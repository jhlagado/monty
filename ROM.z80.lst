0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $2000   ; TODO: set this to TEC 1G
0000                ROMSIZE:   EQU   $2000   
0000                RAMSIZE:   EQU   $2000   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   hl   
0009   2A D0 23               LD   hl,(RST08)   
000C   E3                     EX   (sp),hl   
000D   C9                     RET      
000E                             ; 
000E                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   hl   
0011   2A D2 23               LD   hl,(RST10)   
0014   E3                     EX   (sp),hl   
0015   C9                     RET      
0016                             ; 
0016                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   hl   
0019   2A D4 23               LD   hl,(RST18)   
001C   E3                     EX   (sp),hl   
001D   C9                     RET      
001E                             ; 
001E                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   hl   
0021   2A D6 23               LD   hl,(RST20)   
0024   E3                     EX   (sp),hl   
0025   C9                     RET      
0026                             ; 
0026                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   hl   
0029   2A D8 23               LD   hl,(RST28)   
002C   E3                     EX   (sp),hl   
002D   C9                     RET      
002E                             ; 
002E                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   hl   
0031   2A DA 23               LD   hl,(RST30)   
0034   E3                     EX   (sp),hl   
0035   ED 4D                  RETI      
0037                             ; 
0037                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   hl   
0039   2A DE 23               LD   hl,(INTVEC)   
003C   E3                     EX   (sp),hl   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A E0 23               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A E2 23               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A E4 23               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 21               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 D0 23               LD   (RST08),HL   
0094   22 D2 23               LD   (RST10),HL   
0097   22 D4 23               LD   (RST18),HL   
009A   22 D6 23               LD   (RST20),HL   
009D   22 D8 23               LD   (RST28),HL   
00A0   22 DA 23               LD   (RST30),HL   
00A3   22 DE 23               LD   (INTVEC),HL   
00A6   22 E0 23               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 E2 23               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 E4 23               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   31 00 21               LD   sp,STACK   ; start Monty
00C6   C3 A5 10               JP   start   
00C9                             ; 
00C9                             ; *************************************************************************
00C9                             ; 
00C9                             ;  Monty programming language for the Z80
00C9                             ; 
00C9                             ;  by John Hardy 2023
00C9                             ; 
00C9                             ;  GNU GENERAL PUBLIC LICENSE    Version 3, 29 June 2007
00C9                             ; 
00C9                             ;  see the LICENSE file in this repo for more information
00C9                             ; 
00C9                             ;  Incorporating code from the MINT project by Ken Boak and Craig Jones.
00C9                             ;  Inspiration from Charles H. Moore, Peter Jakacki and André Staltz
00C9                             ; 
00C9                             ; *****************************************************************************
00C9                TRUE:     EQU   -1   ; C-style true
00C9                FALSE:    EQU   0   
00C9                NUL:      EQU   0   ; exit code
00C9                DQ:       EQU   $22   ; " double quote char
00C9                CTRL_C:   EQU   3   
00C9                CTRL_E:   EQU   5   
00C9                CTRL_H:   EQU   8   
00C9                CTRL_J:   EQU   10   
00C9                CTRL_L:   EQU   12   
00C9                CTRL_P:   EQU   16   
00C9                CTRL_S:   EQU   19   
00C9                ESC:      EQU   27   
00C9                             ; macros for inlining a onty function in assembly
00C9                             ; follow immediately with a null terminated block of Monty code
00C9                .macro FUNC,name,numLocals,argsStr
00C9                             ; 
00C9                name:
00C9                 call go
00C9                 dw NUL                      ; NUL closure
00C9                 dw name%%M
00C9                 dw $+2
00C9                 db numLocals                ; num_locals
00C9                 .pstr argsStr
00C9                name%%M:
00C9                .endm
00C9                 
00C9                .macro PERFORM,name
00C9                             ; 
00C9                 ld ix,perform%%M
00C9                 jp name
00C9                perform%%M:
00C9                .endm
00C9                 
0180                          .ORG   ROMSTART + $180   ; 0+180 put monty code from here	
0180                             ;********************** PAGE 1 BEGIN *********************************************
0180                OPCODES:      
0180   21                     DB   lsb(bang_)   ; !     1
0181   0C                     DB   lsb(dquote_)   ; "     2
0182   5E                     DB   lsb(hash_)   ; #     1
0183   09                     DB   lsb(dollar_)   ; $     1
0184   12                     DB   lsb(percent_)   ; %     1
0185   73                     DB   lsb(amper_)   ; &     1
0186   0C                     DB   lsb(quote_)   ; '     2
0187   18                     DB   lsb(lparen_)   ; (     1
0188   6B                     DB   lsb(rparen_)   ; )     1
0189   A5                     DB   lsb(star_)   ; *     1
018A   C9                     DB   lsb(plus_)   ; +     1
018B   06                     DB   lsb(comma_)   ; ,     2
018C   7D                     DB   lsb(minus_)   ; -     1
018D   0F                     DB   lsb(dot_)   ; .     2
018E   1B                     DB   lsb(slash_)   ; /	    1
018F   1E                     DB   lsb(num_)   ; 0     1
0190   1E                     DB   lsb(num_)   ; 1
0191   1E                     DB   lsb(num_)   ; 2
0192   1E                     DB   lsb(num_)   ; 3
0193   1E                     DB   lsb(num_)   ; 4
0194   1E                     DB   lsb(num_)   ; 5
0195   1E                     DB   lsb(num_)   ; 6
0196   1E                     DB   lsb(num_)   ; 7
0197   1E                     DB   lsb(num_)   ; 8
0198   1E                     DB   lsb(num_)   ; 9
0199   04                     DB   lsb(colon_)   ; :     2
019A   5E                     DB   lsb(semicolon_)   ; ;     2
019B   4C                     DB   lsb(lt_)   ; <     1
019C   32                     DB   lsb(eq_)   ; =     1
019D   41                     DB   lsb(gt_)   ; >     1
019E   15                     DB   lsb(question_)   ; ?     1
019F   E9                     DB   lsb(at_)   ; @     2
01A0   E5                     DB   lsb(upcase_)   ; A     1
01A1   E5                     DB   lsb(upcase_)   ; B
01A2   E5                     DB   lsb(upcase_)   ; C
01A3   E5                     DB   lsb(upcase_)   ; D
01A4   E5                     DB   lsb(upcase_)   ; E
01A5   E5                     DB   lsb(upcase_)   ; F
01A6   E5                     DB   lsb(upcase_)   ; G
01A7   E5                     DB   lsb(upcase_)   ; h
01A8   E5                     DB   lsb(upcase_)   ; I
01A9   E5                     DB   lsb(upcase_)   ; J
01AA   E5                     DB   lsb(upcase_)   ; K
01AB   E5                     DB   lsb(upcase_)   ; L
01AC   E5                     DB   lsb(upcase_)   ; M
01AD   E5                     DB   lsb(upcase_)   ; N
01AE   E5                     DB   lsb(upcase_)   ; O
01AF   E5                     DB   lsb(upcase_)   ; p
01B0   E5                     DB   lsb(upcase_)   ; Q
01B1   E5                     DB   lsb(upcase_)   ; R
01B2   E5                     DB   lsb(upcase_)   ; S
01B3   E5                     DB   lsb(upcase_)   ; T
01B4   E5                     DB   lsb(upcase_)   ; U
01B5   E5                     DB   lsb(upcase_)   ; V
01B6   E5                     DB   lsb(upcase_)   ; W
01B7   E5                     DB   lsb(upcase_)   ; X
01B8   E5                     DB   lsb(upcase_)   ; Y
01B9   E5                     DB   lsb(upcase_)   ; Z
01BA   12                     DB   lsb(lbrack_)   ; [     2
01BB   2E                     DB   lsb(backslash_)   ; \     2
01BC   4F                     DB   lsb(rbrack_)   ; ]     2
01BD   9F                     DB   lsb(caret_)   ; ^     1
01BE   E1                     DB   lsb(underscore_)   ; _     2
01BF   B5                     DB   lsb(grave_)   ; `     2   	
01C0   00                     DB   lsb(lowcase_)   ; a     1
01C1   00                     DB   lsb(lowcase_)   ; b
01C2   00                     DB   lsb(lowcase_)   ; c
01C3   00                     DB   lsb(lowcase_)   ; d
01C4   00                     DB   lsb(lowcase_)   ; e
01C5   00                     DB   lsb(lowcase_)   ; f
01C6   00                     DB   lsb(lowcase_)   ; g
01C7   00                     DB   lsb(lowcase_)   ; h
01C8   00                     DB   lsb(lowcase_)   ; i
01C9   00                     DB   lsb(lowcase_)   ; j
01CA   00                     DB   lsb(lowcase_)   ; k
01CB   00                     DB   lsb(lowcase_)   ; l
01CC   00                     DB   lsb(lowcase_)   ; m
01CD   00                     DB   lsb(lowcase_)   ; n
01CE   00                     DB   lsb(lowcase_)   ; o
01CF   00                     DB   lsb(lowcase_)   ; p
01D0   00                     DB   lsb(lowcase_)   ; q
01D1   00                     DB   lsb(lowcase_)   ; r
01D2   00                     DB   lsb(lowcase_)   ; s
01D3   00                     DB   lsb(lowcase_)   ; t
01D4   00                     DB   lsb(lowcase_)   ; u
01D5   00                     DB   lsb(lowcase_)   ; v
01D6   00                     DB   lsb(lowcase_)   ; w
01D7   00                     DB   lsb(lowcase_)   ; x
01D8   00                     DB   lsb(lowcase_)   ; y
01D9   00                     DB   lsb(lowcase_)   ; z
01DA   CB                     DB   lsb(lbrace_)   ; {     1
01DB   D0                     DB   lsb(pipe_)   ; |     1
01DC   DB                     DB   lsb(rbrace_)   ; }     1
01DD   DE                     DB   lsb(tilde_)   ; ~     1
01DE                             ;********************** PAGE 1 END *********************************************
01DE                             ; ***********************************************************************
01DE                             ; Initial values for system vars		
01DE                             ; ***********************************************************************		
01DE                ISYSVARS:      
01DE   00 21                  DW   TIB   ; vTIBPtr pointer into TIB
01E0   00 22                  DW   BUFFER   ; vBufPtr pointer into BUF
01E2   22 24                  DW   HEAP   ; vHeapPtr \h start of the free mem
01E4   00 00                  DW   NUL   ; vRecurPtr
01E6   02                     DB   2   ; vDataWidth in bytes of array operations (default 1 byte)
01E7   0A                     DB   10   ; vNumBase = 10
01E8   24                     DB   "$"   ; vHexPrefix
01E9   FF                     DB   TRUE   ; vEcho
01EA   00                     DB   FALSE   ; vStrMode
01EB   00                     DB   0   
01EC   00                     DB   0   
01ED   00                     DB   0   
01EE   00                     DB   0   
01EF   00                     DB   0   
01F0                             ; **********************************************************************			
01F0                             ; title string (also used by warm boot)
01F0                             ; **********************************************************************
01F0                TITLESTR:      
01F0   1B 5B 32 4A 4D 6F 6E 74 79 20 56 30 2E 31 0D 0A 00 00 00 00 .CSTR   ESC,"[2JMonty V0.1\r\n",0,0,0   
0204                             ;********************** PAGE 2 BEGIN ***********************************
0204                COLON_:      
0204   DD E9                  JP   (ix)   
0206                COMMA_:      
0206   C3 5E 0B               JP   comma   
0209                DOLLAR_:      
0209   C3 E1 0B               JP   dollar   
020C                DQUOTE_:      
020C                QUOTE_:      
020C   C3 0B 0C               JP   quote   
020F                DOT_:        
020F   C3 00 04               JP   dot   
0212                PERCENT_:      
0212   C3 25 0C               JP   percent   
0215                QUESTION_:      
0215   C3 FE 0B               JP   question   
0218                LPAREN_:      
0218   C3 CB 03               JP   lbrace   
021B                SLASH_:      
021B   C3 00 05               JP   slash   
021E                NUM_:        
021E   C3 5A 0C               JP   num   
0221                BANG_:       
0221                BANG:        ; logical invert, any non zero value
0221   03                     INC   bc   
0222   0A                     LD   a,(bc)   
0223   FE 3D                  CP   "="   
0225   20 05                  JR   nz,not   
0227   E1                     POP   hl   
0228   D1                     POP   de   
0229   C3 9C 0D               JP   notequals   
022C                NOT:         
022C   0B                     DEC   bc   
022D   21 00 00               LD   hl,0   ; is considered true
0230   18 0B                  JR   eq1   
0232                EQ_:         
0232                EQ:          
0232   03                     INC   bc   
0233   0A                     LD   a,(bc)   
0234   FE 3D                  CP   "="   
0236   28 04                  JR   z,eq0   
0238   0B                     DEC   bc   
0239   C3 84 0D               JP   assign   
023C                EQ0:         
023C   E1                     POP   hl   
023D                EQ1:         
023D   D1                     POP   de   
023E   C3 95 0D               JP   equals   
0241                GT_:         
0241                GT:          
0241   03                     INC   bc   
0242   0A                     LD   a,(bc)   
0243   FE 3E                  CP   ">"   
0245   CA FC 0D               JP   z,shiftRight   
0248   D1                     POP   de   
0249   E1                     POP   hl   
024A   18 09                  JR   lt1   
024C                LT_:         
024C                LT:          
024C   03                     INC   bc   
024D   0A                     LD   a,(bc)   
024E   FE 3C                  CP   "<"   
0250   CA E0 0D               JP   z,shiftLeft   
0253   E1                     POP   hl   
0254   D1                     POP   de   
0255                LT1:         
0255   FE 3D                  CP   "="   
0257   CA A3 0D               JP   z,lessthaneq   
025A   0B                     DEC   bc   
025B   C3 A8 0D               JP   lessthan   
025E                             ; index of an array, based on vDataWidth 22
025E                             ; array* num -- value    ; also sets vPointer to address
025E                HASH_:       
025E                SEMICOLON_:      
025E                SEMICOLON:      
025E                ARRAYINDEX:      
025E   E1                     POP   hl   ; hl = index
025F   D1                     POP   de   ; de = array
0260   3A EE 23               LD   a,(vDataWidth)   ; a = data width
0263   3D                     DEC   a   
0264   28 01                  JR   z,arrayIndex1   
0266                ARRAYINDEX0:      
0266   29                     ADD   hl,hl   ; if data width = 2 then double
0267                ARRAYINDEX1:      
0267   19                     ADD   hl,de   ; add addr
0268   C3 95 0F               JP   variable   
026B                             ;                               4
026B                RPAREN_:      
026B                             ; jp rparen
026B                RPAREN:      
026B   FD 4E 08               LD   c,(iy+8)   ; IP = block* just under stack frame
026E   FD 46 09               LD   b,(iy+9)   
0271   DD E9                  JP   (ix)   
0273                             ; & and                          14
0273                             ; a b -- c
0273                AMPER_:      
0273                AMPER:       
0273                AND:         
0273   D1                     POP   de   ; Bitwise and the top 2 elements of the stack
0274   E1                     POP   hl   
0275   7B                     LD   a,e   
0276   A5                     AND   l   
0277   6F                     LD   l,a   
0278   7A                     LD   a,d   
0279   A4                     AND   h   
027A   67                     LD   h,a   
027B   18 5B                  JR   add3   
027D                             ; - sub
027D                             ; a b -- c
027D                             ; -- sub
027D                             ; b1 -- b2
027D                             ; -= sub
027D                             ; a b1 -- b2
027D                MINUS_:      
027D                MINUS:       
027D   03                     INC   bc   ; check if sign of a number
027E   0A                     LD   a,(bc)   
027F   0B                     DEC   bc   
0280   FE 30                  CP   "0"   
0282   38 05                  JR   c,sub   
0284   FE 3A                  CP   "9"+1   
0286   DA 5A 0C               JP   c,num   
0289                SUB:         ; Subtract the value 2nd on stack from top of stack
0289   E1                     POP   hl   ; hl = arg_b
028A   03                     INC   bc   
028B   FE 2D                  CP   "-"   
028D   20 04                  JR   nz,sub1   
028F   2B                     DEC   hl   ; --
0290   C3 86 0D               JP   assign0   
0293                SUB1:        
0293   D1                     POP   de   ; de = arg_a
0294   FE 3D                  CP   "="   
0296   28 02                  JR   z,sub2   
0298   0B                     DEC   bc   ; -
0299   EB                     EX   de,hl   
029A                SUB2:        
029A   B7                     OR   a   ; -=
029B   ED 52                  SBC   hl,de   
029D                SUB3:        
029D   FE 3D                  CP   "="   
029F   CA 86 0D               JP   z,assign0   
02A2   E5                     PUSH   hl   
02A3   DD E9                  JP   (ix)   
02A5                STAR_:       ; 21
02A5                STAR:        
02A5   03                     INC   bc   ; check for ** spread
02A6   0A                     LD   a,(bc)   
02A7   FE 2A                  CP   "*"   
02A9   CA BC 0D               JP   z,spread   
02AC   0B                     DEC   bc   
02AD                MUL:         
02AD   D1                     POP   de   ; get first value
02AE   E1                     POP   hl   
02AF                MUL2:        
02AF   C5                     PUSH   bc   ; Preserve the IP
02B0   44 4D                  LD   bc,hl   ; bc = 2nd value
02B2   21 00 00               LD   hl,0   
02B5   3E 10                  LD   a,16   
02B7                MUL3:        
02B7   29                     ADD   hl,hl   
02B8   CB 13                  RL   e   
02BA   CB 12                  RL   d   
02BC   30 04                  JR   nc,$+6   
02BE   09                     ADD   hl,bc   
02BF   30 01                  JR   nc,$+3   
02C1   13                     INC   de   
02C2   3D                     DEC   a   
02C3   20 F2                  JR   nz,mul3   
02C5   C1                     POP   bc   ; Restore the IP
02C6   C3 D8 02               JP   add3   
02C9                             ; + add                         25
02C9                             ; a b -- c
02C9                PLUS_:       
02C9                PLUS:        
02C9                ADD:         
02C9   03                     INC   bc   
02CA   0A                     LD   a,(bc)   
02CB   FE 2B                  CP   "+"   ; ++ increment variable
02CD   20 05                  JR   nz,add1   
02CF   E1                     POP   hl   
02D0   23                     INC   hl   
02D1   C3 86 0D               JP   assign0   
02D4                ADD1:        
02D4   0B                     DEC   bc   
02D5   D1                     POP   de   ; second term
02D6   E1                     POP   hl   ; first term
02D7   19                     ADD   hl,de   
02D8                ADD3:        
02D8   03                     INC   bc   
02D9   0A                     LD   a,(bc)   
02DA   FE 3D                  CP   "="   
02DC   28 04                  JR   z,add4   
02DE   0B                     DEC   bc   
02DF   E5                     PUSH   hl   
02E0   DD E9                  JP   (ix)   
02E2                ADD4:        
02E2   C3 86 0D               JP   assign0   
02E5                             ;                               18
02E5                UPCASE_:      
02E5                UPCASE:      
02E5   0A                     LD   a,(bc)   ; a = identifier char
02E6   D6 41                  SUB   "A"   ; "A" = 0
02E8   18 1B                  JR   ident1   
02EA                             ;********************** PAGE 2 END *********************************************
02EA                          ALIGN   $100   
0300                             ;********************** PAGE 3 BEGIN *********************************************
0300                LOWCASE_:      
0300                LOWCASE:      
0300   0A                     LD   a,(bc)   
0301   D6 61                  SUB   "a"   
0303   C6 1A                  ADD   a,26   
0305                IDENT1:      
0305   87                     ADD   a,a   ; l = a * 2
0306   6F                     LD   l,a   
0307   26 23                  LD   h,msb(VARS)   
0309   22 F8 23               LD   (vPointer),hl   ; store address in setter
030C   5E                     LD   e,(hl)   
030D   23                     INC   hl   
030E   56                     LD   d,(hl)   
030F   D5                     PUSH   de   
0310   DD E9                  JP   (ix)   
0312                             ; [                             14
0312                LBRACK_:      
0312                LBRACK:      
0312                ARRAYSTART:      
0312   11 00 00               LD   de,0   ; create stack frame
0315   D5                     PUSH   de   ; push null for IP
0316   FD 5E 04               LD   e,(iy+4)   ; push arg_list* from parent stack frame
0319   FD 56 05               LD   d,(iy+5)   ; 
031C   D5                     PUSH   de   ; 
031D   FD 5E 02               LD   e,(iy+2)   ; push first_arg* from parent stack frame
0320   FD 56 03               LD   d,(iy+3)   ; 
0323   D5                     PUSH   de   ; 
0324   FD E5                  PUSH   iy   ; push BP
0326   FD 21 00 00            LD   iy,0   ; BP = SP
032A   FD 39                  ADD   iy,sp   
032C   DD E9                  JP   (ix)   
032E                             ; \                             19
032E                BACKSLASH_:      
032E                BACKSLASH:      
032E                LAMBDA:      
032E   DD E5                  PUSH   ix   
0330   CD 4E 0E               CALL   parseArgs   
0333                LAMBDA1:      
0333   03                     INC   bc   ; arg_list must ve immediately followed by {
0334   0A                     LD   a,(bc)   
0335   FE 21                  CP   " "+1   ; skip white space
0337   38 FA                  JR   c,lambda1   
0339   FE 7B                  CP   "{"   
033B   28 06                  JR   z,lambda2   
033D   21 02 00               LD   hl,2   ; error 2: parse error
0340   C3 4B 11               JP   error   
0343                LAMBDA2:      
0343   CD 84 0E               CALL   parseBlock   
0346   CD F3 0E               CALL   createFunc   
0349   E1                     POP   hl   
034A   DD E1                  POP   ix   
034C   E5                     PUSH   hl   
034D   DD E9                  JP   (ix)   
034F                RBRACK_:      
034F                RBRACK:      
034F                ARRAYEND:      ; 53
034F   FD 54                  LD   d,iyh   ; de = BP
0351   FD 5D                  LD   e,iyl   
0353   ED 43 04 24            LD   (vTemp1),bc   ; save IP
0357   62 6B                  LD   hl,de   ; hl = de = BP
0359   B7                     OR   a   
035A   ED 72                  SBC   hl,sp   ; hl = array count (items on stack)
035C   CB 3C                  SRL   h   ; 
035E   CB 1D                  RR   l   
0360   44 4D                  LD   bc,hl   ; bc = count
0362   2A EA 23               LD   hl,(vHeapPtr)   ; hl = array[-4]
0365   71                     LD   (hl),c   ; write num items in length word
0366   23                     INC   hl   
0367   70                     LD   (hl),b   
0368   23                     INC   hl   ; hl = array[0], bc = count
0369                             ; de = BP, hl = array[0], bc = count
0369   18 15                  JR   arrayEnd3   
036B                ARRAYEND1:      
036B   FD 7E FE               LD   a,(iy-2)   ; a = lsb of stack item
036E   77                     LD   (hl),a   ; write lsb of array item
036F   23                     INC   hl   ; move to msb of array item
0370   3A EE 23               LD   a,(vDataWidth)   ; vDataWidth=1?
0373   3D                     DEC   a   
0374   28 05                  JR   z,arrayEnd2   
0376   FD 7E FF               LD   a,(iy-1)   ; a = msb of stack item
0379   77                     LD   (hl),a   ; write msb of array item
037A   23                     INC   hl   ; move to next word in array
037B                ARRAYEND2:      
037B   FD 2B                  DEC   iy   ; move to next word on stack
037D   FD 2B                  DEC   iy   
037F   0B                     DEC   bc   ; dec items count
0380                ARRAYEND3:      
0380   79                     LD   a,c   ; if not zero loop
0381   B0                     OR   b   
0382   20 E7                  JR   nz,arrayEnd1   
0384   EB                     EX   de,hl   ; de = end of array, hl = BP
0385   F9                     LD   sp,hl   ; sp = BP
0386   E1                     POP   hl   ; de = end of array, hl = old BP
0387   EB                     EX   de,hl   ; iy = de = old BP, hl = end of array
0388   FD 62                  LD   iyh,d   
038A   FD 6B                  LD   iyl,e   
038C   D1                     POP   de   ; pop arg_list (discard)
038D   D1                     POP   de   ; pop first_arg* (discard)
038E   D1                     POP   de   ; pop IP (discard)
038F   ED 5B EA 23            LD   de,(vHeapPtr)   ; de = array[-2]
0393   13                     INC   de   
0394   13                     INC   de   
0395   D5                     PUSH   de   ; return array[0]
0396   22 EA 23               LD   (vHeapPtr),hl   ; move heap* to end of array
0399   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
039D   DD E9                  JP   (ix)   
039F                CARET_:      
039F                             ; execute a block of code which ends with } 116
039F                             ; creates a root scope if BP == stack
039F                             ; else uses outer scope
039F                CARET:       
039F                GO:          
039F   D1                     POP   de   ; de = block*
03A0                GO1:         
03A0   7B                     LD   a,e   ; if block* == null, exit
03A1   B2                     OR   d   
03A2   20 02                  JR   nz,go2   
03A4   DD E9                  JP   (ix)   
03A6                GO2:         
03A6   1A                     LD   a,(de)   
03A7   FE 7B                  CP   "{"   
03A9   CA F7 0C               JP   z,goBlock   
03AC   FE 28                  CP   "("   
03AE   C2 2A 0D               JP   nz,goFunc   
03B1   D5                     PUSH   de   ; push de just before stack frame
03B2   CA F7 0C               JP   z,goBlock   
03B5                GRAVE_:      
03B5                GRAVE:       
03B5                PRINTLITERAL:      
03B5   03                     INC   bc   ; move to first char
03B6   ED 5B E8 23            LD   de,(vBufPtr)   ; de = buffer*
03BA   18 03                  JR   printLiteral1   
03BC                PRINTLITERAL0:      
03BC   12                     LD   (de),a   ; a -> buffer*
03BD   13                     INC   de   ; string*++,
03BE   03                     INC   bc   
03BF                PRINTLITERAL1:      
03BF   0A                     LD   a,(bc)   ; a <- string*
03C0   FE 60                  CP   "`"   ; if ` exit loop
03C2   20 F8                  JR   nz,printLiteral0   
03C4   ED 53 E8 23            LD   (vBufPtr),de   ; save buffer*' in pointer
03C8   C3 34 0E               JP   dotNext   
03CB                LBRACE_:      
03CB                LBRACE:      
03CB   CD 84 0E               CALL   parseBlock   
03CE   DD E9                  JP   (ix)   
03D0                             ; | or                          11
03D0                             ; a b -- c
03D0                PIPE_:       
03D0                PIPE:        
03D0                OR:          
03D0   D1                     POP   de   ; Bitwise or the top 2 elements of the stack
03D1   E1                     POP   hl   
03D2   7B                     LD   a,e   
03D3   B5                     OR   l   
03D4   6F                     LD   l,a   
03D5   7A                     LD   a,d   
03D6   B4                     OR   h   
03D7   67                     LD   h,a   
03D8   C3 D8 02               JP   add3   
03DB                RBRACE_:      
03DB   C3 8A 0C               JP   rbrace   
03DE                             ; ~ char                        8
03DE                TILDE_:      
03DE   C3 D7 0B               JP   tilde   
03E1                UNDERSCORE_:      
03E1                CHAR:        
03E1   03                     INC   bc   ; point to next char
03E2   0A                     LD   a,(bc)   
03E3   6F                     LD   l,a   
03E4   26 00                  LD   h,0   
03E6   E5                     PUSH   hl   
03E7   DD E9                  JP   (ix)   
03E9                AT_:         
03E9                AT:          
03E9                ADDR:        
03E9   ED 5B F8 23            LD   de,(vPointer)   
03ED   21 F8 23               LD   hl,vPointer   
03F0   C3 95 0F               JP   variable   
03F3                             ;********************** PAGE 3 END *********************************************
03F3                          ALIGN   $100   
0400                             ;********************** PAGE 4 BEGIN *********************************************
0400                             ;                               67
0400                DOT:         
0400                PRINT:       
0400   CD C2 0F               CALL   cmdTable   
0403   61 00                  DB   "a",0   ; .a print array
0405   15 0B                  DW   printArray   
0407   63 00                  DB   "c",0   ; .c print char
0409   13 04                  DW   printChar   
040B   73 00                  DB   "s",0   ; .s print string
040D   22 04                  DW   printString   
040F   00 00                  DW   0   ; .  print number, fall through
0411   37 04                  DW   printNumber   
0413                             ; .c print char
0413                             ; char --
0413                PRINTCHAR:      
0413   E1                     POP   hl   ; a = char
0414   7D                     LD   a,l   
0415   ED 5B E8 23            LD   de,(vBufPtr)   ; de = buffer*
0419   12                     LD   (de),a   
041A   13                     INC   de   
041B   ED 53 E8 23            LD   (vBufPtr),de   ; save buffer*'
041F   C3 34 0E               JP   dotNext   
0422                             ; .s print string
0422                             ; string* --
0422                PRINTSTRING:      
0422   E1                     POP   hl   ; hl = string*
0423   ED 5B E8 23            LD   de,(vBufPtr)   ; de = buffer*
0427   18 03                  JR   printString1   
0429                PRINTSTRING0:      
0429   12                     LD   (de),a   ; a -> buffer*
042A   13                     INC   de   ; string*++,
042B   23                     INC   hl   
042C                PRINTSTRING1:      
042C   7E                     LD   a,(hl)   ; a <- string*
042D   B7                     OR   a   ; if NUL exit loop
042E   20 F9                  JR   nz,printString0   
0430   ED 53 E8 23            LD   (vBufPtr),de   ; save buffer*' in pointer
0434   C3 34 0E               JP   dotNext   
0437                             ; . print decimal
0437                             ; value --
0437                PRINTNUMBER:      
0437   3A EF 23               LD   a,(vNumBase)   
043A   FE 10                  CP   16   
043C   CA A8 04               JP   z,printHex   ; else falls through
043F   C3 42 04               JP   printDec   
0442                             ; print decimal                 ; 70
0442                             ; value --
0442                PRINTDEC:      
0442   ED 5B E8 23            LD   de,(vBufPtr)   ; de"= buffer* bc" = IP
0446   D9                     EXX      
0447   E1                     POP   hl   ; hl = value
0448   3A EE 23               LD   a,(vDataWidth)   
044B   3D                     DEC   a   
044C   20 02                  JR   nz,printDec1   
044E   26 00                  LD   h,0   
0450                PRINTDEC1:      
0450   CD 5F 04               CALL   printDec2   
0453   D9                     EXX      ; de = buffer*' bc = IP
0454   3E 20                  LD   a," "   ; append space to buffer
0456   12                     LD   (de),a   
0457   13                     INC   de   ; string*++,
0458   ED 53 E8 23            LD   (vBufPtr),de   ; update buffer* with buffer*'
045C   C3 34 0E               JP   dotNext   
045F                             ; hl = value
045F                             ; de' = buffer*
045F                             ; a, bc, de, hl destroyed
045F                PRINTDEC2:      
045F   CB 7C                  BIT   7,h   
0461   28 0C                  JR   z,printDec3   
0463   D9                     EXX      
0464   3E 2D                  LD   a,"-"   
0466   12                     LD   (de),a   
0467   13                     INC   de   
0468   D9                     EXX      
0469   AF                     XOR   a   
046A   95                     SUB   l   
046B   6F                     LD   l,a   
046C   9F                     SBC   a,a   
046D   94                     SUB   h   
046E   67                     LD   h,a   
046F                PRINTDEC3:      
046F   0E 00                  LD   c,0   ; leading zeros flag = false
0471   11 F0 D8               LD   de,-10000   
0474   CD 8F 04               CALL   printDec4   
0477   11 18 FC               LD   de,-1000   
047A   CD 8F 04               CALL   printDec4   
047D   11 9C FF               LD   de,-100   
0480   CD 8F 04               CALL   printDec4   
0483   1E F6                  LD   e,-10   
0485   CD 8F 04               CALL   printDec4   
0488   0C                     INC   c   ; flag = true for at least digit
0489   1E FF                  LD   e,-1   
048B   CD 8F 04               CALL   printDec4   
048E   C9                     RET      
048F                PRINTDEC4:      
048F   06 2F                  LD   b,"0"-1   
0491                PRINTDEC5:      
0491   04                     INC   b   
0492   19                     ADD   hl,de   
0493   38 FC                  JR   c,printDec5   
0495   ED 52                  SBC   hl,de   
0497   3E 30                  LD   a,"0"   
0499   B8                     CP   b   
049A   20 05                  JR   nz,printDec6   
049C   AF                     XOR   a   
049D   B1                     OR   c   
049E   C8                     RET   z   
049F   18 01                  JR   printDec7   
04A1                PRINTDEC6:      
04A1   0C                     INC   c   
04A2                PRINTDEC7:      
04A2   78                     LD   a,b   
04A3   D9                     EXX      
04A4   12                     LD   (de),a   
04A5   13                     INC   de   
04A6   D9                     EXX      
04A7   C9                     RET      
04A8                             ; buffer hex                    37
04A8                             ; value --
04A8                PRINTHEX:      
04A8   ED 5B E8 23            LD   de,(vBufPtr)   
04AC   3A F0 23               LD   a,(vHexPrefix)   ; "$"
04AF   B7                     OR   a   ; skip if null
04B0   28 02                  JR   z,printHex1   
04B2   12                     LD   (de),a   
04B3   13                     INC   de   ; string*++,
04B4                PRINTHEX1:      
04B4   E1                     POP   hl   ; hl = value
04B5   3A EE 23               LD   a,(vDataWidth)   
04B8   3D                     DEC   a   
04B9   28 04                  JR   z,printHex2   
04BB   7C                     LD   a,h   
04BC   CD CE 04               CALL   printHex3   
04BF                PRINTHEX2:      
04BF   7D                     LD   a,l   
04C0   CD CE 04               CALL   printHex3   
04C3   3E 20                  LD   a," "   ; append space to buffer
04C5   12                     LD   (de),a   
04C6   13                     INC   de   ; string*++,
04C7   ED 53 E8 23            LD   (vBufPtr),de   
04CB   C3 34 0E               JP   dotNext   
04CE                PRINTHEX3:      
04CE   F5                     PUSH   af   
04CF   1F                     RRA      
04D0   1F                     RRA      
04D1   1F                     RRA      
04D2   1F                     RRA      
04D3   CD D7 04               CALL   printHex4   
04D6   F1                     POP   af   
04D7                PRINTHEX4:      
04D7   E6 0F                  AND   0x0F   
04D9   C6 90                  ADD   a,0x90   
04DB   27                     DAA      
04DC   CE 40                  ADC   a,0x40   
04DE   27                     DAA      
04DF   12                     LD   (de),a   
04E0   13                     INC   de   ; string*++,
04E1   C9                     RET      
04E2                             ;********************** PAGE 4 END *********************************************
04E2                          ALIGN   $100   
0500                             ;********************** PAGE 5 BEGIN *********************************************
0500                SLASH:       
0500                COMMAND:      
0500   03                     INC   bc   
0501   0A                     LD   a,(bc)   
0502   FE 2F                  CP   "/"   ; // comment
0504   CA CB 06               JP   z,comment   
0507   0B                     DEC   bc   
0508   CD A7 0F               CALL   charTable   
050B   26                     DB   lsb(command_a_)   
050C   45                     DB   lsb(command_b_)   
050D   00                     DB   0   
050E   54                     DB   lsb(command_d_)   
050F   00                     DB   0   
0510   6E                     DB   lsb(command_f_)   
0511   00                     DB   0   
0512   A1                     DB   lsb(command_h_)   
0513   AC                     DB   lsb(command_i_)   
0514   00                     DB   0   
0515   00                     DB   0   
0516   00                     DB   0   
0517   B7                     DB   lsb(command_m_)   
0518   00                     DB   0   
0519   CA                     DB   lsb(comand_o_)   
051A   D5                     DB   lsb(command_p_)   
051B   00                     DB   0   
051C   DC                     DB   lsb(command_r_)   
051D   DE                     DB   lsb(command_s_)   
051E   E0                     DB   lsb(command_t_)   
051F   00                     DB   0   
0520   E2                     DB   lsb(command_v_)   
0521   E4                     DB   lsb(command_w_)   
0522   E6                     DB   lsb(command_x_)   
0523   00                     DB   0   
0524   00                     DB   0   
0525   E8                     DB   lsb(command_default_)   
0526                             ; 12
0526                COMMAND_A_:      
0526   CD C2 0F               CALL   cmdTable   
0529   62 73                  DB   "bs"   ; /abs absolute
052B   77 06                  DW   absolute   
052D   64 72                  DB   "dr"   ; /adr address of
052F   85 06                  DW   addrOf   
0531   69 00                  DB   "i",0   ; /ai array iterator
0533   83 08                  DW   arrayIter   
0535   6C 63                  DB   "lc"   ; /alc mem allocate
0537   F7 06                  DW   memAllocate   
0539   6C 6E                  DB   "ln"   ; /al array length
053B   8D 06                  DW   arrayLength   
053D   73 00                  DB   "s",0   ; /as array size
053F   96 06                  DW   arraySize   
0541   00 00                  DW   0   
0543   E6 06                  DW   error1   
0545                COMMAND_B_:      
0545   CD C2 0F               CALL   cmdTable   
0548   79 65                  DB   "ye"   ; /bye cold reboot
054A   9C 10                  DW   coldStart   
054C   79 74                  DB   "yt"   ; /byt byte mode
054E   C4 06                  DW   byteMode   
0550   00 00                  DW   0   
0552   E6 06                  DW   error1   
0554                COMMAND_D_:      
0554   CD C2 0F               CALL   cmdTable   
0557   65 63                  DB   "ec"   ; /dec decimal
0559   D4 06                  DW   decBase   
055B   00 00                  DW   0   
055D   E6 06                  DW   error1   
055F                COMMAND_E:      
055F   CD C2 0F               CALL   cmdTable   
0562   63 68                  DB   "ch"   
0564   DB 06                  DW   echo   
0566   6E 64                  DB   "nd"   
0568   6A 07                  DW   stringEnd   
056A   00 00                  DW   0   
056C   E6 06                  DW   error1   
056E                COMMAND_F_:      
056E   CD C2 0F               CALL   cmdTable   
0571   61 6C                  DB   "al"   ; /fal false
0573   B6 0D                  DW   false1   
0575   64 00                  DB   "d",0   ; /fd fold
0577   3D 0A                  DW   fold   
0579   6F 72                  DB   "or"   ; /for forEach
057B   8E 0A                  DW   forEach   
057D   72 65                  DB   "re"   ; /fre free memory
057F   F9 06                  DW   memFree   
0581   72 61                  DB   "ra"   ; /fra free memory array
0583   FF 06                  DW   memFreeArray   
0585   73 00                  DB   "s",0   ; /fs funcSrc
0587   DA 0A                  DW   funcSrc   
0589   74 00                  DB   "t",0   ; /ft filter
058B   DC 09                  DW   filter   
058D   31 00                  DB   "1",0   
058F   8D 11                  DW   f1   
0591   32 00                  DB   "2",0   
0593   8D 11                  DW   f2   
0595   33 00                  DB   "3",0   
0597   8D 11                  DW   f3   
0599   34 00                  DB   "4",0   
059B   8D 11                  DW   f4   
059D   00 00                  DW   0   
059F   E6 06                  DW   error1   
05A1                COMMAND_H_:      
05A1   CD C2 0F               CALL   cmdTable   
05A4   65 78                  DB   "ex"   ; /hex hex
05A6   E1 06                  DW   hexBase   
05A8   00 00                  DW   0   
05AA   E6 06                  DW   error1   
05AC                COMMAND_I_:      
05AC   CD C2 0F               CALL   cmdTable   
05AF   6E 00                  DB   "n",0   ; /in input
05B1   EC 06                  DW   input   
05B3   00 00                  DW   0   
05B5   E6 06                  DW   error1   
05B7                COMMAND_M_:      
05B7   CD C2 0F               CALL   cmdTable   
05BA   61 70                  DB   "ap"   ; /map map
05BC   9A 09                  DW   map   
05BE   61 78                  DB   "ax"   ; /max maximum
05C0   04 07                  DW   maximum   
05C2   69 6E                  DB   "in"   ; /min minimum
05C4   10 07                  DW   minimum   
05C6   00 00                  DW   0   
05C8   E6 06                  DW   error1   
05CA                COMAND_O_:      
05CA   CD C2 0F               CALL   cmdTable   
05CD   75 74                  DB   "ut"   ; /out out
05CF   1C 07                  DW   output   
05D1   00 00                  DW   0   
05D3   E6 06                  DW   error1   
05D5                COMMAND_P_:      
05D5   CD C2 0F               CALL   cmdTable   
05D8   00 00                  DW   0   
05DA   E6 06                  DW   error1   
05DC                COMMAND_R_:      
05DC   18 0D                  JR   command_r   
05DE                COMMAND_S_:      
05DE   18 22                  JR   command_s   
05E0                COMMAND_T_:      
05E0   18 3F                  JR   command_t   
05E2                COMMAND_V_:      
05E2   18 48                  JR   command_v   
05E4                COMMAND_W_:      
05E4   18 55                  JR   command_w   
05E6                COMMAND_X_:      
05E6   18 62                  JR   command_x   
05E8                             ; 3
05E8                COMMAND_DEFAULT_:      
05E8   C3 55 06               JP   command_default   
05EB                             ;********************** PAGE 5 END *********************************************
05EB                             ; .align $100
05EB                COMMAND_R:      
05EB   CD C2 0F               CALL   cmdTable   
05EE   63 00                  DB   "c",0   ; /rc tail call optimisation
05F0   2F 07                  DW   recur   
05F2   65 6D                  DB   "em"   ; /rem remainder
05F4   35 07                  DW   remain   
05F6   65 74                  DB   "et"   ; /ret return
05F8   25 07                  DW   return   
05FA   6E 67                  DB   "ng"   ; /rng range src
05FC   EA 07                  DW   rangeSrc   
05FE   00 00                  DW   0   
0600   E6 06                  DW   error1   
0602                COMMAND_S:      
0602   CD C2 0F               CALL   cmdTable   
0605   63 00                  DB   "c",0   
0607   B4 07                  DW   stringCompare   
0609   65 6C                  DB   "el"   
060B   3B 07                  DW   select   
060D   69 00                  DB   "i",0   
060F   0A 09                  DW   stringIter   
0611   6C 00                  DB   "l",0   
0613   99 07                  DW   stringLength   
0615   73 00                  DB   "s",0   
0617   A8 07                  DW   stringSize   
0619   74 72                  DB   "tr"   ; /str
061B   62 07                  DW   stringBegin   
061D   00 00                  DW   0   
061F   E6 06                  DW   error1   
0621                COMMAND_T:      
0621   CD C2 0F               CALL   cmdTable   
0624   72 75                  DB   "ru"   
0626   B0 0D                  DW   true1   
0628   00 00                  DW   0   
062A   E6 06                  DW   error1   
062C                COMMAND_V:      
062C   CD C2 0F               CALL   cmdTable   
062F   61 72                  DB   "ar"   
0631   00 23                  DW   vars   
0633   6F 69                  DB   "oi"   
0635   D2 07                  DW   void   
0637   00 00                  DW   0   
0639   E6 06                  DW   error1   
063B                COMMAND_W:      
063B   CD C2 0F               CALL   cmdTable   
063E   68 69                  DB   "hi"   ; /whi while true else break from loop
0640   AA 06                  DW   while   
0642   72 64                  DB   "rd"   ; /wrd word mode
0644   DA 07                  DW   wordMode   
0646   00 00                  DW   0   
0648   E6 06                  DW   error1   
064A                COMMAND_X:      
064A   CD C2 0F               CALL   cmdTable   
064D   6F 72                  DB   "or"   ; /xor exclsuive or
064F   DF 07                  DW   xor   
0651   00 00                  DW   0   
0653   E6 06                  DW   error1   
0655                COMMAND_DEFAULT:      
0655   CD C2 0F               CALL   cmdTable   
0658   00 00                  DW   0   
065A   5C 06                  DW   div   
065C                             ;                               32
065C                DIV:         
065C   E1                     POP   hl   ; hl = arg_b
065D   D1                     POP   de   ; de = arg_a
065E   03                     INC   bc   
065F   0A                     LD   a,(bc)   
0660   FE 3D                  CP   "="   
0662   28 02                  JR   z,div2   
0664   0B                     DEC   bc   ; /
0665   EB                     EX   de,hl   
0666                DIV2:        
0666   F5                     PUSH   af   ; preserve af, bc
0667   C5                     PUSH   bc   
0668   44 4D                  LD   bc,hl   
066A   CD 1B 0E               CALL   divide   
066D   EB                     EX   de,hl   
066E   ED 53 FA 23            LD   (vRemain),de   
0672   C1                     POP   bc   ; restore
0673   F1                     POP   af   
0674   C3 9D 02               JP   sub3   
0677                             ; /abs absolute
0677                             ; num -- num
0677                ABSOLUTE:      
0677   E1                     POP   hl   
0678   CB 7C                  BIT   7,h   
067A   28 06                  JR   z,absolute1   
067C   AF                     XOR   a   
067D   95                     SUB   l   
067E   6F                     LD   l,a   
067F   9F                     SBC   a,a   
0680   94                     SUB   h   
0681   67                     LD   h,a   
0682                ABSOLUTE1:      
0682   E5                     PUSH   hl   
0683   DD E9                  JP   (ix)   
0685                             ; /adr addrOf
0685                             ; char -- addr
0685                ADDROF:      
0685   E1                     POP   hl   ; a = char
0686   7D                     LD   a,l   
0687   CD E4 0F               CALL   getVarAddr   
068A   E5                     PUSH   hl   
068B                ADDROF2:      
068B   DD E9                  JP   (ix)   
068D                             ; /al length of an array, num elements
068D                             ; array* -- num
068D                ARRAYLENGTH:      
068D   E1                     POP   hl   
068E   2B                     DEC   hl   ; msb size
068F   56                     LD   d,(hl)   
0690   2B                     DEC   hl   ; lsb size
0691   5E                     LD   e,(hl)   
0692   EB                     EX   de,hl   
0693                ARRAYLENGTH1:      
0693   E5                     PUSH   hl   
0694   DD E9                  JP   (ix)   
0696                             ; /as size in bytes of an array, based on current data width
0696                             ; array* -- num
0696                ARRAYSIZE:      
0696                          ;*Macro unroll:  PERFORM arrayLength
0696   DD 21 9D 06            LD   ix,performM_1513S1072   
069A   C3 8D 06               JP   arrayLength   
069D                PERFORMM_1513S1072:      
069D   E1                     POP   hl   
069E   3A EE 23               LD   a,(vDataWidth)   
06A1   3D                     DEC   a   
06A2   28 EF                  JR   z,arrayLength1   
06A4   CB 3C                  SRL   h   
06A6   CB 1D                  RR   l   
06A8   18 E9                  JR   arrayLength1   
06AA                             ; 13
06AA                             ; /whi while true else break from loop
06AA                             ; --
06AA                WHILE:       
06AA   E1                     POP   hl   ; hl = condition, break if false
06AB   7D                     LD   a,l   
06AC   B4                     OR   h   
06AD   28 02                  JR   z,while1   
06AF   DD E9                  JP   (ix)   
06B1                WHILE1:      
06B1   FD 5D                  LD   e,iyl   ; get block* just under stack frame
06B3   FD 54                  LD   d,iyh   
06B5   21 08 00               LD   hl,8   
06B8   19                     ADD   hl,de   
06B9   23                     INC   hl   
06BA   23                     INC   hl   
06BB   FD 75 02               LD   (iy+2),l   ; force first_arg* into this scope for clean up
06BE   FD 74 03               LD   (iy+3),h   ; first_arg* = address of block*
06C1   C3 8A 0C               JP   blockEnd   
06C4                             ; /byt
06C4                BYTEMODE:      
06C4   3E 01                  LD   a,1   
06C6                BYTEMODE1:      
06C6   32 EE 23               LD   (vDataWidth),a   
06C9   DD E9                  JP   (ix)   
06CB                             ; //
06CB                COMMENT:      
06CB   03                     INC   bc   ; point to next char
06CC   0A                     LD   a,(bc)   
06CD   FE 20                  CP   " "   ; terminate on any char less than SP
06CF   30 FA                  JR   nc,comment   
06D1   0B                     DEC   bc   
06D2   DD E9                  JP   (ix)   
06D4                DECBASE:      
06D4   3E 0A                  LD   a,10   
06D6                DECBASE1:      
06D6   32 EF 23               LD   (vNumBase),a   
06D9   DD E9                  JP   (ix)   
06DB                             ; /ech
06DB                             ; bool --
06DB                ECHO:        
06DB   E1                     POP   hl   
06DC   22 F1 23               LD   (vEcho),hl   
06DF   DD E9                  JP   (ix)   
06E1                HEXBASE:      
06E1   3E 10                  LD   a,16   
06E3   C3 D6 06               JP   decBase1   
06E6                ERROR1:      
06E6   21 01 00               LD   hl,1   ; error 1: unknown command
06E9   C3 4B 11               JP   error   
06EC                             ; Z80 port input
06EC                             ; port -- value
06EC                INPUT:       
06EC   E1                     POP   hl   
06ED   59                     LD   e,c   ; save IP
06EE   4D                     LD   c,l   
06EF   ED 68                  IN   l,(c)   
06F1   26 00                  LD   h,0   
06F3   4B                     LD   c,e   ; restore IP
06F4   E5                     PUSH   hl   
06F5   DD E9                  JP   (ix)   
06F7                             ; /alc
06F7                             ; size -- adr
06F7                MEMALLOCATE:      
06F7   DD E9                  JP   (ix)   
06F9                             ; /fre
06F9                             ; adr --
06F9                MEMFREE:      
06F9   E1                     POP   hl   
06FA                MEMFREE1:      
06FA   22 EA 23               LD   (vHeapPtr),hl   
06FD   DD E9                  JP   (ix)   
06FF                             ; /fra
06FF                             ; adr --
06FF                MEMFREEARRAY:      
06FF   E1                     POP   hl   
0700   2B                     DEC   hl   
0701   2B                     DEC   hl   
0702   18 F6                  JR   memFree1   
0704                             ; /max maximum
0704                             ; a b -- c
0704                MAXIMUM:      
0704   E1                     POP   hl   
0705   D1                     POP   de   
0706   E5                     PUSH   hl   
0707   B3                     OR   e   
0708   ED 52                  SBC   hl,de   
070A   30 02                  JR   nc,maximum1   
070C   E1                     POP   hl   
070D   D5                     PUSH   de   
070E                MAXIMUM1:      
070E   DD E9                  JP   (ix)   
0710                             ; /min minimum
0710                             ; a b -- c
0710                MINIMUM:      
0710   E1                     POP   hl   
0711   D1                     POP   de   
0712   E5                     PUSH   hl   
0713   B3                     OR   e   
0714   ED 52                  SBC   hl,de   
0716   38 02                  JR   c,minimum1   
0718   E1                     POP   hl   
0719   D5                     PUSH   de   
071A                MINIMUM1:      
071A   DD E9                  JP   (ix)   
071C                             ; /o Z80 port output
071C                             ; value port --
071C                OUTPUT:      
071C   E1                     POP   hl   
071D   59                     LD   e,c   ; save IP
071E   4D                     LD   c,l   
071F   E1                     POP   hl   
0720   ED 69                  OUT   (c),l   
0722   4B                     LD   c,e   ; restore IP
0723   DD E9                  JP   (ix)   
0725                             ; /ret
0725                             ; --
0725                RETURN:      
0725   E1                     POP   hl   ; hl = condition, exit if true
0726   7D                     LD   a,l   
0727   B4                     OR   h   
0728   20 02                  JR   nz,return1   
072A   DD E9                  JP   (ix)   
072C                RETURN1:      
072C   C3 8A 0C               JP   blockEnd   
072F                RECUR:       
072F   E1                     POP   hl   
0730   22 EC 23               LD   (vRecurPtr),hl   
0733   DD E9                  JP   (ix)   
0735                REMAIN:      
0735   2A FA 23               LD   hl,(vRemain)   
0738   E5                     PUSH   hl   
0739   DD E9                  JP   (ix)   
073B                             ; select case from an associative array of cases
073B                             ; bool cases* --
073B                SELECT:      
073B   E1                     POP   hl   ; hl = case associative array [ key1 value1 ... ]
073C   D1                     POP   de   ; de = select key
073D   C5                     PUSH   bc   ; save IP
073E   2B                     DEC   hl   ; bc = array length
073F   46                     LD   b,(hl)   
0740   2B                     DEC   hl   
0741   4E                     LD   c,(hl)   
0742   23                     INC   hl   
0743   23                     INC   hl   
0744   18 15                  JR   select2   
0746                SELECT1:      
0746   7E                     LD   a,(hl)   ; compare lsb case key with lsb select key, hl++
0747   BB                     CP   e   
0748   23                     INC   hl   ; hl++, flags are unaltered
0749   20 0C                  JR   nz,select1a   
074B   7E                     LD   a,(hl)   ; compare msb case key with msb select key, hl++
074C   BA                     CP   d   
074D   23                     INC   hl   ; hl++, flags are unaltered
074E   20 08                  JR   nz,select1b   
0750   5E                     LD   e,(hl)   
0751   23                     INC   hl   
0752   56                     LD   d,(hl)   
0753   C1                     POP   bc   
0754   C3 A0 03               JP   go1   
0757                SELECT1A:      
0757   23                     INC   hl   
0758                SELECT1B:      
0758   23                     INC   hl   
0759   23                     INC   hl   
075A   0B                     DEC   bc   
075B                SELECT2:      
075B   79                     LD   a,c   
075C   B0                     OR   b   
075D   20 E7                  JR   nz,select1   
075F   C1                     POP   bc   
0760   DD E9                  JP   (ix)   
0762                             ; /str
0762                STRINGBEGIN:      
0762   21 FF FF               LD   hl,TRUE   ; string mode = true
0765   22 F2 23               LD   (vStrMode),hl   
0768   18 27                  JR   stringEnd1   ; save hl in vBufPtr
076A                             ; /end
076A                STRINGEND:      
076A   21 00 00               LD   hl,FALSE   ; string mode = false
076D   22 F2 23               LD   (vStrMode),hl   
0770   2A E8 23               LD   hl,(vBufPtr)   ; append NUL to string
0773   AF                     XOR   a   
0774   77                     LD   (hl),a   
0775   23                     INC   hl   ; hl = string_end*
0776   ED 43 04 24            LD   (vTemp1),bc   ; save IP
077A   11 00 22               LD   de,BUFFER   ; de = string*
077D   B7                     OR   a   ; bc = size
077E   ED 52                  SBC   hl,de   
0780   44 4D                  LD   bc,hl   
0782   2A EA 23               LD   hl,(vHeapPtr)   ; hl = hstring*
0785   EB                     EX   de,hl   ; hl = string*, de = hstring*, bc = size
0786   D5                     PUSH   de   ; return hstring*
0787   ED B0                  LDIR      ; copy size bytes from string* to hstring*
0789   ED 53 EA 23            LD   (vHeapPtr),de   ; bump heap to hstring* += size
078D   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
0791                STRINGEND1:      
0791   21 00 22               LD   hl,BUFFER   ; reset vBufPtr
0794   22 E8 23               LD   (vBufPtr),hl   
0797   DD E9                  JP   (ix)   
0799                STRINGLENGTH:      
0799   D1                     POP   de   
079A   21 00 00               LD   hl,0   
079D   18 02                  JR   stringLength2   
079F                STRINGLENGTH1:      
079F   13                     INC   de   
07A0   23                     INC   hl   
07A1                STRINGLENGTH2:      
07A1   1A                     LD   a,(de)   
07A2   B7                     OR   a   
07A3   20 FA                  JR   nz,stringLength1   
07A5                STRINGLENGTH3:      
07A5   E5                     PUSH   hl   
07A6   DD E9                  JP   (ix)   
07A8                STRINGSIZE:      
07A8                          ;*Macro unroll:  PERFORM stringLength
07A8   DD 21 AF 07            LD   ix,performM_1736S1317   
07AC   C3 99 07               JP   stringLength   
07AF                PERFORMM_1736S1317:      
07AF   E1                     POP   hl   
07B0   23                     INC   hl   
07B1   C3 A5 07               JP   stringLength3   
07B4                             ; /sc string compare
07B4                             ; string1* string2* -- bool
07B4                             ; Compares two null terminated strings.
07B4                STRINGCOMPARE:      
07B4   D1                     POP   de   
07B5   E1                     POP   hl   
07B6                STRINGCOMPARE1:      
07B6   1A                     LD   a,(de)   
07B7   BE                     CP   (hl)   
07B8   20 07                  JR   nz,stringCompare2   
07BA   B7                     OR   a   
07BB   28 09                  JR   z,stringCompare3   
07BD   13                     INC   de   
07BE   23                     INC   hl   
07BF   18 F5                  JR   stringCompare1   
07C1                STRINGCOMPARE2:      
07C1   21 00 00               LD   hl,FALSE   
07C4   18 03                  JR   stringCompare4   
07C6                STRINGCOMPARE3:      
07C6   21 FF FF               LD   hl,TRUE   
07C9                STRINGCOMPARE4:      
07C9   E5                     PUSH   hl   
07CA   DD E9                  JP   (ix)   
07CC                             ; /var
07CC                             ; --
07CC                VARIABLES:      
07CC   21 00 23               LD   hl,VARS   
07CF   C3 A4 0F               JP   constant   
07D2                             ; /voi clear out returned values
07D2                             ; ?? --
07D2                VOID:        
07D2   FD 5D                  LD   e,iyl   
07D4   FD 54                  LD   d,iyh   
07D6   EB                     EX   de,hl   
07D7   F9                     LD   sp,hl   
07D8   DD E9                  JP   (ix)   
07DA                             ; /wrd
07DA                WORDMODE:      
07DA   3E 02                  LD   a,2   
07DC   C3 C6 06               JP   byteMode1   
07DF                             ; /xor
07DF                XOR:         
07DF   D1                     POP   de   ; Bitwise xor the top 2 elements of the stack
07E0                XOR1:        
07E0   E1                     POP   hl   
07E1   7B                     LD   a,e   
07E2   AD                     XOR   l   
07E3   6F                     LD   l,a   
07E4   7A                     LD   a,d   
07E5   AC                     XOR   h   
07E6   67                     LD   h,a   
07E7   C3 D8 02               JP   add3   
07EA                             ;*******************************************************************
07EA                             ; Monty implementations
07EA                             ;*******************************************************************
07EA                             ; /rng rangeSrc
07EA                             ; begin end step -- src
07EA                          ;*Macro unroll: FUNC rangeSrc, 1, "besL"            ; range source: begin, end, step, local: L
07EA                RANGESRC:      ; range source: begin, end, step, local: L
07EA   CD 9F 03               CALL   go   
07ED   00 00                  DW   NUL   
07EF   F9 07                  DW   rangeSrcM_1797S1385   
07F1   F3 07                  DW   $+2   
07F3   01                     DB   1   
07F4   04 62 65 73 4C         .PSTR   "besL"   
07F9                RANGESRCM_1797S1385:      
07F9   7B                     DB   "{"   ; init mutable L [index active inrange_test]
07FA   5B 25 62 20 2F 74 72 75 20 25 73 30 3E 7B 7B 25 61 25 65 3C 7D 7D 7B 7B 25 61 25 65 3E 7D 7D 3F 5D 20 25 4C 3D 20 DB   "[%b /tru %s0>{{%a%e<}}{{%a%e>}}?] %L= "   
0820   5C 6B 74 7B            DB   "\\kt{"   
0824   30 25 74 21 3D 2F 72 65 74 DB   "0%t!=/ret"   ; break if type != 0
082D   5C 64 74 3A 61 7B      DB   "\\dt:a{"   ; return talkback to receive data
0833   25 4C 31 3B 21 2F 72 65 74 DB   "%L1;!/ret"   ; if not active don't send
083C   25 4C 30 3B 20 25 61 3D DB   "%L0; %a="   ; store current index in A
0844   25 73 20 25 4C 30 3B 20 2B 3D DB   "%s %L0; +="   ; inc value of index by step
084E   31 25 74 21 3D 2F 72 65 74 DB   "1%t!=/ret"   ; break if type != 0
0857   25 4C 32 3B 5E         DB   "%L2;^"   ; ifte: inrange_test?
085C   7B 25 61 20 31 7D 7B 2F 66 61 6C 20 25 4C 31 3B 3D 20 30 20 32 7D DB   "{%a 1}{/fal %L1;= 0 2}"   ; ifte: /tru index, /fal active = false, quit
0872   3F 20 25 6B 2F 72 63   DB   "? %k/rc"   ; ifte: send to sink note: /rc recur
0879   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0880   7D                     DB   "}"   
0881   7D                     DB   "}"   
0882   00                     DB   0   
0883                             ; /ai arrayIter
0883                             ; array* -- src
0883                          ;*Macro unroll: FUNC arrayIter, 1, "aL"
0883                ARRAYITER:      
0883   CD 9F 03               CALL   go   
0886   00 00                  DW   NUL   
0888   90 08                  DW   arrayIterM_1816S1405   
088A   8C 08                  DW   $+2   
088C   01                     DB   1   
088D   02 61 4C               .PSTR   "aL"   
0890                ARRAYITERM_1816S1405:      
0890   7B                     DB   "{"   
0891   5B 30 20 2F 74 72 75 20 25 61 2F 61 6C 5D 20 25 4C 3D DB   "[0 /tru %a/al] %L="   ; init mutable L [index active size]
08A3   5C 6B 74 7B            DB   "\\kt{"   
08A7   30 25 74 21 3D 2F 72 65 74 DB   "0%t!=/ret"   ; break if type != 0
08B0   5C 64 74 3A 69 7B      DB   "\\dt:i{"   ; return talkback to receive data
08B6   25 4C 31 3B 21 2F 72 65 74 DB   "%L1;!/ret"   ; if not active don't send
08BF   25 4C 30 3B 20 25 69 3D DB   "%L0; %i="   ; store current index in i
08C7   25 4C 30 3B 20 2B 2B   DB   "%L0; ++"   ; inc value of index
08CE   31 25 74 21 3D 2F 72 65 74 DB   "1%t!=/ret"   ; break if type != 0
08D7   25 69 20 25 4C 32 3B 20 3C DB   "%i %L2; <"   ; ifte: index < size
08E0   7B 25 61 25 69 3B 20 31 7D 7B 2F 66 61 6C 20 25 4C 31 3B 3D 20 30 20 32 7D DB   "{%a%i; 1}{/fal %L1;= 0 2}"   ; ifte: /tru value, /fal active = false, quit
08F9   3F 20 25 6B 2F 72 63   DB   "? %k/rc"   ; ifte: send to sink note: /rc recur
0900   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0907   7D                     DB   "}"   
0908   7D                     DB   "}"   
0909   00                     DB   0   
090A                             ; /si stringIter
090A                             ; string* -- src
090A                          ;*Macro unroll: FUNC stringIter, 1, "sL"
090A                STRINGITER:      
090A   CD 9F 03               CALL   go   
090D   00 00                  DW   NUL   
090F   17 09                  DW   stringIterM_1835S1425   
0911   13 09                  DW   $+2   
0913   01                     DB   1   
0914   02 73 4C               .PSTR   "sL"   
0917                STRINGITERM_1835S1425:      
0917   7B                     DB   "{"   
0918   5B 30 20 2F 74 72 75 5D 20 25 4C 3D DB   "[0 /tru] %L="   ; init mutable L [index active]
0924   5C 6B 74 7B            DB   "\\kt{"   
0928   30 25 74 21 3D 2F 72 65 74 DB   "0%t!=/ret"   ; break if type != 0
0931   5C 64 74 3A 69 63 7B   DB   "\\dt:ic{"   ; return talkback to receive data
0938   25 4C 31 3B 21 2F 72 65 74 DB   "%L1;!/ret"   ; if not active don't send
0941   25 4C 30 3B 20 25 69 3D DB   "%L0; %i="   ; store current index in A
0949   25 4C 30 3B 20 2B 2B   DB   "%L0; ++"   ; inc value of index by step
0950   2F 62 79 74 20 25 73 25 69 3B 20 2F 77 72 64 20 25 63 3D DB   "/byt %s%i; /wrd %c="   ; read byte at i, store in c as word
0963   31 25 74 21 3D 2F 72 65 74 DB   "1%t!=/ret"   ; break if type != 0
096C   25 63 20 30 20 21 3D   DB   "%c 0 !="   ; ifte: c != NUL ?
0973   7B 25 63 20 31 7D 7B 2F 66 61 6C 20 25 4C 31 3B 3D 20 30 20 32 7D DB   "{%c 1}{/fal %L1;= 0 2}"   ; ifte: 1: send c, 2: active = false, send quit
0989   3F 20 25 6B 2F 72 63   DB   "? %k/rc"   ; ifte: call sink note: /rc recur
0990   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0997   7D                     DB   "}"   
0998   7D                     DB   "}"   
0999   00                     DB   0   
099A                             ; /map map
099A                             ; src func -- src1
099A                          ;*Macro unroll: FUNC map, 0, "sf"                   ; map: source, function
099A                MAP:         ; map: source, function
099A   CD 9F 03               CALL   go   
099D   00 00                  DW   NUL   
099F   A7 09                  DW   mapM_1855S1447   
09A1   A3 09                  DW   $+2   
09A3   00                     DB   0   
09A4   02 73 66               .PSTR   "sf"   
09A7                MAPM_1855S1447:      
09A7   7B                     DB   "{"   
09A8   5C 6B 74 7B            DB   "\\kt{"   
09AC   30 25 74 21 3D 2F 72 65 74 DB   "0%t!=/ret"   ; break if type != 0
09B5   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
09B9   31 25 74 3D 3D         DB   "1%t=="   ; ifte: type == 1 ?
09BE   7B 25 64 20 25 66 5E 7D 7B 25 64 7D DB   "{%d %f^}{%d}"   ; ifte: func(data) or data
09CA   3F 20 25 74 20 25 6B 5E DB   "? %t %k^"   ; ifte: send to sink
09D2   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
09D9   7D                     DB   "}"   
09DA   7D                     DB   "}"   
09DB   00                     DB   0   
09DC                             ; /ft filter
09DC                             ; src pred -- src1
09DC                          ;*Macro unroll: FUNC filter, 1, "spT"               ; filter: source, predicate, local: T
09DC                FILTER:      ; filter: source, predicate, local: T
09DC   CD 9F 03               CALL   go   
09DF   00 00                  DW   NUL   
09E1   EA 09                  DW   filterM_1869S1462   
09E3   E5 09                  DW   $+2   
09E5   01                     DB   1   
09E6   03 73 70 54            .PSTR   "spT"   
09EA                FILTERM_1869S1462:      
09EA   7B                     DB   "{"   
09EB   5B 30 5D 25 54 3D      DB   "[0]%T="   
09F1   5C 6B 74 7B            DB   "\\kt{"   ; return talkback to receive data
09F5   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
09F9   5B                     DB   "["   
09FA   7B 25 64 20 25 54 30 3B 3D 20 2F 74 72 75 7D DB   "{%d %T0;= /tru}"   ; case 0: store talkback in T[0], return true
0A09   7B 25 64 20 25 70 5E 7D DB   "{%d %p^}"   ; case 1: return boolean based on predicate
0A11   7B 2F 74 72 75 7D      DB   "{/tru}"   ; case 2: return true
0A17   5D 25 74 3B 5E         DB   "]%t;^"   ; select on %t
0A1C   7B 25 64 20 25 74 20 25 6B 5E 7D 7B 30 20 31 20 25 54 30 3B 5E 7D DB   "{%d %t %k^}{0 1 %T0;^}"   ; ifte: true send d to sink, false send 1 to talkback
0A32   3F                     DB   "?"   
0A33   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
0A3A   7D                     DB   "}"   
0A3B   7D                     DB   "}"   
0A3C   00                     DB   0   
0A3D                             ; /fd fold
0A3D                             ; reducer is a function like: \\da00bbLi4u
0A3D                             ; src init reducer -- src1
0A3D                          ;*Macro unroll: FUNC fold, 1, "sirA"                    ; src, init, reducer
0A3D                FOLD:        ; src, init, reducer
0A3D   CD 9F 03               CALL   go   
0A40   00 00                  DW   NUL   
0A42   4C 0A                  DW   foldM_1888S1482   
0A44   46 0A                  DW   $+2   
0A46   01                     DB   1   
0A47   04 73 69 72 41         .PSTR   "sirA"   
0A4C                FOLDM_1888S1482:      
0A4C   7B                     DB   "{"   ; reducer: \\da00bbLi4u
0A4D   5B 25 69 5D 25 41 3D   DB   "[%i]%A="   
0A54   5C 6B 74 7B            DB   "\\kt{"   ; return talkback to receive data
0A58   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
0A5C   31 25 74 3D 3D         DB   "1%t=="   ; ifte: type == 1 ?
0A61   7B 25 64 20 25 41 30 3B 20 25 72 5E 25 41 30 3B 3D 20 25 41 30 3B 7D 7B 25 64 7D DB   "{%d %A0; %r^%A0;= %A0;}{%d}"   ; ifte: reduce -> acc, acc or data
0A7C   3F 20 25 74 20 25 6B 5E DB   "? %t %k^"   ; ifte: send to sink
0A84   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
0A8B   7D                     DB   "}"   
0A8C   7D                     DB   "}"   
0A8D   00                     DB   0   
0A8E                             ; /for forEach
0A8E                             ; src proc --
0A8E                          ;*Macro unroll: FUNC forEach, 1, "spT"              ; forEach: source, procedure, local: T
0A8E                FOREACH:      ; forEach: source, procedure, local: T
0A8E   CD 9F 03               CALL   go   
0A91   00 00                  DW   NUL   
0A93   9C 0A                  DW   forEachM_1902S1497   
0A95   97 0A                  DW   $+2   
0A97   01                     DB   1   
0A98   03 73 70 54            .PSTR   "spT"   
0A9C                FOREACHM_1902S1497:      
0A9C   7B                     DB   "{"   
0A9D   5B 30 5D 25 54 3D      DB   "[0]%T="   
0AA3   5C 64 74 7B            DB   "\\dt{"   ; return talkback to receive data ; $56AA
0AA7   32 25 74 3D 3D 2F 72 65 74 DB   "2%t==/ret"   ; if type == 2 skip
0AB0   30 25 74 3D 3D         DB   "0%t=="   ; ifte: type = 0 ?
0AB5   7B 25 64 20 25 54 30 3B 3D 7D 7B 25 64 20 25 70 5E 7D DB   "{%d %T0;=}{%d %p^}"   ; ifte: 0: store talkback, 1: send data
0AC7   3F                     DB   "?"   ; ifte:
0AC8   30 20 31 20 25 54 30 3B 5E DB   "0 1 %T0;^"   ; 0 or 1: get next src data item
0AD1   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
0AD8   7D                     DB   "}"   
0AD9   00                     DB   0   
0ADA                             ; ; /fs funcSrc
0ADA                             ; ; func -- src
0ADA                          ;*Macro unroll: FUNC funcSrc, 0, "f"                      ; :f func or block
0ADA                FUNCSRC:      ; :f func or block
0ADA   CD 9F 03               CALL   go   
0ADD   00 00                  DW   NUL   
0ADF   E6 0A                  DW   funcSrcM_1916S1512   
0AE1   E3 0A                  DW   $+2   
0AE3   00                     DB   0   
0AE4   01 66                  .PSTR   "f"   
0AE6                FUNCSRCM_1916S1512:      
0AE6   7B                     DB   "{"   
0AE7   5C 6B 74 7B            DB   "\\kt{"   ; :kt sink, type
0AEB   30 25 74 3D 3D 2F 77 68 69 DB   "0%t==/whi"   ; break if t != 0 ; TODO replace with /ret
0AF4   5C 64 74 7B            DB   "\\dt{"   
0AF8   31 25 74 3D 3D 2F 77 68 69 20 25 66 5E 20 31 20 25 6B 5E DB   "1%t==/whi %f^ 1 %k^"   ; if t == 1 send data to sink TODO: replace with /ret
0B0B   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0B12   7D                     DB   "}"   
0B13   7D                     DB   "}"   
0B14   00                     DB   0   
0B15                          ;*Macro unroll: FUNC printArray, 2, "abc"
0B15                PRINTARRAY:      
0B15   CD 9F 03               CALL   go   
0B18   00 00                  DW   NUL   
0B1A   23 0B                  DW   printArrayM_1926S1523   
0B1C   1E 0B                  DW   $+2   
0B1E   02                     DB   2   
0B1F   03 61 62 63            .PSTR   "abc"   
0B23                PRINTARRAYM_1926S1523:      
0B23   7B                     DB   "{"   
0B24   27 5B 20 27 2E 73 20 25 61 2F 61 6C 25 63 3D 20 30 25 62 3D 20 28 25 61 20 25 62 20 3B 2E 20 25 62 20 2B 2B 20 25 62 20 25 63 20 3C 2F 77 68 69 29 5E 20 27 5D 27 2E 73 DB   "'[ '.s %a/al%c= 0%b= (%a %b ;. %b ++ %b %c </whi)^ ']'.s"   
0B5C   7D                     DB   "}"   
0B5D   00                     DB   0   
0B5E                             ;*******************************************************************
0B5E                             ; implementations continued
0B5E                             ;*******************************************************************
0B5E                COMMA:       
0B5E   CD C2 0F               CALL   cmdTable   
0B61   63 00                  DB   "c",NUL   ; .c print char
0B63   6D 0B                  DW   readChar   
0B65   73 00                  DB   "s",NUL   ; .s print string
0B67   76 0B                  DW   readString   
0B69   00 00                  DW   NUL   ; .  print number, fall through
0B6B   98 0B                  DW   readNumber   
0B6D                READCHAR:      
0B6D   CD 81 00               CALL   getchar   
0B70   26 00                  LD   h,0   
0B72   6F                     LD   l,a   
0B73   E5                     PUSH   hl   
0B74   DD E9                  JP   (ix)   
0B76                READSTRING:      
0B76   ED 5B EA 23            LD   de,(vHeapPtr)   
0B7A   D5                     PUSH   de   ; return start of string
0B7B                READSTRING1:      
0B7B   CD 81 00               CALL   getchar   
0B7E   FE 0D                  CP   "\r"   
0B80   28 0D                  JR   z,readString2   
0B82   12                     LD   (de),a   
0B83   13                     INC   de   
0B84   3A F1 23               LD   a,(vEcho)   
0B87   3C                     INC   a   
0B88   20 F1                  JR   nz,readString1   
0B8A   CD 85 00               CALL   putchar   
0B8D   18 EC                  JR   readString1   
0B8F                READSTRING2:      
0B8F   AF                     XOR   a   
0B90   12                     LD   (de),a   
0B91   13                     INC   de   
0B92   ED 53 EA 23            LD   (vHeapPtr),de   
0B96   DD E9                  JP   (ix)   
0B98                READNUMBER:      
0B98   DD E5                  PUSH   ix   
0B9A                          ;*Macro unroll:  PERFORM readString
0B9A   DD 21 A1 0B            LD   ix,performM_1970S1572   
0B9E   C3 76 0B               JP   readString   
0BA1                PERFORMM_1970S1572:      
0BA1   60 69                  LD   hl,bc   ; save bc, hl = string*
0BA3   E3                     EX   (sp),hl   
0BA4   22 EA 23               LD   (vHeapPtr),hl   ; restore heap* to before string
0BA7   44 4D                  LD   bc,hl   
0BA9   0A                     LD   a,(bc)   
0BAA   FE 2D                  CP   "-"   
0BAC   28 11                  JR   z,readNumber1   
0BAE   FE 24                  CP   "$"   
0BB0   28 17                  JR   z,readNumber2   
0BB2   FE 30                  CP   "0"   
0BB4   30 09                  JR   nc,readNumber1   
0BB6   FE 3A                  CP   "9"+1   
0BB8   38 05                  JR   c,readNumber1   
0BBA   21 00 00               LD   hl,0   
0BBD   18 12                  JR   readNumber3   
0BBF                READNUMBER1:      
0BBF                          ;*Macro unroll:  PERFORM num
0BBF   DD 21 C6 0B            LD   ix,performM_1987S1589   
0BC3   C3 5A 0C               JP   num   
0BC6                PERFORMM_1987S1589:      
0BC6   E1                     POP   hl   
0BC7   18 08                  JR   readNumber3   
0BC9                READNUMBER2:      
0BC9                          ;*Macro unroll:  PERFORM hexNum
0BC9   DD 21 D0 0B            LD   ix,performM_1991S1593   
0BCD   C3 E1 0B               JP   hexNum   
0BD0                PERFORMM_1991S1593:      
0BD0   E1                     POP   hl   
0BD1                READNUMBER3:      
0BD1   C1                     POP   bc   
0BD2   DD E1                  POP   ix   
0BD4   E5                     PUSH   hl   
0BD5   DD E9                  JP   (ix)   
0BD7                             ; ~ bitwise invert
0BD7                TILDE:       
0BD7                INVERT:      
0BD7   E1                     POP   hl   ; Bitwise xor the top 2 elements of the stack
0BD8   7D                     LD   a,l   
0BD9   2F                     CPL      
0BDA   6F                     LD   l,a   
0BDB   7C                     LD   a,h   
0BDC   2F                     CPL      
0BDD   67                     LD   h,a   
0BDE   C3 D8 02               JP   add3   
0BE1                             ; $ hex                         ; 22
0BE1                DOLLAR:      
0BE1                HEXNUM:      
0BE1   21 00 00               LD   hl,0   ; Clear hl to accept the number
0BE4                HEXNUM1:      
0BE4   03                     INC   bc   
0BE5   0A                     LD   a,(bc)   ; Get the character which is a numeral
0BE6   CB 77                  BIT   6,a   ; is it uppercase alpha?
0BE8   28 02                  JR   z,hexnum2   ; no a decimal
0BEA   D6 07                  SUB   7   ; sub 7  to make $a - $F
0BEC                HEXNUM2:      
0BEC   D6 30                  SUB   $30   ; form decimal digit
0BEE   DA 7C 0C               JP   c,num2   
0BF1   FE 10                  CP   $0F+1   
0BF3   D2 7C 0C               JP   nc,num2   
0BF6   29                     ADD   hl,hl   ; 2X ; Multiply digit(s) in hl by 16
0BF7   29                     ADD   hl,hl   ; 4X
0BF8   29                     ADD   hl,hl   ; 8X
0BF9   29                     ADD   hl,hl   ; 16X
0BFA   85                     ADD   a,l   ; add into bottom of hl
0BFB   6F                     LD   l,a   
0BFC   18 E6                  JR   hexnum1   
0BFE                             ; ? if                            23
0BFE                             ; condition then else -- value
0BFE                QUESTION:      
0BFE                IF:          
0BFE   D1                     POP   de   ; de = else
0BFF   E1                     POP   hl   ; hl = then
0C00   E3                     EX   (sp),hl   ; hl = condition, (sp) = then
0C01   7C                     LD   a,h   
0C02   B5                     OR   l   
0C03   E1                     POP   hl   ; hl = then
0C04   CA A0 03               JP   z,go1   ; if z de = else
0C07   EB                     EX   de,hl   ; condition = false, de = then
0C08   C3 A0 03               JP   go1   
0C0B                             ; string                        ;38
0C0B                             ; -- ptr                        ; points to start of string chars,                                 ; length is stored at start - 2 bytes
0C0B                QUOTE:       
0C0B                STRING:      
0C0B   2A EA 23               LD   hl,(vHeapPtr)   ; hl = heap*
0C0E   E5                     PUSH   hl   ; save start of string
0C0F   0A                     LD   a,(bc)   
0C10   5F                     LD   e,a   ; e = matching terminator
0C11   03                     INC   bc   ; point to next char
0C12   18 03                  JR   string2   
0C14                STRING1:      
0C14   77                     LD   (hl),a   
0C15   23                     INC   hl   ; increase count
0C16   03                     INC   bc   ; point to next char
0C17                STRING2:      
0C17   0A                     LD   a,(bc)   
0C18   BB                     CP   e   ; is it the string terminator
0C19   28 02                  JR   z,string3   
0C1B   18 F7                  JR   string1   
0C1D                STRING3:      
0C1D   AF                     XOR   a   ; write NUL to terminate string
0C1E   77                     LD   (hl),a   ; hl = end of string
0C1F   23                     INC   hl   
0C20   22 EA 23               LD   (vHeapPtr),hl   ; bump heap* to after end of string
0C23   DD E9                  JP   (ix)   
0C25                             ; %a .. %z                      43
0C25                             ; -- value
0C25                             ; returns value of arg
0C25                PERCENT:      
0C25                ARG:         
0C25   FD 5E 04               LD   e,(iy+4)   ; hl = arg_list*
0C28   FD 56 05               LD   d,(iy+5)   
0C2B   EB                     EX   de,hl   
0C2C   7D                     LD   a,l   ; arg_list* == null, skip
0C2D   B4                     OR   h   
0C2E   28 1A                  JR   z,arg0a   
0C30   23                     INC   hl   ; a = num_args, hl = arg_list*
0C31   7E                     LD   a,(hl)   
0C32   23                     INC   hl   
0C33   B7                     OR   a   
0C34   28 14                  JR   z,arg0a   ; num_args == 0, skip
0C36   5F                     LD   e,a   ; e = a = num_args
0C37   03                     INC   bc   ; a = next char = dollar_name
0C38   0A                     LD   a,(bc)   
0C39   C5                     PUSH   bc   ; save IP
0C3A   43                     LD   b,e   ; b = e = num_args
0C3B   FD 5E 02               LD   e,(iy+2)   ; de = first_arg*, hl = argslist*
0C3E   FD 56 03               LD   d,(iy+3)   
0C41                ARG0:        
0C41   1B                     DEC   de   ; a = dollar_name, de = next arg*
0C42   1B                     DEC   de   
0C43   BE                     CP   (hl)   
0C44   28 09                  JR   z,arg1   
0C46   23                     INC   hl   ; hl = next arg_list*
0C47   10 F8                  DJNZ   arg0   
0C49   C1                     POP   bc   ; no match, restore IP
0C4A                ARG0A:       
0C4A   11 00 00               LD   de,0   ; return 0
0C4D   18 08                  JR   arg1a   
0C4F                ARG1:        
0C4F   C1                     POP   bc   ; restore IP
0C50   EB                     EX   de,hl   ; hl = arg*
0C51   22 F8 23               LD   (vPointer),hl   ; store arg* in setter
0C54   5E                     LD   e,(hl)   
0C55   23                     INC   hl   
0C56   56                     LD   d,(hl)   ; de = arg
0C57                ARG1A:       
0C57   D5                     PUSH   de   ; push arg
0C58   DD E9                  JP   (ix)   
0C5A                             ; 0..9 number                   37
0C5A                NUM:         
0C5A   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
0C5D   0A                     LD   a,(bc)   ; Get numeral or -
0C5E   FE 2D                  CP   "-"   
0C60   20 01                  JR   nz,num0   
0C62   03                     INC   bc   ; move to next char, no flags affected
0C63                NUM0:        
0C63   08                     EX   af,af'   ; save zero flag = 0 for later
0C64                NUM1:        
0C64   0A                     LD   a,(bc)   ; read digit
0C65   D6 30                  SUB   "0"   ; less than 0?
0C67   38 13                  JR   c,num2   ; not a digit, exit loop
0C69   FE 0A                  CP   10   ; greater that 9?
0C6B   30 0F                  JR   nc,num2   ; not a digit, exit loop
0C6D   03                     INC   bc   ; inc IP
0C6E   54 5D                  LD   de,hl   ; multiply hl * 10
0C70   29                     ADD   hl,hl   
0C71   29                     ADD   hl,hl   
0C72   19                     ADD   hl,de   
0C73   29                     ADD   hl,hl   
0C74   85                     ADD   a,l   ; add digit in a to hl
0C75   6F                     LD   l,a   
0C76   3E 00                  LD   a,0   
0C78   8C                     ADC   a,h   
0C79   67                     LD   h,a   
0C7A   18 E8                  JR   num1   
0C7C                NUM2:        
0C7C   0B                     DEC   bc   
0C7D   08                     EX   af,af'   ; restore zero flag
0C7E   20 07                  JR   nz,num3   
0C80   EB                     EX   de,hl   ; negate the value of hl
0C81   21 00 00               LD   hl,0   
0C84   B7                     OR   a   ; jump to sub2
0C85   ED 52                  SBC   hl,de   
0C87                NUM3:        
0C87   E5                     PUSH   hl   ; Put the number on the stack
0C88   DD E9                  JP   (ix)   ; and process the next character
0C8A                             ; }                               58
0C8A                RBRACE:      
0C8A                BLOCKEND:      
0C8A   FD 5E 00               LD   e,(iy+0)   ; vTemp1 = oldBP
0C8D   FD 56 01               LD   d,(iy+1)   
0C90   ED 53 04 24            LD   (vTemp1),de   
0C94   FD 5E 06               LD   e,(iy+6)   ; vTemp2 = oldIP
0C97   FD 56 07               LD   d,(iy+7)   
0C9A   ED 53 06 24            LD   (vTemp2),de   
0C9E   FD 5E 02               LD   e,(iy+2)   ; hl = first_arg*, is it in this scope?
0CA1   FD 56 03               LD   d,(iy+3)   
0CA4   EB                     EX   de,hl   
0CA5   FD 5E 00               LD   e,(iy+0)   ; de = oldBP
0CA8   FD 56 01               LD   d,(iy+1)   
0CAB   13                     INC   de   ; for carry flag <=
0CAC   B7                     OR   a   
0CAD   ED 52                  SBC   hl,de   
0CAF   38 0B                  JR   c,blockEnd1   ; oldBP >= first_arg, same scope skip
0CB1   FD 54                  LD   d,iyh   ; de = BP = first_result*, no args in this scope
0CB3   FD 5D                  LD   e,iyl   
0CB5   21 08 00               LD   hl,8   
0CB8   19                     ADD   hl,de   ; de = BP = first_result* (BP), hl = first_arg* (BP+8)
0CB9   EB                     EX   de,hl   ; de = first_arg*, hl = first_result*
0CBA   18 0C                  JR   blockEnd2   
0CBC                BLOCKEND1:      ; same scope
0CBC   FD 5E 02               LD   e,(iy+2)   ; hl = first_arg*, in scope
0CBF   FD 56 03               LD   d,(iy+3)   
0CC2   EB                     EX   de,hl   
0CC3   FD 54                  LD   d,iyh   ; de = first_arg*, hl = BP = first_result*
0CC5   FD 5D                  LD   e,iyl   
0CC7   EB                     EX   de,hl   
0CC8                BLOCKEND2:      
0CC8   44 4D                  LD   bc,hl   ; bc = hl = BP
0CCA   B7                     OR   a   ; hl = BP - SP = count
0CCB   ED 72                  SBC   hl,sp   
0CCD   7D                     LD   a,l   
0CCE   B4                     OR   h   
0CCF   28 09                  JR   z,blockEnd3   
0CD1   C5                     PUSH   bc   ; bc = count, hl = BP
0CD2   44 4D                  LD   bc,hl   
0CD4   E1                     POP   hl   
0CD5   2B                     DEC   hl   ; hl = BP-1
0CD6   1B                     DEC   de   ; de = args*-1
0CD7   ED B8                  LDDR      
0CD9   13                     INC   de   
0CDA                BLOCKEND3:      
0CDA   EB                     EX   de,hl   ; sp = de = new tos*
0CDB   F9                     LD   sp,hl   
0CDC   ED 4B 06 24            LD   bc,(vTemp2)   
0CE0   FD 2A 04 24            LD   iy,(vTemp1)   
0CE4   ED 5B EC 23            LD   de,(vRecurPtr)   ; de = recur vector
0CE8   7B                     LD   a,e   ; check for NUL
0CE9   B2                     OR   d   
0CEA   20 02                  JR   nz,blockEnd4   
0CEC   DD E9                  JP   (ix)   
0CEE                BLOCKEND4:      
0CEE   21 00 00               LD   hl,0   ; clear recur vector
0CF1   22 EC 23               LD   (vRecurPtr),hl   
0CF4   C3 A0 03               JP   go1   ; execute de
0CF7                GOBLOCK:      
0CF7   ED 53 04 24            LD   (vTemp1),de   ; save de
0CFB   21 00 21               LD   hl,stack   ; de = BP, hl = stack, (sp) = code*
0CFE   FD 54                  LD   d,iyh   
0D00   FD 5D                  LD   e,iyl   
0D02   B7                     OR   a   ; if stack* == BP then this is the root_scope
0D03   ED 52                  SBC   hl,de   
0D05   ED 5B 04 24            LD   de,(vTemp1)   ; restore de
0D09   7D                     LD   a,l   ; if (not root_scope) then inherit scope vars from parent
0D0A   B4                     OR   h   
0D0B   3E 00                  LD   a,0   
0D0D   28 6A                  JR   z,goFunc8   
0D0F   C5                     PUSH   bc   ; push IP
0D10   FD 4E 04               LD   c,(iy+4)   ; push arg_list* (parent)
0D13   FD 46 05               LD   b,(iy+5)   
0D16   FD 6E 02               LD   l,(iy+2)   ; push first_arg* (parent)
0D19   FD 66 03               LD   h,(iy+3)   
0D1C                GOBLOCK2:      
0D1C   C5                     PUSH   bc   ; arg_list*
0D1D   E5                     PUSH   hl   ; first_arg*
0D1E   FD E5                  PUSH   iy   ; push BP
0D20   FD 21 00 00            LD   iy,0   ; BP = SP
0D24   FD 39                  ADD   iy,sp   
0D26                GOBLOCK3:      
0D26   42 4B                  LD   bc,de   ; bc = de = block*-1
0D28   DD E9                  JP   (ix)   
0D2A                GOFUNC:      ; execute func
0D2A   EB                     EX   de,hl   ; hl = func*
0D2B   5E                     LD   e,(hl)   ; de = partial_array*
0D2C   23                     INC   hl   
0D2D   56                     LD   d,(hl)   
0D2E   23                     INC   hl   
0D2F   7B                     LD   a,e   ; if partial_array* == null skip
0D30   B2                     OR   d   
0D31   28 21                  JR   z,goFunc3   
0D33   ED 43 04 24            LD   (vTemp1),bc   
0D37   22 06 24               LD   (vTemp2),hl   ; save bc,hl
0D3A   EB                     EX   de,hl   ; hl = partial_array*
0D3B   2B                     DEC   hl   ; bc = count
0D3C   46                     LD   b,(hl)   
0D3D   2B                     DEC   hl   
0D3E   4E                     LD   c,(hl)   
0D3F   23                     INC   hl   ; hl = array data*
0D40   23                     INC   hl   
0D41   18 06                  JR   goFunc2   ; push each item on stack
0D43                GOFUNC1:      
0D43   5E                     LD   e,(hl)   ; de = partial item
0D44   23                     INC   hl   
0D45   56                     LD   d,(hl)   
0D46   23                     INC   hl   
0D47   D5                     PUSH   de   ; push on stack
0D48   0B                     DEC   bc   
0D49                GOFUNC2:      
0D49   79                     LD   a,c   ; if count != 0 then loop
0D4A   B0                     OR   b   
0D4B   20 F6                  JR   nz,goFunc1   
0D4D   ED 4B 04 24            LD   bc,(vTemp1)   ; restore bc
0D51   2A 06 24               LD   hl,(vTemp2)   ; restore hl
0D54                GOFUNC3:      
0D54   5E                     LD   e,(hl)   ; de = block*
0D55   23                     INC   hl   
0D56   56                     LD   d,(hl)   
0D57   23                     INC   hl   
0D58   ED 53 04 24            LD   (vTemp1),de   ; save block*
0D5C   5E                     LD   e,(hl)   ; de = arg_list*
0D5D   23                     INC   hl   
0D5E   56                     LD   d,(hl)   
0D5F   23                     INC   hl   
0D60   EB                     EX   de,hl   ; hl = arg_list*
0D61   ED 5B 04 24            LD   de,(vTemp1)   ; restore de = block*
0D65   7D                     LD   a,l   ; if arg_list* == null a = 0
0D66   B4                     OR   h   
0D67   20 03                  JR   nz,goFunc4   
0D69   AF                     XOR   a   ; a = num_args (zero), num_locals (zero)
0D6A   18 0D                  JR   goFunc8   
0D6C                GOFUNC4:      ; allocate locals
0D6C   7E                     LD   a,(hl)   ; a = num_locals*, de = block* hl = arg_list*
0D6D   18 03                  JR   goFunc6   
0D6F                GOFUNC5:      ; loop
0D6F   3B                     DEC   sp   
0D70   3B                     DEC   sp   
0D71   3D                     DEC   a   
0D72                GOFUNC6:      
0D72   B7                     OR   a   
0D73   20 FA                  JR   nz,goFunc5   ; end loop
0D75                GOFUNC7:      
0D75   23                     INC   hl   ; a = num_args* x 2
0D76   7E                     LD   a,(hl)   
0D77   2B                     DEC   hl   
0D78   87                     ADD   a,a   ; a *= 2
0D79                GOFUNC8:      
0D79   C5                     PUSH   bc   ; push IP, a = num_args* x 2, de = block*
0D7A   44 4D                  LD   bc,hl   
0D7C   21 02 00               LD   hl,2   ; hl = first_arg* (BP+8), a = num args offset
0D7F   85                     ADD   a,l   
0D80   6F                     LD   l,a   
0D81   39                     ADD   hl,sp   
0D82   18 98                  JR   goBlock2   
0D84                             ; =                              21
0D84                             ; value _oldValue --            ; uses address in vPointer 15
0D84                ASSIGN:      
0D84   E1                     POP   hl   ; discard last accessed value
0D85   E1                     POP   hl   ; hl = new value
0D86                ASSIGN0:      
0D86   EB                     EX   de,hl   ; de = new value
0D87   2A F8 23               LD   hl,(vPointer)   
0D8A                ASSIGN1:      ; entry point from defineEnd
0D8A   73                     LD   (hl),e   
0D8B   3A EE 23               LD   a,(vDataWidth)   
0D8E   3D                     DEC   a   ; is it byte?
0D8F   28 02                  JR   z,assign2   
0D91   23                     INC   hl   
0D92   72                     LD   (hl),d   
0D93                ASSIGN2:      
0D93   DD E9                  JP   (ix)   
0D95                             ; hl = value1, de = value2
0D95                             ; hl = result
0D95                EQUALS:      
0D95   B7                     OR   a   ; reset the carry flag
0D96   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
0D98   28 16                  JR   z,true1   
0D9A   18 1A                  JR   false1   
0D9C                NOTEQUALS:      
0D9C   B7                     OR   a   ; reset the carry flag
0D9D   ED 52                  SBC   hl,de   
0D9F   20 0F                  JR   nz,true1   
0DA1   18 13                  JR   false1   
0DA3                             ; hl = value1 de = value2
0DA3                             ; hl = result
0DA3                LESSTHANEQ:      
0DA3   B7                     OR   a   
0DA4   ED 52                  SBC   hl,de   
0DA6   18 05                  JR   lessthan1   
0DA8                             ; hl = value1 de = value2
0DA8                             ; hl = result
0DA8                LESSTHAN:      
0DA8   B7                     OR   a   
0DA9   ED 52                  SBC   hl,de   
0DAB   28 09                  JR   z,false1   
0DAD                LESSTHAN1:      
0DAD   FA B6 0D               JP   m,false1   
0DB0                TRUE1:       
0DB0   21 FF FF               LD   hl,TRUE   
0DB3   E5                     PUSH   hl   
0DB4   DD E9                  JP   (ix)   
0DB6                NULL1:       
0DB6                FALSE1:      
0DB6   21 00 00               LD   hl,FALSE   
0DB9   E5                     PUSH   hl   
0DBA   DD E9                  JP   (ix)   
0DBC                SPREAD:      
0DBC   E1                     POP   hl   ; hl = array*
0DBD   ED 43 04 24            LD   (vTemp1),bc   ; save bc
0DC1   2B                     DEC   hl   ; bc = length
0DC2   46                     LD   b,(hl)   
0DC3   2B                     DEC   hl   
0DC4   4E                     LD   c,(hl)   
0DC5   23                     INC   hl   ; move back to array 0
0DC6   23                     INC   hl   
0DC7   18 0D                  JR   spread3   
0DC9                SPREAD1:      
0DC9   5E                     LD   e,(hl)   ; e = lsb data at hl
0DCA   23                     INC   hl   
0DCB   3A EE 23               LD   a,(vDataWidth)   ; data width = 1, d = 0, skip
0DCE   57                     LD   d,a   
0DCF   15                     DEC   d   
0DD0   28 02                  JR   z,spread2   
0DD2   56                     LD   d,(hl)   ; d = msb data at hl
0DD3   23                     INC   hl   
0DD4                SPREAD2:      
0DD4   D5                     PUSH   de   ; return de
0DD5   0B                     DEC   bc   ; count--
0DD6                SPREAD3:      
0DD6   79                     LD   a,c   ; exit loop if bc == 0
0DD7   B0                     OR   b   
0DD8   20 EF                  JR   nz,spread1   
0DDA   ED 4B 04 24            LD   bc,(vTemp1)   ; restore bc
0DDE   DD E9                  JP   (ix)   
0DE0                             ; shiftLeft
0DE0                             ; value count <<
0DE0                             ; count variable <<=
0DE0                SHIFTLEFT:      
0DE0   E1                     POP   hl   ; de = arg_a, hl = arg_b
0DE1   D1                     POP   de   
0DE2   03                     INC   bc   
0DE3   0A                     LD   a,(bc)   
0DE4   FE 3D                  CP   "="   
0DE6   28 02                  JR   z,shiftLeft2   
0DE8   0B                     DEC   bc   
0DE9   EB                     EX   de,hl   ; de = arg_b, hl = arg_a
0DEA                SHIFTLEFT2:      
0DEA   ED 43 04 24            LD   (vTemp1),bc   ; save IP
0DEE   43                     LD   b,e   ; b = loop counter
0DEF   04                     INC   b   ; test for counter=0 case
0DF0   18 01                  JR   shiftLeft4   
0DF2                SHIFTLEFT3:      
0DF2   29                     ADD   hl,hl   ; left shift hl
0DF3                SHIFTLEFT4:      
0DF3   10 FD                  DJNZ   shiftLeft3   
0DF5   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
0DF9   C3 9D 02               JP   sub3   
0DFC                             ; shiftRight
0DFC                             ; value count >>
0DFC                             ; count variable >>=
0DFC                SHIFTRIGHT:      
0DFC   E1                     POP   hl   ; de = arg_a, hl = arg_b
0DFD   D1                     POP   de   
0DFE   03                     INC   bc   
0DFF   0A                     LD   a,(bc)   
0E00   FE 3D                  CP   "="   
0E02   28 02                  JR   z,shiftRight2   
0E04   0B                     DEC   bc   
0E05   EB                     EX   de,hl   ; de = arg_a, hl = arg_b
0E06                SHIFTRIGHT2:      
0E06   ED 43 04 24            LD   (vTemp1),bc   ; save IP
0E0A   43                     LD   b,e   ; b = loop counter
0E0B   04                     INC   b   ; test for counter=0 case
0E0C   18 04                  JR   shiftRight4   
0E0E                SHIFTRIGHT3:      
0E0E   CB 3C                  SRL   h   ; right shift hl
0E10   CB 1D                  RR   l   
0E12                SHIFTRIGHT4:      
0E12   10 FA                  DJNZ   shiftRight3   
0E14   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
0E18   C3 9D 02               JP   sub3   
0E1B                             ; division subroutine.
0E1B                             ; bc: divisor, de: dividend, hl: remainder
0E1B                DIVIDE:      
0E1B   21 00 00               LD   hl,0   ; zero the remainder
0E1E   3E 10                  LD   a,16   ; loop counter
0E20                DIVIDE1:      ; shift the bits from bc (numerator) into hl (accumulator)
0E20   CB 21                  SLA   c   
0E22   CB 10                  RL   b   
0E24   ED 6A                  ADC   hl,hl   
0E26   ED 52                  SBC   hl,de   ; check if remainder >= denominator (hl>=de)
0E28   38 03                  JR   c,divide2   
0E2A   0C                     INC   c   
0E2B   18 01                  JR   divide3   
0E2D                DIVIDE2:      ; remainder is not >= denominator, so we have to add de back to hl
0E2D   19                     ADD   hl,de   
0E2E                DIVIDE3:      
0E2E   3D                     DEC   a   
0E2F   20 EF                  JR   nz,divide1   
0E31   50 59                  LD   de,bc   ; result from bc to de
0E33   C9                     RET      
0E34                DOTNEXT:      
0E34   3A F2 23               LD   a,(vStrMode)   ; if string mode then exit
0E37   3C                     INC   a   
0E38   20 02                  JR   nz,dotNext1   
0E3A   DD E9                  JP   (ix)   
0E3C                DOTNEXT1:      
0E3C   11 00 22               LD   de,BUFFER   
0E3F   2A E8 23               LD   hl,(vBufPtr)   
0E42   36 00                  LD   (hl),0   ; store NUL at end of string
0E44   ED 53 E8 23            LD   (vBufPtr),de   ; reset vBufPtr to vHeapPtr
0E48   EB                     EX   de,hl   ; hl = BUFFER
0E49   CD FF 0F               CALL   putstr   
0E4C   DD E9                  JP   (ix)   
0E4E                             ; arg_list - parses arg_list e.g. ab:c
0E4E                             ; -- arg_list*
0E4E                PARSEARGS:      
0E4E   11 00 00               LD   de,0   ; d = count locals, e = count args ()
0E51   2A EA 23               LD   hl,(vHeapPtr)   ; hl = heap*
0E54   E5                     PUSH   hl   ; save start of arg_list
0E55   23                     INC   hl   ; skip length fields to start of string
0E56   23                     INC   hl   
0E57   03                     INC   bc   ; point to next char
0E58                PARSEARGS1:      
0E58   0A                     LD   a,(bc)   
0E59   FE 3A                  CP   ":"   ; ":" switches from args to locals
0E5B   20 03                  JR   nz,parseArgs1a   
0E5D   14                     INC   d   ; non zero value local count acts as flag
0E5E   18 10                  JR   parseArgs3   
0E60                PARSEARGS1A:      
0E60   FE 61                  CP   "a"   ; < "a" terminates arg_list
0E62   38 0F                  JR   c,parseArgs4   
0E64   FE 7B                  CP   "z"+1   ; > "z" terminates arg_list
0E66   30 0B                  JR   nc,parseArgs4   
0E68                PARSEARGS2:      
0E68   77                     LD   (hl),a   
0E69   23                     INC   hl   
0E6A   1C                     INC   e   ; increase arg count
0E6B   AF                     XOR   a   
0E6C   B2                     OR   d   
0E6D   28 01                  JR   z,parseArgs3   
0E6F   14                     INC   d   ; if d > 0 increase local count
0E70                PARSEARGS3:      
0E70   03                     INC   bc   ; point to next char
0E71   18 E5                  JR   parseArgs1   
0E73                PARSEARGS4:      
0E73   0B                     DEC   bc   
0E74   AF                     XOR   a   
0E75   B2                     OR   d   
0E76   28 01                  JR   z,parseArgs5   
0E78   15                     DEC   d   ; remove initial inc
0E79                PARSEARGS5:      
0E79   23                     INC   hl   
0E7A   22 EA 23               LD   (vHeapPtr),hl   ; bump heap* to after end of string
0E7D   E1                     POP   hl   ; hl = start of arg_list
0E7E   72                     LD   (hl),d   ; write number of locals at start - 1
0E7F   23                     INC   hl   
0E80   73                     LD   (hl),e   ; write number of args + locals at start - 2
0E81   2B                     DEC   hl   
0E82   E3                     EX   (sp),hl   
0E83   E9                     JP   (hl)   
0E84                             ; create block: parses block e.g. 00bbIC4uLi4g
0E84                             ; -- block*
0E84                PARSEBLOCK:      
0E84   C5                     PUSH   bc   ; return pointer to first { of block
0E85   03                     INC   bc   
0E86   16 01                  LD   d,1   ; nesting: count first parenthesis
0E88                PARSEBLOCK1:      ; Skip to end of definition
0E88   0A                     LD   a,(bc)   ; Get the next character
0E89   03                     INC   bc   ; Point to next character
0E8A   FE 21                  CP   " " + 1   ; ignore whitespace
0E8C   38 FA                  JR   c,parseBlock1   
0E8E   FE 27                  CP   "'"   ; quote char
0E90   28 0F                  JR   z,parseBlock2   
0E92   FE 22                  CP   DQ   ; double quote char
0E94   28 0B                  JR   z,parseBlock2   
0E96   FE 60                  CP   "`"   ; grave char
0E98   28 07                  JR   z,parseBlock2   
0E9A   CB 7A                  BIT   7,d   
0E9C   20 EA                  JR   nz,parseBlock1   
0E9E   C3 A7 0E               JP   parseBlock3   
0EA1                PARSEBLOCK2:      
0EA1   3E 80                  LD   a,$80   
0EA3   AA                     XOR   d   
0EA4   57                     LD   d,a   
0EA5   18 E1                  JR   parseBlock1   
0EA7                PARSEBLOCK3:      
0EA7   FE 28                  CP   "("   
0EA9   28 16                  JR   z,parseBlock4   
0EAB   FE 7B                  CP   "{"   
0EAD   28 12                  JR   z,parseBlock4   
0EAF   FE 5B                  CP   "["   
0EB1   28 0E                  JR   z,parseBlock4   
0EB3   FE 29                  CP   ")"   
0EB5   28 0D                  JR   z,parseBlock5   
0EB7   FE 7D                  CP   "}"   
0EB9   28 09                  JR   z,parseBlock5   
0EBB   FE 5D                  CP   "]"   
0EBD   28 05                  JR   z,parseBlock5   
0EBF   18 C7                  JR   parseBlock1   
0EC1                PARSEBLOCK4:      
0EC1   14                     INC   d   
0EC2   18 C4                  JR   parseBlock1   
0EC4                PARSEBLOCK5:      
0EC4   15                     DEC   d   
0EC5   20 C1                  JR   nz,parseBlock1   ; get the next element
0EC7   60 69                  LD   hl,bc   ; hl = IP
0EC9   11 22 24               LD   de,HEAP   ; is IP pointing to object in heap
0ECC   B7                     OR   a   ; IP - HEAP
0ECD   ED 52                  SBC   hl,de   
0ECF   CB 7C                  BIT   7,h   ; if -ve then copy to heap else skip
0ED1   28 1C                  JR   z,parseBlock6   
0ED3   60 69                  LD   hl,bc   ; hl = IP
0ED5   D1                     POP   de   ; de = block*
0ED6   ED 43 04 24            LD   (vTemp1),bc   ; save IP
0EDA   B7                     OR   a   ; bc = size
0EDB   ED 52                  SBC   hl,de   
0EDD   44 4D                  LD   bc,hl   
0EDF   EB                     EX   de,hl   ; hl = block* de = heap*
0EE0   ED 5B EA 23            LD   de,(vHeapPtr)   
0EE4   D5                     PUSH   de   ; return hblock*
0EE5   ED B0                  LDIR      ; copy size bytes from block* to hblock*
0EE7   ED 53 EA 23            LD   (vHeapPtr),de   ; heap* += size
0EEB   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
0EEF                PARSEBLOCK6:      
0EEF   0B                     DEC   bc   ; balanced, exit
0EF0   E1                     POP   hl   ; hl = block*
0EF1   E3                     EX   (sp),hl   ; return to caller
0EF2   E9                     JP   (hl)   
0EF3                             ; create function
0EF3                             ; arg_list* block* -- func*
0EF3                CREATEFUNC:      
0EF3   E1                     POP   hl   ; save retrn address
0EF4   22 08 24               LD   (vTemp3),hl   
0EF7   ED 43 04 24            LD   (vTemp1),bc   ; save IP
0EFB   E1                     POP   hl   ; hl = block*
0EFC   22 06 24               LD   (vTemp2),hl   ; save block*
0EFF   FD 5E 04               LD   e,(iy+4)   ; de = outer_arg_list
0F02   FD 56 05               LD   d,(iy+5)   
0F05   7B                     LD   a,e   ; if arg_list == null then make a func
0F06   B2                     OR   d   
0F07   20 09                  JR   nz,createFunc0   
0F09   21 00 00               LD   hl,0   ; partial_array = null
0F0C   ED 5B EA 23            LD   de,(vHeapPtr)   ; de = compile*
0F10   18 65                  JR   createFunc5   
0F12                CREATEFUNC0:      
0F12   E1                     POP   hl   ; hl = inner_arg_list*
0F13   E5                     PUSH   hl   ; save inner_arg_list
0F14   ED 5B EA 23            LD   de,(vHeapPtr)   ; de = compile*
0F18   7E                     LD   a,(hl)   ; compile inner_num_locals
0F19   4F                     LD   c,a   ; b = inner_num_locals
0F1A   12                     LD   (de),a   
0F1B   23                     INC   hl   
0F1C   13                     INC   de   
0F1D   7E                     LD   a,(hl)   ; compile inner_length
0F1E   12                     LD   (de),a   
0F1F   91                     SUB   c   ; a = inner_num args
0F20   23                     INC   hl   
0F21   13                     INC   de   
0F22   B7                     OR   a   ; compile args if inner_length > 0
0F23   28 05                  JR   z,createFunc1   
0F25   4F                     LD   c,a   ; bc = a
0F26   06 00                  LD   b,0   
0F28   ED B0                  LDIR      
0F2A                CREATEFUNC1:      
0F2A   EB                     EX   de,hl   ; hl = outer_arg_list
0F2B   FD 5E 04               LD   e,(iy+4)   
0F2E   FD 56 05               LD   d,(iy+5)   
0F31   EB                     EX   de,hl   
0F32   23                     INC   hl   ; a = outer_length
0F33   7E                     LD   a,(hl)   
0F34   23                     INC   hl   
0F35   B7                     OR   a   
0F36   28 05                  JR   z,createFunc2   
0F38   4F                     LD   c,a   
0F39   06 00                  LD   b,0   
0F3B   ED B0                  LDIR      ; append outer_args
0F3D                CREATEFUNC2:      ; a = outer_length
0F3D   47                     LD   b,a   ; b = a = outer_length
0F3E   2A EA 23               LD   hl,(vHeapPtr)   ; b > 0, hl = start of cloned arg_list
0F41   23                     INC   hl   
0F42   7E                     LD   a,(hl)   ; add outer_length to new length
0F43   80                     ADD   a,b   
0F44   77                     LD   (hl),a   
0F45   2B                     DEC   hl   
0F46   78                     LD   a,b   ; save outer_length in a'
0F47   08                     EX   af,af'   
0F48   E3                     EX   (sp),hl   ; hl = inner_arg_list*, (sp) new_arg_list
0F49   7E                     LD   a,(hl)   ; c = a = inner_num_locals
0F4A   B7                     OR   a   
0F4B   28 0F                  JR   z,createFunc2a   ; if inner_num_locals == 0 skip
0F4D   4F                     LD   c,a   ; c = inner_num_locals
0F4E   06 00                  LD   b,0   ; bc = inner_num_locals
0F50   23                     INC   hl   ; a = inner_length
0F51   7E                     LD   a,(hl)   
0F52   91                     SUB   c   ; a = inner_num_args
0F53   23                     INC   hl   ; hl = inner_arg_chars
0F54   85                     ADD   a,l   ; hl += a
0F55   6F                     LD   l,a   
0F56   3E 00                  LD   a,0   
0F58   84                     ADD   a,h   
0F59   67                     LD   h,a   
0F5A   ED B0                  LDIR      ; append inner_locals
0F5C                CREATEFUNC2A:      
0F5C   08                     EX   af,af'   ; restore outer_length to a, de = partial_array[-2]
0F5D   12                     LD   (de),a   ; compile partial_array length field
0F5E   13                     INC   de   
0F5F   AF                     XOR   a   
0F60   12                     LD   (de),a   
0F61   13                     INC   de   
0F62   D5                     PUSH   de   ; push partial_array*
0F63   EB                     EX   de,hl   ; hl = first_arg, copy outer_args+locals to partial_array
0F64   FD 5E 02               LD   e,(iy+2)   
0F67   FD 56 03               LD   d,(iy+3)   
0F6A   EB                     EX   de,hl   
0F6B                CREATEFUNC3:      
0F6B   2B                     DEC   hl   ; c = MSB of arg from stack (incl. locals)
0F6C   4E                     LD   c,(hl)   
0F6D   2B                     DEC   hl   
0F6E   7E                     LD   a,(hl)   ; a = LSB of arg from stack (incl. locals)
0F6F   12                     LD   (de),a   ; write LSB and MSB to partial_array*
0F70   13                     INC   de   
0F71   79                     LD   a,c   
0F72   12                     LD   (de),a   
0F73   13                     INC   de   
0F74   10 F5                  DJNZ   createFunc3   ; b = outer_length
0F76                CREATEFUNC4:      
0F76   E1                     POP   hl   ; hl = partial_array*
0F77                CREATEFUNC5:      
0F77   C1                     POP   bc   ; bc = new_arg_list*
0F78   D5                     PUSH   de   ; return new func*
0F79   EB                     EX   de,hl   ; hl = new func*, de = partial_array*
0F7A   73                     LD   (hl),e   ; compile partial_array* to func
0F7B   23                     INC   hl   
0F7C   72                     LD   (hl),d   
0F7D   23                     INC   hl   
0F7E   ED 5B 06 24            LD   de,(vTemp2)   ; de = block*
0F82   73                     LD   (hl),e   ; compile block* to func
0F83   23                     INC   hl   
0F84   72                     LD   (hl),d   
0F85   23                     INC   hl   
0F86   71                     LD   (hl),c   ; compile new_arg_list* to func
0F87   23                     INC   hl   
0F88   70                     LD   (hl),b   
0F89   23                     INC   hl   
0F8A   22 EA 23               LD   (vHeapPtr),hl   ; bump heap ptr
0F8D   ED 4B 04 24            LD   bc,(vTemp1)   ; restore IP
0F91   2A 08 24               LD   hl,(vTemp3)   ; jump to return address
0F94   E9                     JP   (hl)   
0F95                             ;*******************************************************************
0F95                             ; general routines
0F95                             ;*******************************************************************
0F95                             ; hl = address
0F95                VARIABLE:      
0F95   22 F8 23               LD   (vPointer),hl   
0F98   5E                     LD   e,(hl)   
0F99   3A EE 23               LD   a,(vDataWidth)   
0F9C   3D                     DEC   a   
0F9D   16 00                  LD   d,0   
0F9F   28 03                  JR   z,constant   
0FA1   23                     INC   hl   
0FA2   56                     LD   d,(hl)   
0FA3   2B                     DEC   hl   
0FA4                CONSTANT:      
0FA4   D5                     PUSH   de   
0FA5   DD E9                  JP   (ix)   
0FA7                             ; followed by a table
0FA7                             ; indexed on the 0-25 lowercase letter
0FA7                             ; db lsb(addr)
0FA7                             ; the final item index 26 matches any other char
0FA7                CHARTABLE:      
0FA7   03                     INC   bc   
0FA8   0A                     LD   a,(bc)   
0FA9   FE 7B                  CP   "z"+1   
0FAB   30 10                  JR   nc,charTable3   
0FAD   D6 61                  SUB   "a"   
0FAF   38 0C                  JR   c,charTable3   
0FB1                CHARTABLE1:      
0FB1   E1                     POP   hl   
0FB2   85                     ADD   a,l   
0FB3   6F                     LD   l,a   
0FB4   7E                     LD   a,(hl)   ; must have the same msb as the table
0FB5   B7                     OR   a   ; a = 0, nop
0FB6   20 03                  JR   nz,charTable2   
0FB8   C3 E6 06               JP   error1   
0FBB                CHARTABLE2:      
0FBB   6F                     LD   l,a   
0FBC   E9                     JP   (hl)   
0FBD                CHARTABLE3:      
0FBD   3E 1A                  LD   a,26   
0FBF   0B                     DEC   bc   
0FC0   18 EF                  JR   charTable1   
0FC2                             ; followed by a table
0FC2                             ; db char
0FC2                             ; db char - if null only match on first char
0FC2                             ; dw addr
0FC2                             ; the final item must have char == NUL
0FC2                CMDTABLE:      
0FC2   E1                     POP   hl   
0FC3                CMDTABLE1:      
0FC3                CMDTABLE2:      
0FC3   56                     LD   d,(hl)   
0FC4   23                     INC   hl   
0FC5   5E                     LD   e,(hl)   
0FC6   23                     INC   hl   
0FC7   AF                     XOR   a   ; if d == 0, matched
0FC8   BA                     CP   d   
0FC9   28 14                  JR   z,cmdTable5   
0FCB   03                     INC   bc   ; match?
0FCC   0A                     LD   a,(bc)   
0FCD   BA                     CP   d   
0FCE   20 0A                  JR   nz,cmdTable4   
0FD0                CMDTABLE3:      
0FD0   AF                     XOR   a   ; if e == 0, matched
0FD1   BB                     CP   e   
0FD2   28 0B                  JR   z,cmdTable5   
0FD4   03                     INC   bc   
0FD5   0A                     LD   a,(bc)   ; match?
0FD6   BB                     CP   e   
0FD7   28 06                  JR   z,cmdTable5   
0FD9   0B                     DEC   bc   
0FDA                CMDTABLE4:      ; no match, restore bc, go to next table entry
0FDA   0B                     DEC   bc   
0FDB   23                     INC   hl   
0FDC   23                     INC   hl   
0FDD   18 E4                  JR   cmdTable2   
0FDF                CMDTABLE5:      ; matched, jump to addr
0FDF   5E                     LD   e,(hl)   
0FE0   23                     INC   hl   
0FE1   56                     LD   d,(hl)   
0FE2   EB                     EX   de,hl   
0FE3   E9                     JP   (hl)   
0FE4                GETVARADDR:      
0FE4   21 00 00               LD   hl,0   
0FE7   FE 7B                  CP   "z"+1   ; if a > z then exit
0FE9   D0                     RET   nc   
0FEA   D6 41                  SUB   "A"   ; a - 65
0FEC   D8                     RET   c   ; if < A then exit
0FED   FE 1A                  CP   "Z"+1-"A"   ; if > Z then subtract 7
0FEF   38 05                  JR   c,getVarAddr1   
0FF1   D6 06                  SUB   "a"-("Z"+1)   
0FF3   FE 1A                  CP   "Z"-"A"+1   
0FF5   D8                     RET   c   ; if < a then exit
0FF6                GETVARADDR1:      
0FF6   87                     ADD   a,a   ; double a
0FF7   6F                     LD   l,a   
0FF8   26 23                  LD   h,msb(VARS)   
0FFA   C9                     RET      
0FFB                PUTSTR0:      
0FFB   CD 85 00               CALL   putchar   
0FFE   23                     INC   hl   
0FFF                PUTSTR:      
0FFF   7E                     LD   a,(hl)   
1000   B7                     OR   a   
1001   20 F8                  JR   nz,putstr0   
1003   C9                     RET      
1004                             ; **************************************************************************
1004                             ; calculate nesting value
1004                             ; a is char to be tested,
1004                             ; e is the nesting value (initially 0)
1004                             ; e is increased by ( and [
1004                             ; e is decreased by ) and ]
1004                             ; e has its bit 7 toggled by `
1004                             ; limited to 127 levels
1004                             ; **************************************************************************
1004                NESTING:      
1004   FE 27                  CP   "'"   ; quote char
1006   28 0A                  JR   z,nesting0   
1008   FE 22                  CP   DQ   ; double quote char
100A   28 06                  JR   z,nesting0   
100C   FE 60                  CP   "`"   ; grave char
100E   28 02                  JR   z,nesting0   
1010   18 0A                  JR   nesting1   
1012                NESTING0:      
1012   CB 7B                  BIT   7,e   
1014   28 03                  JR   z,nesting1a   
1016   CB BB                  RES   7,e   
1018   C9                     RET      
1019                NESTING1A:      
1019   CB FB                  SET   7,e   
101B   C9                     RET      
101C                NESTING1:      
101C   CB 7B                  BIT   7,e   
101E   C0                     RET   nz   
101F   FE 7B                  CP   "{"   
1021   28 08                  JR   z,nesting2   
1023   FE 5B                  CP   "["   
1025   28 04                  JR   z,nesting2   
1027   FE 28                  CP   "("   
1029   20 02                  JR   nz,nesting3   
102B                NESTING2:      
102B   1C                     INC   e   
102C   C9                     RET      
102D                NESTING3:      
102D   FE 7D                  CP   "}"   
102F   28 07                  JR   z,nesting4   
1031   FE 5D                  CP   "]"   
1033   28 03                  JR   z,nesting4   
1035   FE 29                  CP   ")"   
1037   C0                     RET   nz   
1038                NESTING4:      
1038   1D                     DEC   e   
1039   C9                     RET      
103A                PROMPT:      
103A   CD 4A 10               CALL   printStr   
103D   0D 0A 3E 20 00         .CSTR   "\r\n> "   
1042   C9                     RET      
1043                CRLF:        
1043   CD 4A 10               CALL   printStr   
1046   0D 0A 00               .CSTR   "\r\n"   
1049   C9                     RET      
104A                             ; prints a null teminated string
104A                             ; the string should be immediately following the call
104A                PRINTSTR:      
104A   E3                     EX   (sp),hl   ; swap			
104B   CD FF 0F               CALL   putstr   
104E   23                     INC   hl   ; inc past NUL
104F   E3                     EX   (sp),hl   ; put it back	
1050   C9                     RET      
1051                INIT:        
1051   21 F0 01               LD   hl,titleStr   
1054   11 0E 24               LD   de,titleBuf   
1057   06 14                  LD   b,20   
1059                INIT1:       
1059   1A                     LD   a,(de)   
105A   BE                     CP   (hl)   
105B   20 17                  JR   nz,coldBoot0   
105D   13                     INC   de   
105E   23                     INC   hl   
105F   10 F8                  DJNZ   init1   
1061                WARMINIT:      
1061   ED 4B FC 23            LD   bc,(vSavedIP)   ; restore IP
1065   ED 7B FE 23            LD   sp,(vSavedSP)   ; restore SP
1069   DD 2A 00 24            LD   ix,(vSavedNext)   ; restore Next
106D   FD 2A 02 24            LD   iy,(vSavedBP)   ; restore BP
1071   C3 AB 10               JP   start1   
1074                COLDBOOT0:      
1074   21 F0 01               LD   hl,titleStr   ; copy titleStr to titleBuf
1077   11 0E 24               LD   de,titleBuf   
107A   06 14                  LD   b,20   
107C   ED B0                  LDIR      
107E                COLDINIT:      
107E   21 DE 01               LD   hl,isysVars   
1081   11 E6 23               LD   de,sysVars   
1084   01 12 00               LD   bc,4 * 2 + 10   
1087   ED B0                  LDIR      
1089   21 00 23               LD   hl,vars   ; 52 vars LO HI
108C   06 34                  LD   b,26*2   
108E   AF                     XOR   a   
108F                COLDBOOT1:      
108F   77                     LD   (hl),a   
1090   23                     INC   hl   
1091   10 FC                  DJNZ   coldBoot1   
1093   DD 21 27 11            LD   ix,NEXT   
1097   FD 21 00 21            LD   iy,STACK   
109B   C9                     RET      
109C                COLDSTART:      
109C   31 00 21               LD   sp,STACK   
109F   CD 74 10               CALL   coldBoot0   
10A2   C3 AB 10               JP   start1   
10A5                START:       
10A5   31 00 21               LD   sp,STACK   ; start Monty
10A8   CD 51 10               CALL   init   ; setups
10AB                START1:      
10AB   21 0E 24               LD   hl,titleBuf   
10AE   CD FF 0F               CALL   putstr   ; prog count to stack, put code line 235 on stack then call print
10B1                INTERPRET:      
10B1   CD 3A 10               CALL   prompt   
10B4   01 00 00               LD   bc,0   ; load TIB length, decide char into tib or execute or control
10B7   21 00 21               LD   hl,TIB   
10BA   22 E6 23               LD   (vTIBPtr),hl   ; no chars in TIB so set end pointer to beginning
10BD                INTERPRET2:      ; calculate nesting
10BD   1E 00                  LD   e,0   ; initilize nesting value
10BF   C5                     PUSH   bc   ; save offset into TIB,
10C0                             ; bc is also the count of chars in TIB
10C0   21 00 21               LD   hl,TIB   ; hl is start of TIB
10C3   18 06                  JR   interpret4   
10C5                INTERPRET3:      
10C5   7E                     LD   a,(hl)   ; a = char in TIB
10C6   23                     INC   hl   ; inc pointer into TIB
10C7   0B                     DEC   bc   ; dec count of chars in TIB
10C8   CD 04 10               CALL   nesting   ; update nesting value
10CB                INTERPRET4:      
10CB   79                     LD   a,c   ; is count zero?
10CC   B0                     OR   b   
10CD   20 F6                  JR   nz,interpret3   ; if not loop
10CF   C1                     POP   bc   ; restore offset into TIB
10D0                INTERPRET5:      
10D0   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
10D3   FE 20                  CP   $20   ; compare to space
10D5   30 14                  JR   nc,interpret6   ; if >= space, if below 20 set cary flag
10D7   FE 00                  CP   NUL   ; is it end of string? NUL end of string
10D9   28 31                  JR   z,interpret8   
10DB   FE 0D                  CP   "\r"   ; carriage return? ascii 13
10DD   28 1A                  JR   z,interpret7   ; if anything else its macro/control
10DF   FE 08                  CP   CTRL_H   
10E1   CA 5D 11               JP   z,backSpace_   
10E4   FE 0A                  CP   CTRL_J   
10E6   CA 6D 11               JP   z,reEdit_   
10E9                INTERPRET5A:      
10E9   18 D2                  JR   interpret2   
10EB                INTERPRET6:      
10EB   21 00 21               LD   hl,TIB   
10EE   09                     ADD   hl,bc   
10EF   77                     LD   (hl),a   ; store the character in textbuf
10F0   03                     INC   bc   
10F1   CD 85 00               CALL   putchar   ; echo character to screen
10F4   CD 04 10               CALL   nesting   
10F7   18 D7                  JR   interpret5   ; wait for next character
10F9                INTERPRET7:      
10F9   21 00 21               LD   hl,TIB   
10FC   09                     ADD   hl,bc   
10FD   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
10FF   23                     INC   hl   
1100   36 0A                  LD   (hl),"\n"   
1102   23                     INC   hl   
1103   03                     INC   bc   
1104   03                     INC   bc   
1105   CD 43 10               CALL   crlf   ; echo character to screen
1108   7B                     LD   a,e   ; if zero nesting append and ETX after \r
1109   B7                     OR   a   
110A   20 C4                  JR   nz,interpret5   
110C                INTERPRET8:      
110C   21 00 21               LD   hl,TIB   
110F   09                     ADD   hl,bc   
1110   22 E6 23               LD   (vTIBPtr),hl   
1113   01 00 21               LD   bc,TIB   
1116   ED 43 FC 23            LD   (vSavedIP),bc   ; save IP
111A   ED 73 FE 23            LD   (vSavedSP),sp   ; save SP
111E   DD 22 00 24            LD   (vSavedNext),ix   ; save Next
1122   FD 22 02 24            LD   (vSavedBP),iy   ; save BP
1126   0B                     DEC   bc   
1127                NEXT:        
1127   03                     INC   bc   ; Increment the IP
1128   0A                     LD   a,(bc)   ; Get the next character and dispatch
1129   FE 20                  CP   " "   ; whitespace?
112B   28 FA                  JR   z,next   ; space? ignore
112D   38 0D                  JR   c,next1   
112F   C6 5F                  ADD   a,$80 - "!"   ; subtract "!", add $80 (opcodes lsb starts at $80)
1131   6F                     LD   l,a   ; index into table
1132   26 01                  LD   h,msb(opcodes)   ; start address of jump table
1134   6E                     LD   l,(hl)   ; get low jump address
1135   24                     INC   h   ; page 2
1136   FE BA                  CP   "Z" - "!" + 1 + $80   
1138   38 01                  JR   c,next0   
113A   24                     INC   h   ; page 3
113B                NEXT0:       
113B   E9                     JP   (hl)   ; Jump to routine
113C                NEXT1:       
113C   FE 00                  CP   NUL   ; end of input string?
113E   28 03                  JR   z,exit   
1140   C3 B1 10               JP   interpret   ; no, other whitespace, macros?
1143                EXIT:        
1143   03                     INC   bc   
1144   60 69                  LD   hl,bc   
1146   E9                     JP   (hl)   
1147                RUN:         
1147   C1                     POP   bc   
1148   0B                     DEC   bc   
1149   DD E9                  JP   (ix)   
114B                ERROR:       
114B   E5                     PUSH   hl   
114C   CD 47 11               CALL   run   
114F   60 45 72 72 6F 72 20 60 20 2E 00 DB   "`Error ` .",0   
115A   C3 B1 10               JP   interpret   
115D                BACKSPACE_:      
115D   79                     LD   a,c   
115E   B0                     OR   b   
115F   CA BD 10               JP   z,interpret2   
1162   0B                     DEC   bc   
1163   CD 4A 10               CALL   printStr   
1166   08 20 08 00            .CSTR   "\b \b"   
116A   C3 BD 10               JP   interpret2   
116D                REEDIT_:      
116D   CD 4A 10               CALL   printStr   
1170   0D 3E 20 00            .CSTR   "\r> "   
1174   21 00 21               LD   hl,TIB   
1177   18 04                  JR   reEdit1   
1179                REEDIT0:      
1179   CD 85 00               CALL   putchar   
117C   23                     INC   hl   
117D                REEDIT1:      
117D   7E                     LD   a,(hl)   
117E   FE 0D                  CP   "\r"   
1180   20 F7                  JR   nz,reEdit0   
1182   11 00 21               LD   de,TIB   
1185   B7                     OR   a   
1186   ED 52                  SBC   hl,de   
1188   44 4D                  LD   bc,hl   
118A   C3 BD 10               JP   interpret2   
118D                F1:          
118D                F2:          
118D                F3:          
118D                F4:          
118D                             ; 
2000                          .ORG   RAMSTART   
2000                STKSIZE:   EQU   $100   ; Stack size
2000                TIBSIZE:   EQU   $100   ; 256 bytes
2000                BUFSIZE:   EQU   $100   ; 256 bytes, wraps
2000                          ALIGN   $100   
2000                          DS   STKSIZE   
2100                STACK:       
2100                          ALIGN   $100   
2100                TIB:      DS   TIBSIZE   ; must be one page, lsb of vTIBPtr is length and wraps around
2200                          ALIGN   $100   
2200                BUFFER:   DS   BUFSIZE   ; must be one page, lsb of vBufPtr is length and wraps around
2300                          ALIGN   $100   
2300                VARS:        
2300                          DS   26 * 2 * 4   ; 52 vars, 3 bytes, RST LO HI CHAR
23D0                RESTARTS:      
23D0                RST08:    DS   2   
23D2                RST10:    DS   2   
23D4                RST18:    DS   2   
23D6                RST20:    DS   2   
23D8                RST28:    DS   2   
23DA                RST30:    DS   2   ; 
23DC                BAUD:     DS   2   ; 
23DE                INTVEC:   DS   2   ; 
23E0                NMIVEC:   DS   2   ; 
23E2                GETCVEC:   DS   2   ; 
23E4                PUTCVEC:   DS   2   ; 
23E6                SYSVARS:      
23E6                             ; initialised sys variables (preserved)
23E6                VTIBPTR:   DS   2   
23E8                VBUFPTR:   DS   2   
23EA                VHEAPPTR:   DS   2   
23EC                VRECURPTR:   DS   2   
23EE                VDATAWIDTH:   DS   1   
23EF                VNUMBASE:   DS   1   
23F0                VHEXPREFIX:   DS   1   
23F1                VECHO:    DS   1   
23F2                VSTRMODE:   DS   1   
23F3                          DS   1   
23F4                          DS   1   
23F5                          DS   1   
23F6                          DS   1   
23F7                          DS   1   
23F8                             ; uninitialised sys variables (preserved)
23F8                VPOINTER:   DS   2   ; 
23FA                VREMAIN:   DS   2   ; 
23FC                VSAVEDIP:   DS   2   ; 
23FE                VSAVEDSP:   DS   2   ; 
2400                VSAVEDNEXT:   DS   2   ; 
2402                VSAVEDBP:   DS   2   ; 
2404                             ; uninitialised sys variables (unpreserved)
2404                VTEMP1:   DS   2   ; 
2406                VTEMP2:   DS   2   ; 
2408                VTEMP3:   DS   2   ; 
240A                          DS   2   ; 
240C                TBPTR:    DS   2   ; reserved for tests
240E                TITLEBUF:   DS   20   
2422                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 112 IN IOSerial.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 126 IN IOSerial.asm
                    > USED AT LINE 133 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 153 IN IOSerial.asm
                    > USED AT LINE 195 IN IOSerial.asm
                    > USED AT LINE 48 IN MAIN.asm
RAMSTART:           2000 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 15
ROMSIZE:            2000 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            2000 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
                    > USED AT LINE 493 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 317 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 321 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 27 IN MAIN.asm
                    > USED AT LINE 174 IN MAIN.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 158 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 182 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 186 IN IOSerial.asm
                    > USED AT LINE 188 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 299 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 300 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 303 IN IOSerial.asm
                    > USED AT LINE 307 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 315 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 316 IN IOSerial.asm
                    > USED AT LINE 320 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 1543 IN MAIN.asm
                    > USED AT LINE 1553 IN MAIN.asm
                    > USED AT LINE 2598 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 1561 IN MAIN.asm
                    > USED AT LINE 2437 IN MAIN.asm
                    > USED AT LINE 2620 IN MAIN.asm
                    > USED AT LINE 2704 IN MAIN.asm
RESET:              008B DEFINED AT LINE 450 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 1273 IN MAIN.asm
                    > USED AT LINE 1341 IN MAIN.asm
                    > USED AT LINE 1970 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 162 IN MAIN.asm
                    > USED AT LINE 1279 IN MAIN.asm
                    > USED AT LINE 1338 IN MAIN.asm
                    > USED AT LINE 1975 IN MAIN.asm
NUL:                0000 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 1535 IN MAIN.asm
                    > USED AT LINE 1537 IN MAIN.asm
                    > USED AT LINE 1539 IN MAIN.asm
                    > USED AT LINE 2601 IN MAIN.asm
                    > USED AT LINE 2669 IN MAIN.asm
DQ:                 0022 DEFINED AT LINE 19 IN MAIN.asm
                    > USED AT LINE 2155 IN MAIN.asm
                    > USED AT LINE 2458 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 20 IN MAIN.asm
CTRL_E:             0005 DEFINED AT LINE 21 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 22 IN MAIN.asm
                    > USED AT LINE 2606 IN MAIN.asm
CTRL_J:             000A DEFINED AT LINE 23 IN MAIN.asm
                    > USED AT LINE 2608 IN MAIN.asm
CTRL_L:             000C DEFINED AT LINE 24 IN MAIN.asm
CTRL_P:             0010 DEFINED AT LINE 25 IN MAIN.asm
CTRL_S:             0013 DEFINED AT LINE 26 IN MAIN.asm
OPCODES:            0180 DEFINED AT LINE 52 IN MAIN.asm
ISYSVARS:           01DE DEFINED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 2539 IN MAIN.asm
TITLESTR:           01F0 DEFINED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 2514 IN MAIN.asm
                    > USED AT LINE 2533 IN MAIN.asm
COLON_:             0204 DEFINED AT LINE 178 IN MAIN.asm
COMMA_:             0206 DEFINED AT LINE 181 IN MAIN.asm
DOLLAR_:            0209 DEFINED AT LINE 184 IN MAIN.asm
DQUOTE_:            020C DEFINED AT LINE 187 IN MAIN.asm
QUOTE_:             020C DEFINED AT LINE 188 IN MAIN.asm
DOT_:               020F DEFINED AT LINE 191 IN MAIN.asm
PERCENT_:           0212 DEFINED AT LINE 194 IN MAIN.asm
QUESTION_:          0215 DEFINED AT LINE 197 IN MAIN.asm
LPAREN_:            0218 DEFINED AT LINE 200 IN MAIN.asm
SLASH_:             021B DEFINED AT LINE 203 IN MAIN.asm
NUM_:               021E DEFINED AT LINE 206 IN MAIN.asm
BANG_:              0221 DEFINED AT LINE 209 IN MAIN.asm
BANG:               0221 DEFINED AT LINE 210 IN MAIN.asm
NOT:                022C DEFINED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
EQ_:                0232 DEFINED AT LINE 222 IN MAIN.asm
EQ:                 0232 DEFINED AT LINE 223 IN MAIN.asm
EQ0:                023C DEFINED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 227 IN MAIN.asm
EQ1:                023D DEFINED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
GT_:                0241 DEFINED AT LINE 236 IN MAIN.asm
GT:                 0241 DEFINED AT LINE 237 IN MAIN.asm
LT_:                024C DEFINED AT LINE 245 IN MAIN.asm
LT:                 024C DEFINED AT LINE 246 IN MAIN.asm
LT1:                0255 DEFINED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 244 IN MAIN.asm
HASH_:              025E DEFINED AT LINE 261 IN MAIN.asm
SEMICOLON_:         025E DEFINED AT LINE 262 IN MAIN.asm
SEMICOLON:          025E DEFINED AT LINE 263 IN MAIN.asm
ARRAYINDEX:         025E DEFINED AT LINE 264 IN MAIN.asm
ARRAYINDEX0:        0266 DEFINED AT LINE 270 IN MAIN.asm
ARRAYINDEX1:        0267 DEFINED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
RPAREN_:            026B DEFINED AT LINE 277 IN MAIN.asm
RPAREN:             026B DEFINED AT LINE 279 IN MAIN.asm
AMPER_:             0273 DEFINED AT LINE 287 IN MAIN.asm
AMPER:              0273 DEFINED AT LINE 288 IN MAIN.asm
AND:                0273 DEFINED AT LINE 289 IN MAIN.asm
MINUS_:             027D DEFINED AT LINE 307 IN MAIN.asm
MINUS:              027D DEFINED AT LINE 308 IN MAIN.asm
SUB:                0289 DEFINED AT LINE 316 IN MAIN.asm
                    > USED AT LINE 313 IN MAIN.asm
SUB1:               0293 DEFINED AT LINE 323 IN MAIN.asm
                    > USED AT LINE 320 IN MAIN.asm
SUB2:               029A DEFINED AT LINE 329 IN MAIN.asm
                    > USED AT LINE 326 IN MAIN.asm
SUB3:               029D DEFINED AT LINE 332 IN MAIN.asm
                    > USED AT LINE 1028 IN MAIN.asm
                    > USED AT LINE 2030 IN MAIN.asm
                    > USED AT LINE 2055 IN MAIN.asm
STAR_:              02A5 DEFINED AT LINE 338 IN MAIN.asm
STAR:               02A5 DEFINED AT LINE 339 IN MAIN.asm
MUL:                02AD DEFINED AT LINE 345 IN MAIN.asm
MUL2:               02AF DEFINED AT LINE 348 IN MAIN.asm
MUL3:               02B7 DEFINED AT LINE 353 IN MAIN.asm
                    > USED AT LINE 362 IN MAIN.asm
PLUS_:              02C9 DEFINED AT LINE 368 IN MAIN.asm
PLUS:               02C9 DEFINED AT LINE 369 IN MAIN.asm
ADD:                02C9 DEFINED AT LINE 370 IN MAIN.asm
ADD1:               02D4 DEFINED AT LINE 378 IN MAIN.asm
                    > USED AT LINE 374 IN MAIN.asm
ADD3:               02D8 DEFINED AT LINE 383 IN MAIN.asm
                    > USED AT LINE 298 IN MAIN.asm
                    > USED AT LINE 364 IN MAIN.asm
                    > USED AT LINE 571 IN MAIN.asm
                    > USED AT LINE 1377 IN MAIN.asm
                    > USED AT LINE 1611 IN MAIN.asm
ADD4:               02E2 DEFINED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 387 IN MAIN.asm
UPCASE_:            02E5 DEFINED AT LINE 395 IN MAIN.asm
UPCASE:             02E5 DEFINED AT LINE 396 IN MAIN.asm
LOWCASE_:           0300 DEFINED AT LINE 405 IN MAIN.asm
LOWCASE:            0300 DEFINED AT LINE 406 IN MAIN.asm
IDENT1:             0305 DEFINED AT LINE 410 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
LBRACK_:            0312 DEFINED AT LINE 422 IN MAIN.asm
LBRACK:             0312 DEFINED AT LINE 423 IN MAIN.asm
ARRAYSTART:         0312 DEFINED AT LINE 424 IN MAIN.asm
BACKSLASH_:         032E DEFINED AT LINE 439 IN MAIN.asm
BACKSLASH:          032E DEFINED AT LINE 440 IN MAIN.asm
LAMBDA:             032E DEFINED AT LINE 441 IN MAIN.asm
LAMBDA1:            0333 DEFINED AT LINE 444 IN MAIN.asm
                    > USED AT LINE 448 IN MAIN.asm
LAMBDA2:            0343 DEFINED AT LINE 453 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
RBRACK_:            034F DEFINED AT LINE 461 IN MAIN.asm
RBRACK:             034F DEFINED AT LINE 462 IN MAIN.asm
ARRAYEND:           034F DEFINED AT LINE 463 IN MAIN.asm
ARRAYEND1:          036B DEFINED AT LINE 480 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
ARRAYEND2:          037B DEFINED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 486 IN MAIN.asm
ARRAYEND3:          0380 DEFINED AT LINE 494 IN MAIN.asm
                    > USED AT LINE 479 IN MAIN.asm
CARET_:             039F DEFINED AT LINE 515 IN MAIN.asm
CARET:              039F DEFINED AT LINE 519 IN MAIN.asm
GO:                 039F DEFINED AT LINE 520 IN MAIN.asm
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
GO1:                03A0 DEFINED AT LINE 522 IN MAIN.asm
                    > USED AT LINE 1257 IN MAIN.asm
                    > USED AT LINE 1646 IN MAIN.asm
                    > USED AT LINE 1648 IN MAIN.asm
                    > USED AT LINE 1818 IN MAIN.asm
GO2:                03A6 DEFINED AT LINE 527 IN MAIN.asm
                    > USED AT LINE 525 IN MAIN.asm
GRAVE_:             03B5 DEFINED AT LINE 536 IN MAIN.asm
GRAVE:              03B5 DEFINED AT LINE 537 IN MAIN.asm
PRINTLITERAL:       03B5 DEFINED AT LINE 538 IN MAIN.asm
PRINTLITERAL0:      03BC DEFINED AT LINE 542 IN MAIN.asm
                    > USED AT LINE 549 IN MAIN.asm
PRINTLITERAL1:      03BF DEFINED AT LINE 546 IN MAIN.asm
                    > USED AT LINE 541 IN MAIN.asm
LBRACE_:            03CB DEFINED AT LINE 553 IN MAIN.asm
LBRACE:             03CB DEFINED AT LINE 554 IN MAIN.asm
                    > USED AT LINE 201 IN MAIN.asm
PIPE_:              03D0 DEFINED AT LINE 560 IN MAIN.asm
PIPE:               03D0 DEFINED AT LINE 561 IN MAIN.asm
OR:                 03D0 DEFINED AT LINE 562 IN MAIN.asm
RBRACE_:            03DB DEFINED AT LINE 573 IN MAIN.asm
TILDE_:             03DE DEFINED AT LINE 577 IN MAIN.asm
UNDERSCORE_:        03E1 DEFINED AT LINE 580 IN MAIN.asm
CHAR:               03E1 DEFINED AT LINE 581 IN MAIN.asm
AT_:                03E9 DEFINED AT LINE 589 IN MAIN.asm
AT:                 03E9 DEFINED AT LINE 590 IN MAIN.asm
ADDR:               03E9 DEFINED AT LINE 591 IN MAIN.asm
DOT:                0400 DEFINED AT LINE 602 IN MAIN.asm
                    > USED AT LINE 192 IN MAIN.asm
PRINT:              0400 DEFINED AT LINE 603 IN MAIN.asm
PRINTCHAR:          0413 DEFINED AT LINE 616 IN MAIN.asm
                    > USED AT LINE 608 IN MAIN.asm
PRINTSTRING:        0422 DEFINED AT LINE 627 IN MAIN.asm
                    > USED AT LINE 610 IN MAIN.asm
PRINTSTRING0:       0429 DEFINED AT LINE 631 IN MAIN.asm
                    > USED AT LINE 638 IN MAIN.asm
PRINTSTRING1:       042C DEFINED AT LINE 635 IN MAIN.asm
                    > USED AT LINE 630 IN MAIN.asm
PRINTNUMBER:        0437 DEFINED AT LINE 644 IN MAIN.asm
                    > USED AT LINE 612 IN MAIN.asm
PRINTDEC:           0442 DEFINED AT LINE 652 IN MAIN.asm
                    > USED AT LINE 648 IN MAIN.asm
PRINTDEC1:          0450 DEFINED AT LINE 660 IN MAIN.asm
                    > USED AT LINE 658 IN MAIN.asm
PRINTDEC2:          045F DEFINED AT LINE 672 IN MAIN.asm
                    > USED AT LINE 661 IN MAIN.asm
PRINTDEC3:          046F DEFINED AT LINE 686 IN MAIN.asm
                    > USED AT LINE 674 IN MAIN.asm
PRINTDEC4:          048F DEFINED AT LINE 700 IN MAIN.asm
                    > USED AT LINE 689 IN MAIN.asm
                    > USED AT LINE 691 IN MAIN.asm
                    > USED AT LINE 693 IN MAIN.asm
                    > USED AT LINE 695 IN MAIN.asm
                    > USED AT LINE 698 IN MAIN.asm
PRINTDEC5:          0491 DEFINED AT LINE 702 IN MAIN.asm
                    > USED AT LINE 705 IN MAIN.asm
PRINTDEC6:          04A1 DEFINED AT LINE 714 IN MAIN.asm
                    > USED AT LINE 709 IN MAIN.asm
PRINTDEC7:          04A2 DEFINED AT LINE 716 IN MAIN.asm
                    > USED AT LINE 713 IN MAIN.asm
PRINTHEX:           04A8 DEFINED AT LINE 727 IN MAIN.asm
                    > USED AT LINE 647 IN MAIN.asm
PRINTHEX1:          04B4 DEFINED AT LINE 734 IN MAIN.asm
                    > USED AT LINE 731 IN MAIN.asm
PRINTHEX2:          04BF DEFINED AT LINE 741 IN MAIN.asm
                    > USED AT LINE 738 IN MAIN.asm
PRINTHEX3:          04CE DEFINED AT LINE 750 IN MAIN.asm
                    > USED AT LINE 740 IN MAIN.asm
                    > USED AT LINE 743 IN MAIN.asm
PRINTHEX4:          04D7 DEFINED AT LINE 758 IN MAIN.asm
                    > USED AT LINE 756 IN MAIN.asm
SLASH:              0500 DEFINED AT LINE 773 IN MAIN.asm
                    > USED AT LINE 204 IN MAIN.asm
COMMAND:            0500 DEFINED AT LINE 774 IN MAIN.asm
COMMAND_A_:         0526 DEFINED AT LINE 810 IN MAIN.asm
COMMAND_B_:         0545 DEFINED AT LINE 827 IN MAIN.asm
COMMAND_D_:         0554 DEFINED AT LINE 836 IN MAIN.asm
COMMAND_E:          055F DEFINED AT LINE 843 IN MAIN.asm
COMMAND_F_:         056E DEFINED AT LINE 852 IN MAIN.asm
COMMAND_H_:         05A1 DEFINED AT LINE 880 IN MAIN.asm
COMMAND_I_:         05AC DEFINED AT LINE 887 IN MAIN.asm
COMMAND_M_:         05B7 DEFINED AT LINE 894 IN MAIN.asm
COMAND_O_:          05CA DEFINED AT LINE 905 IN MAIN.asm
COMMAND_P_:         05D5 DEFINED AT LINE 912 IN MAIN.asm
COMMAND_R_:         05DC DEFINED AT LINE 917 IN MAIN.asm
COMMAND_S_:         05DE DEFINED AT LINE 920 IN MAIN.asm
COMMAND_T_:         05E0 DEFINED AT LINE 923 IN MAIN.asm
COMMAND_V_:         05E2 DEFINED AT LINE 926 IN MAIN.asm
COMMAND_W_:         05E4 DEFINED AT LINE 929 IN MAIN.asm
COMMAND_X_:         05E6 DEFINED AT LINE 932 IN MAIN.asm
COMMAND_DEFAULT_:   05E8 DEFINED AT LINE 935 IN MAIN.asm
COMMAND_R:          05EB DEFINED AT LINE 942 IN MAIN.asm
                    > USED AT LINE 918 IN MAIN.asm
COMMAND_S:          0602 DEFINED AT LINE 955 IN MAIN.asm
                    > USED AT LINE 921 IN MAIN.asm
COMMAND_T:          0621 DEFINED AT LINE 972 IN MAIN.asm
                    > USED AT LINE 924 IN MAIN.asm
COMMAND_V:          062C DEFINED AT LINE 979 IN MAIN.asm
                    > USED AT LINE 927 IN MAIN.asm
COMMAND_W:          063B DEFINED AT LINE 988 IN MAIN.asm
                    > USED AT LINE 930 IN MAIN.asm
COMMAND_X:          064A DEFINED AT LINE 997 IN MAIN.asm
                    > USED AT LINE 933 IN MAIN.asm
COMMAND_DEFAULT:    0655 DEFINED AT LINE 1004 IN MAIN.asm
                    > USED AT LINE 936 IN MAIN.asm
DIV:                065C DEFINED AT LINE 1010 IN MAIN.asm
                    > USED AT LINE 1007 IN MAIN.asm
DIV2:               0666 DEFINED AT LINE 1019 IN MAIN.asm
                    > USED AT LINE 1016 IN MAIN.asm
ABSOLUTE:           0677 DEFINED AT LINE 1032 IN MAIN.asm
                    > USED AT LINE 813 IN MAIN.asm
ABSOLUTE1:          0682 DEFINED AT LINE 1042 IN MAIN.asm
                    > USED AT LINE 1035 IN MAIN.asm
ADDROF:             0685 DEFINED AT LINE 1048 IN MAIN.asm
                    > USED AT LINE 815 IN MAIN.asm
ADDROF2:            068B DEFINED AT LINE 1053 IN MAIN.asm
ARRAYLENGTH:        068D DEFINED AT LINE 1058 IN MAIN.asm
                    > USED AT LINE 821 IN MAIN.asm
                    > USED AT LINE 44
ARRAYLENGTH1:       0693 DEFINED AT LINE 1065 IN MAIN.asm
                    > USED AT LINE 1076 IN MAIN.asm
                    > USED AT LINE 1079 IN MAIN.asm
ARRAYSIZE:          0696 DEFINED AT LINE 1071 IN MAIN.asm
                    > USED AT LINE 823 IN MAIN.asm
PERFORMM_1513S1072: 069D DEFINED AT LINE 45
                    > USED AT LINE 43
WHILE:              06AA DEFINED AT LINE 1084 IN MAIN.asm
                    > USED AT LINE 991 IN MAIN.asm
WHILE1:             06B1 DEFINED AT LINE 1090 IN MAIN.asm
                    > USED AT LINE 1088 IN MAIN.asm
BYTEMODE:           06C4 DEFINED AT LINE 1102 IN MAIN.asm
                    > USED AT LINE 832 IN MAIN.asm
BYTEMODE1:          06C6 DEFINED AT LINE 1104 IN MAIN.asm
                    > USED AT LINE 1364 IN MAIN.asm
COMMENT:            06CB DEFINED AT LINE 1109 IN MAIN.asm
                    > USED AT LINE 778 IN MAIN.asm
                    > USED AT LINE 1113 IN MAIN.asm
DECBASE:            06D4 DEFINED AT LINE 1117 IN MAIN.asm
                    > USED AT LINE 839 IN MAIN.asm
DECBASE1:           06D6 DEFINED AT LINE 1119 IN MAIN.asm
                    > USED AT LINE 1132 IN MAIN.asm
ECHO:               06DB DEFINED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 846 IN MAIN.asm
HEXBASE:            06E1 DEFINED AT LINE 1130 IN MAIN.asm
                    > USED AT LINE 883 IN MAIN.asm
ERROR1:             06E6 DEFINED AT LINE 1134 IN MAIN.asm
                    > USED AT LINE 825 IN MAIN.asm
                    > USED AT LINE 834 IN MAIN.asm
                    > USED AT LINE 841 IN MAIN.asm
                    > USED AT LINE 850 IN MAIN.asm
                    > USED AT LINE 878 IN MAIN.asm
                    > USED AT LINE 885 IN MAIN.asm
                    > USED AT LINE 892 IN MAIN.asm
                    > USED AT LINE 903 IN MAIN.asm
                    > USED AT LINE 910 IN MAIN.asm
                    > USED AT LINE 915 IN MAIN.asm
                    > USED AT LINE 953 IN MAIN.asm
                    > USED AT LINE 970 IN MAIN.asm
                    > USED AT LINE 977 IN MAIN.asm
                    > USED AT LINE 986 IN MAIN.asm
                    > USED AT LINE 995 IN MAIN.asm
                    > USED AT LINE 1002 IN MAIN.asm
                    > USED AT LINE 2369 IN MAIN.asm
INPUT:              06EC DEFINED AT LINE 1140 IN MAIN.asm
                    > USED AT LINE 890 IN MAIN.asm
MEMALLOCATE:        06F7 DEFINED AT LINE 1152 IN MAIN.asm
                    > USED AT LINE 819 IN MAIN.asm
MEMFREE:            06F9 DEFINED AT LINE 1157 IN MAIN.asm
                    > USED AT LINE 861 IN MAIN.asm
MEMFREE1:           06FA DEFINED AT LINE 1159 IN MAIN.asm
                    > USED AT LINE 1169 IN MAIN.asm
MEMFREEARRAY:       06FF DEFINED AT LINE 1165 IN MAIN.asm
                    > USED AT LINE 863 IN MAIN.asm
MAXIMUM:            0704 DEFINED AT LINE 1173 IN MAIN.asm
                    > USED AT LINE 899 IN MAIN.asm
MAXIMUM1:           070E DEFINED AT LINE 1182 IN MAIN.asm
                    > USED AT LINE 1179 IN MAIN.asm
MINIMUM:            0710 DEFINED AT LINE 1187 IN MAIN.asm
                    > USED AT LINE 901 IN MAIN.asm
MINIMUM1:           071A DEFINED AT LINE 1196 IN MAIN.asm
                    > USED AT LINE 1193 IN MAIN.asm
OUTPUT:             071C DEFINED AT LINE 1201 IN MAIN.asm
                    > USED AT LINE 908 IN MAIN.asm
RETURN:             0725 DEFINED AT LINE 1212 IN MAIN.asm
                    > USED AT LINE 949 IN MAIN.asm
RETURN1:            072C DEFINED AT LINE 1218 IN MAIN.asm
                    > USED AT LINE 1216 IN MAIN.asm
RECUR:              072F DEFINED AT LINE 1221 IN MAIN.asm
                    > USED AT LINE 945 IN MAIN.asm
REMAIN:             0735 DEFINED AT LINE 1226 IN MAIN.asm
                    > USED AT LINE 947 IN MAIN.asm
SELECT:             073B DEFINED AT LINE 1233 IN MAIN.asm
                    > USED AT LINE 960 IN MAIN.asm
SELECT1:            0746 DEFINED AT LINE 1244 IN MAIN.asm
                    > USED AT LINE 1267 IN MAIN.asm
SELECT1A:           0757 DEFINED AT LINE 1258 IN MAIN.asm
                    > USED AT LINE 1248 IN MAIN.asm
SELECT1B:           0758 DEFINED AT LINE 1260 IN MAIN.asm
                    > USED AT LINE 1252 IN MAIN.asm
SELECT2:            075B DEFINED AT LINE 1264 IN MAIN.asm
                    > USED AT LINE 1243 IN MAIN.asm
STRINGBEGIN:        0762 DEFINED AT LINE 1272 IN MAIN.asm
                    > USED AT LINE 968 IN MAIN.asm
STRINGEND:          076A DEFINED AT LINE 1278 IN MAIN.asm
                    > USED AT LINE 848 IN MAIN.asm
STRINGEND1:         0791 DEFINED AT LINE 1296 IN MAIN.asm
                    > USED AT LINE 1275 IN MAIN.asm
STRINGLENGTH:       0799 DEFINED AT LINE 1301 IN MAIN.asm
                    > USED AT LINE 964 IN MAIN.asm
                    > USED AT LINE 44
STRINGLENGTH1:      079F DEFINED AT LINE 1305 IN MAIN.asm
                    > USED AT LINE 1311 IN MAIN.asm
STRINGLENGTH2:      07A1 DEFINED AT LINE 1308 IN MAIN.asm
                    > USED AT LINE 1304 IN MAIN.asm
STRINGLENGTH3:      07A5 DEFINED AT LINE 1312 IN MAIN.asm
                    > USED AT LINE 1320 IN MAIN.asm
STRINGSIZE:         07A8 DEFINED AT LINE 1316 IN MAIN.asm
                    > USED AT LINE 966 IN MAIN.asm
PERFORMM_1736S1317: 07AF DEFINED AT LINE 45
                    > USED AT LINE 43
STRINGCOMPARE:      07B4 DEFINED AT LINE 1325 IN MAIN.asm
                    > USED AT LINE 958 IN MAIN.asm
STRINGCOMPARE1:     07B6 DEFINED AT LINE 1328 IN MAIN.asm
                    > USED AT LINE 1336 IN MAIN.asm
STRINGCOMPARE2:     07C1 DEFINED AT LINE 1337 IN MAIN.asm
                    > USED AT LINE 1331 IN MAIN.asm
STRINGCOMPARE3:     07C6 DEFINED AT LINE 1340 IN MAIN.asm
                    > USED AT LINE 1333 IN MAIN.asm
STRINGCOMPARE4:     07C9 DEFINED AT LINE 1342 IN MAIN.asm
                    > USED AT LINE 1339 IN MAIN.asm
VARIABLES:          07CC DEFINED AT LINE 1348 IN MAIN.asm
VOID:               07D2 DEFINED AT LINE 1354 IN MAIN.asm
                    > USED AT LINE 984 IN MAIN.asm
WORDMODE:           07DA DEFINED AT LINE 1362 IN MAIN.asm
                    > USED AT LINE 993 IN MAIN.asm
XOR:                07DF DEFINED AT LINE 1367 IN MAIN.asm
                    > USED AT LINE 1000 IN MAIN.asm
XOR1:               07E0 DEFINED AT LINE 1369 IN MAIN.asm
RANGESRC:           07EA DEFINED AT LINE 32
                    > USED AT LINE 951 IN MAIN.asm
RANGESRCM_1797S1385: 07F9 DEFINED AT LINE 39
                    > USED AT LINE 35
ARRAYITER:          0883 DEFINED AT LINE 32
                    > USED AT LINE 817 IN MAIN.asm
ARRAYITERM_1816S1405: 0890 DEFINED AT LINE 39
                    > USED AT LINE 35
STRINGITER:         090A DEFINED AT LINE 32
                    > USED AT LINE 962 IN MAIN.asm
STRINGITERM_1835S1425: 0917 DEFINED AT LINE 39
                    > USED AT LINE 35
MAP:                099A DEFINED AT LINE 32
                    > USED AT LINE 897 IN MAIN.asm
MAPM_1855S1447:     09A7 DEFINED AT LINE 39
                    > USED AT LINE 35
FILTER:             09DC DEFINED AT LINE 32
                    > USED AT LINE 868 IN MAIN.asm
FILTERM_1869S1462:  09EA DEFINED AT LINE 39
                    > USED AT LINE 35
FOLD:               0A3D DEFINED AT LINE 32
                    > USED AT LINE 857 IN MAIN.asm
FOLDM_1888S1482:    0A4C DEFINED AT LINE 39
                    > USED AT LINE 35
FOREACH:            0A8E DEFINED AT LINE 32
                    > USED AT LINE 859 IN MAIN.asm
FOREACHM_1902S1497: 0A9C DEFINED AT LINE 39
                    > USED AT LINE 35
FUNCSRC:            0ADA DEFINED AT LINE 32
                    > USED AT LINE 866 IN MAIN.asm
FUNCSRCM_1916S1512: 0AE6 DEFINED AT LINE 39
                    > USED AT LINE 35
PRINTARRAY:         0B15 DEFINED AT LINE 32
                    > USED AT LINE 606 IN MAIN.asm
PRINTARRAYM_1926S1523: 0B23 DEFINED AT LINE 39
                    > USED AT LINE 35
COMMA:              0B5E DEFINED AT LINE 1533 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
READCHAR:           0B6D DEFINED AT LINE 1542 IN MAIN.asm
                    > USED AT LINE 1536 IN MAIN.asm
READSTRING:         0B76 DEFINED AT LINE 1549 IN MAIN.asm
                    > USED AT LINE 1538 IN MAIN.asm
                    > USED AT LINE 44
READSTRING1:        0B7B DEFINED AT LINE 1552 IN MAIN.asm
                    > USED AT LINE 1560 IN MAIN.asm
                    > USED AT LINE 1562 IN MAIN.asm
READSTRING2:        0B8F DEFINED AT LINE 1563 IN MAIN.asm
                    > USED AT LINE 1555 IN MAIN.asm
READNUMBER:         0B98 DEFINED AT LINE 1570 IN MAIN.asm
                    > USED AT LINE 1540 IN MAIN.asm
PERFORMM_1970S1572: 0BA1 DEFINED AT LINE 45
                    > USED AT LINE 43
READNUMBER1:        0BBF DEFINED AT LINE 1588 IN MAIN.asm
                    > USED AT LINE 1579 IN MAIN.asm
                    > USED AT LINE 1583 IN MAIN.asm
                    > USED AT LINE 1585 IN MAIN.asm
PERFORMM_1987S1589: 0BC6 DEFINED AT LINE 45
                    > USED AT LINE 43
READNUMBER2:        0BC9 DEFINED AT LINE 1592 IN MAIN.asm
                    > USED AT LINE 1581 IN MAIN.asm
PERFORMM_1991S1593: 0BD0 DEFINED AT LINE 45
                    > USED AT LINE 43
READNUMBER3:        0BD1 DEFINED AT LINE 1595 IN MAIN.asm
                    > USED AT LINE 1587 IN MAIN.asm
                    > USED AT LINE 1591 IN MAIN.asm
TILDE:              0BD7 DEFINED AT LINE 1602 IN MAIN.asm
                    > USED AT LINE 578 IN MAIN.asm
INVERT:             0BD7 DEFINED AT LINE 1603 IN MAIN.asm
DOLLAR:             0BE1 DEFINED AT LINE 1614 IN MAIN.asm
                    > USED AT LINE 185 IN MAIN.asm
HEXNUM:             0BE1 DEFINED AT LINE 1615 IN MAIN.asm
                    > USED AT LINE 44
HEXNUM1:            0BE4 DEFINED AT LINE 1617 IN MAIN.asm
                    > USED AT LINE 1634 IN MAIN.asm
HEXNUM2:            0BEC DEFINED AT LINE 1623 IN MAIN.asm
                    > USED AT LINE 1621 IN MAIN.asm
QUESTION:           0BFE DEFINED AT LINE 1638 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
IF:                 0BFE DEFINED AT LINE 1639 IN MAIN.asm
QUOTE:              0C0B DEFINED AT LINE 1652 IN MAIN.asm
                    > USED AT LINE 189 IN MAIN.asm
STRING:             0C0B DEFINED AT LINE 1653 IN MAIN.asm
STRING1:            0C14 DEFINED AT LINE 1660 IN MAIN.asm
                    > USED AT LINE 1668 IN MAIN.asm
STRING2:            0C17 DEFINED AT LINE 1664 IN MAIN.asm
                    > USED AT LINE 1659 IN MAIN.asm
STRING3:            0C1D DEFINED AT LINE 1669 IN MAIN.asm
                    > USED AT LINE 1667 IN MAIN.asm
PERCENT:            0C25 DEFINED AT LINE 1679 IN MAIN.asm
                    > USED AT LINE 195 IN MAIN.asm
ARG:                0C25 DEFINED AT LINE 1680 IN MAIN.asm
ARG0:               0C41 DEFINED AT LINE 1699 IN MAIN.asm
                    > USED AT LINE 1705 IN MAIN.asm
ARG0A:              0C4A DEFINED AT LINE 1707 IN MAIN.asm
                    > USED AT LINE 1686 IN MAIN.asm
                    > USED AT LINE 1691 IN MAIN.asm
ARG1:               0C4F DEFINED AT LINE 1710 IN MAIN.asm
                    > USED AT LINE 1703 IN MAIN.asm
ARG1A:              0C57 DEFINED AT LINE 1717 IN MAIN.asm
                    > USED AT LINE 1709 IN MAIN.asm
NUM:                0C5A DEFINED AT LINE 1722 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
                    > USED AT LINE 315 IN MAIN.asm
                    > USED AT LINE 44
NUM0:               0C63 DEFINED AT LINE 1728 IN MAIN.asm
                    > USED AT LINE 1726 IN MAIN.asm
NUM1:               0C64 DEFINED AT LINE 1730 IN MAIN.asm
                    > USED AT LINE 1747 IN MAIN.asm
NUM2:               0C7C DEFINED AT LINE 1748 IN MAIN.asm
                    > USED AT LINE 1625 IN MAIN.asm
                    > USED AT LINE 1627 IN MAIN.asm
                    > USED AT LINE 1733 IN MAIN.asm
                    > USED AT LINE 1735 IN MAIN.asm
NUM3:               0C87 DEFINED AT LINE 1756 IN MAIN.asm
                    > USED AT LINE 1751 IN MAIN.asm
RBRACE:             0C8A DEFINED AT LINE 1761 IN MAIN.asm
                    > USED AT LINE 574 IN MAIN.asm
BLOCKEND:           0C8A DEFINED AT LINE 1762 IN MAIN.asm
                    > USED AT LINE 1099 IN MAIN.asm
                    > USED AT LINE 1219 IN MAIN.asm
BLOCKEND1:          0CBC DEFINED AT LINE 1784 IN MAIN.asm
                    > USED AT LINE 1777 IN MAIN.asm
BLOCKEND2:          0CC8 DEFINED AT LINE 1791 IN MAIN.asm
                    > USED AT LINE 1783 IN MAIN.asm
BLOCKEND3:          0CDA DEFINED AT LINE 1805 IN MAIN.asm
                    > USED AT LINE 1797 IN MAIN.asm
BLOCKEND4:          0CEE DEFINED AT LINE 1815 IN MAIN.asm
                    > USED AT LINE 1813 IN MAIN.asm
GOBLOCK:            0CF7 DEFINED AT LINE 1820 IN MAIN.asm
                    > USED AT LINE 530 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
GOBLOCK2:           0D1C DEFINED AT LINE 1837 IN MAIN.asm
                    > USED AT LINE 1918 IN MAIN.asm
GOBLOCK3:           0D26 DEFINED AT LINE 1843 IN MAIN.asm
GOFUNC:             0D2A DEFINED AT LINE 1847 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
GOFUNC1:            0D43 DEFINED AT LINE 1866 IN MAIN.asm
                    > USED AT LINE 1876 IN MAIN.asm
GOFUNC2:            0D49 DEFINED AT LINE 1873 IN MAIN.asm
                    > USED AT LINE 1865 IN MAIN.asm
GOFUNC3:            0D54 DEFINED AT LINE 1879 IN MAIN.asm
                    > USED AT LINE 1855 IN MAIN.asm
GOFUNC4:            0D6C DEFINED AT LINE 1896 IN MAIN.asm
                    > USED AT LINE 1893 IN MAIN.asm
GOFUNC5:            0D6F DEFINED AT LINE 1899 IN MAIN.asm
                    > USED AT LINE 1905 IN MAIN.asm
GOFUNC6:            0D72 DEFINED AT LINE 1903 IN MAIN.asm
                    > USED AT LINE 1898 IN MAIN.asm
GOFUNC7:            0D75 DEFINED AT LINE 1906 IN MAIN.asm
GOFUNC8:            0D79 DEFINED AT LINE 1911 IN MAIN.asm
                    > USED AT LINE 1831 IN MAIN.asm
                    > USED AT LINE 1895 IN MAIN.asm
ASSIGN:             0D84 DEFINED AT LINE 1922 IN MAIN.asm
                    > USED AT LINE 229 IN MAIN.asm
ASSIGN0:            0D86 DEFINED AT LINE 1925 IN MAIN.asm
                    > USED AT LINE 322 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
                    > USED AT LINE 377 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
ASSIGN1:            0D8A DEFINED AT LINE 1928 IN MAIN.asm
ASSIGN2:            0D93 DEFINED AT LINE 1935 IN MAIN.asm
                    > USED AT LINE 1932 IN MAIN.asm
EQUALS:             0D95 DEFINED AT LINE 1940 IN MAIN.asm
                    > USED AT LINE 234 IN MAIN.asm
NOTEQUALS:          0D9C DEFINED AT LINE 1946 IN MAIN.asm
                    > USED AT LINE 217 IN MAIN.asm
LESSTHANEQ:         0DA3 DEFINED AT LINE 1954 IN MAIN.asm
                    > USED AT LINE 255 IN MAIN.asm
LESSTHAN:           0DA8 DEFINED AT LINE 1961 IN MAIN.asm
                    > USED AT LINE 257 IN MAIN.asm
LESSTHAN1:          0DAD DEFINED AT LINE 1966 IN MAIN.asm
                    > USED AT LINE 1957 IN MAIN.asm
TRUE1:              0DB0 DEFINED AT LINE 1969 IN MAIN.asm
                    > USED AT LINE 975 IN MAIN.asm
                    > USED AT LINE 1943 IN MAIN.asm
                    > USED AT LINE 1949 IN MAIN.asm
NULL1:              0DB6 DEFINED AT LINE 1973 IN MAIN.asm
FALSE1:             0DB6 DEFINED AT LINE 1974 IN MAIN.asm
                    > USED AT LINE 855 IN MAIN.asm
                    > USED AT LINE 1944 IN MAIN.asm
                    > USED AT LINE 1950 IN MAIN.asm
                    > USED AT LINE 1964 IN MAIN.asm
                    > USED AT LINE 1967 IN MAIN.asm
SPREAD:             0DBC DEFINED AT LINE 1979 IN MAIN.asm
                    > USED AT LINE 343 IN MAIN.asm
SPREAD1:            0DC9 DEFINED AT LINE 1989 IN MAIN.asm
                    > USED AT LINE 2004 IN MAIN.asm
SPREAD2:            0DD4 DEFINED AT LINE 1998 IN MAIN.asm
                    > USED AT LINE 1995 IN MAIN.asm
SPREAD3:            0DD6 DEFINED AT LINE 2001 IN MAIN.asm
                    > USED AT LINE 1988 IN MAIN.asm
SHIFTLEFT:          0DE0 DEFINED AT LINE 2011 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
SHIFTLEFT2:         0DEA DEFINED AT LINE 2020 IN MAIN.asm
                    > USED AT LINE 2017 IN MAIN.asm
SHIFTLEFT3:         0DF2 DEFINED AT LINE 2025 IN MAIN.asm
                    > USED AT LINE 2028 IN MAIN.asm
SHIFTLEFT4:         0DF3 DEFINED AT LINE 2027 IN MAIN.asm
                    > USED AT LINE 2024 IN MAIN.asm
SHIFTRIGHT:         0DFC DEFINED AT LINE 2035 IN MAIN.asm
                    > USED AT LINE 241 IN MAIN.asm
SHIFTRIGHT2:        0E06 DEFINED AT LINE 2044 IN MAIN.asm
                    > USED AT LINE 2041 IN MAIN.asm
SHIFTRIGHT3:        0E0E DEFINED AT LINE 2049 IN MAIN.asm
                    > USED AT LINE 2053 IN MAIN.asm
SHIFTRIGHT4:        0E12 DEFINED AT LINE 2052 IN MAIN.asm
                    > USED AT LINE 2048 IN MAIN.asm
DIVIDE:             0E1B DEFINED AT LINE 2061 IN MAIN.asm
                    > USED AT LINE 1023 IN MAIN.asm
DIVIDE1:            0E20 DEFINED AT LINE 2064 IN MAIN.asm
                    > USED AT LINE 2076 IN MAIN.asm
DIVIDE2:            0E2D DEFINED AT LINE 2072 IN MAIN.asm
                    > USED AT LINE 2069 IN MAIN.asm
DIVIDE3:            0E2E DEFINED AT LINE 2074 IN MAIN.asm
                    > USED AT LINE 2071 IN MAIN.asm
DOTNEXT:            0E34 DEFINED AT LINE 2080 IN MAIN.asm
                    > USED AT LINE 551 IN MAIN.asm
                    > USED AT LINE 623 IN MAIN.asm
                    > USED AT LINE 640 IN MAIN.asm
                    > USED AT LINE 667 IN MAIN.asm
                    > USED AT LINE 748 IN MAIN.asm
DOTNEXT1:           0E3C DEFINED AT LINE 2085 IN MAIN.asm
                    > USED AT LINE 2083 IN MAIN.asm
PARSEARGS:          0E4E DEFINED AT LINE 2096 IN MAIN.asm
                    > USED AT LINE 443 IN MAIN.asm
PARSEARGS1:         0E58 DEFINED AT LINE 2103 IN MAIN.asm
                    > USED AT LINE 2124 IN MAIN.asm
PARSEARGS1A:        0E60 DEFINED AT LINE 2109 IN MAIN.asm
                    > USED AT LINE 2106 IN MAIN.asm
PARSEARGS2:         0E68 DEFINED AT LINE 2114 IN MAIN.asm
PARSEARGS3:         0E70 DEFINED AT LINE 2122 IN MAIN.asm
                    > USED AT LINE 2108 IN MAIN.asm
                    > USED AT LINE 2120 IN MAIN.asm
PARSEARGS4:         0E73 DEFINED AT LINE 2125 IN MAIN.asm
                    > USED AT LINE 2111 IN MAIN.asm
                    > USED AT LINE 2113 IN MAIN.asm
PARSEARGS5:         0E79 DEFINED AT LINE 2131 IN MAIN.asm
                    > USED AT LINE 2129 IN MAIN.asm
PARSEBLOCK:         0E84 DEFINED AT LINE 2144 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
                    > USED AT LINE 555 IN MAIN.asm
PARSEBLOCK1:        0E88 DEFINED AT LINE 2148 IN MAIN.asm
                    > USED AT LINE 2152 IN MAIN.asm
                    > USED AT LINE 2160 IN MAIN.asm
                    > USED AT LINE 2166 IN MAIN.asm
                    > USED AT LINE 2180 IN MAIN.asm
                    > USED AT LINE 2183 IN MAIN.asm
                    > USED AT LINE 2186 IN MAIN.asm
PARSEBLOCK2:        0EA1 DEFINED AT LINE 2162 IN MAIN.asm
                    > USED AT LINE 2154 IN MAIN.asm
                    > USED AT LINE 2156 IN MAIN.asm
                    > USED AT LINE 2158 IN MAIN.asm
PARSEBLOCK3:        0EA7 DEFINED AT LINE 2167 IN MAIN.asm
                    > USED AT LINE 2161 IN MAIN.asm
PARSEBLOCK4:        0EC1 DEFINED AT LINE 2181 IN MAIN.asm
                    > USED AT LINE 2169 IN MAIN.asm
                    > USED AT LINE 2171 IN MAIN.asm
                    > USED AT LINE 2173 IN MAIN.asm
PARSEBLOCK5:        0EC4 DEFINED AT LINE 2184 IN MAIN.asm
                    > USED AT LINE 2175 IN MAIN.asm
                    > USED AT LINE 2177 IN MAIN.asm
                    > USED AT LINE 2179 IN MAIN.asm
PARSEBLOCK6:        0EEF DEFINED AT LINE 2205 IN MAIN.asm
                    > USED AT LINE 2192 IN MAIN.asm
CREATEFUNC:         0EF3 DEFINED AT LINE 2213 IN MAIN.asm
                    > USED AT LINE 455 IN MAIN.asm
CREATEFUNC0:        0F12 DEFINED AT LINE 2227 IN MAIN.asm
                    > USED AT LINE 2223 IN MAIN.asm
CREATEFUNC1:        0F2A DEFINED AT LINE 2246 IN MAIN.asm
                    > USED AT LINE 2242 IN MAIN.asm
CREATEFUNC2:        0F3D DEFINED AT LINE 2259 IN MAIN.asm
                    > USED AT LINE 2255 IN MAIN.asm
CREATEFUNC2A:       0F5C DEFINED AT LINE 2285 IN MAIN.asm
                    > USED AT LINE 2272 IN MAIN.asm
CREATEFUNC3:        0F6B DEFINED AT LINE 2297 IN MAIN.asm
                    > USED AT LINE 2307 IN MAIN.asm
CREATEFUNC4:        0F76 DEFINED AT LINE 2308 IN MAIN.asm
CREATEFUNC5:        0F77 DEFINED AT LINE 2310 IN MAIN.asm
                    > USED AT LINE 2226 IN MAIN.asm
VARIABLE:           0F95 DEFINED AT LINE 2337 IN MAIN.asm
                    > USED AT LINE 274 IN MAIN.asm
                    > USED AT LINE 594 IN MAIN.asm
CONSTANT:           0FA4 DEFINED AT LINE 2347 IN MAIN.asm
                    > USED AT LINE 1350 IN MAIN.asm
                    > USED AT LINE 2343 IN MAIN.asm
CHARTABLE:          0FA7 DEFINED AT LINE 2355 IN MAIN.asm
                    > USED AT LINE 780 IN MAIN.asm
CHARTABLE1:         0FB1 DEFINED AT LINE 2362 IN MAIN.asm
                    > USED AT LINE 2376 IN MAIN.asm
CHARTABLE2:         0FBB DEFINED AT LINE 2370 IN MAIN.asm
                    > USED AT LINE 2368 IN MAIN.asm
CHARTABLE3:         0FBD DEFINED AT LINE 2373 IN MAIN.asm
                    > USED AT LINE 2359 IN MAIN.asm
                    > USED AT LINE 2361 IN MAIN.asm
CMDTABLE:           0FC2 DEFINED AT LINE 2383 IN MAIN.asm
                    > USED AT LINE 604 IN MAIN.asm
                    > USED AT LINE 811 IN MAIN.asm
                    > USED AT LINE 828 IN MAIN.asm
                    > USED AT LINE 837 IN MAIN.asm
                    > USED AT LINE 844 IN MAIN.asm
                    > USED AT LINE 853 IN MAIN.asm
                    > USED AT LINE 881 IN MAIN.asm
                    > USED AT LINE 888 IN MAIN.asm
                    > USED AT LINE 895 IN MAIN.asm
                    > USED AT LINE 906 IN MAIN.asm
                    > USED AT LINE 913 IN MAIN.asm
                    > USED AT LINE 943 IN MAIN.asm
                    > USED AT LINE 956 IN MAIN.asm
                    > USED AT LINE 973 IN MAIN.asm
                    > USED AT LINE 980 IN MAIN.asm
                    > USED AT LINE 989 IN MAIN.asm
                    > USED AT LINE 998 IN MAIN.asm
                    > USED AT LINE 1005 IN MAIN.asm
                    > USED AT LINE 1534 IN MAIN.asm
CMDTABLE1:          0FC3 DEFINED AT LINE 2385 IN MAIN.asm
CMDTABLE2:          0FC3 DEFINED AT LINE 2386 IN MAIN.asm
                    > USED AT LINE 2411 IN MAIN.asm
CMDTABLE3:          0FD0 DEFINED AT LINE 2398 IN MAIN.asm
CMDTABLE4:          0FDA DEFINED AT LINE 2407 IN MAIN.asm
                    > USED AT LINE 2397 IN MAIN.asm
CMDTABLE5:          0FDF DEFINED AT LINE 2412 IN MAIN.asm
                    > USED AT LINE 2393 IN MAIN.asm
                    > USED AT LINE 2401 IN MAIN.asm
                    > USED AT LINE 2405 IN MAIN.asm
GETVARADDR:         0FE4 DEFINED AT LINE 2419 IN MAIN.asm
                    > USED AT LINE 1051 IN MAIN.asm
GETVARADDR1:        0FF6 DEFINED AT LINE 2430 IN MAIN.asm
                    > USED AT LINE 2426 IN MAIN.asm
PUTSTR0:            0FFB DEFINED AT LINE 2436 IN MAIN.asm
                    > USED AT LINE 2442 IN MAIN.asm
PUTSTR:             0FFF DEFINED AT LINE 2439 IN MAIN.asm
                    > USED AT LINE 2091 IN MAIN.asm
                    > USED AT LINE 2508 IN MAIN.asm
                    > USED AT LINE 2565 IN MAIN.asm
NESTING:            1004 DEFINED AT LINE 2455 IN MAIN.asm
                    > USED AT LINE 2587 IN MAIN.asm
                    > USED AT LINE 2621 IN MAIN.asm
NESTING0:           1012 DEFINED AT LINE 2463 IN MAIN.asm
                    > USED AT LINE 2457 IN MAIN.asm
                    > USED AT LINE 2459 IN MAIN.asm
                    > USED AT LINE 2461 IN MAIN.asm
NESTING1A:          1019 DEFINED AT LINE 2468 IN MAIN.asm
                    > USED AT LINE 2465 IN MAIN.asm
NESTING1:           101C DEFINED AT LINE 2471 IN MAIN.asm
                    > USED AT LINE 2462 IN MAIN.asm
NESTING2:           102B DEFINED AT LINE 2480 IN MAIN.asm
                    > USED AT LINE 2475 IN MAIN.asm
                    > USED AT LINE 2477 IN MAIN.asm
NESTING3:           102D DEFINED AT LINE 2483 IN MAIN.asm
                    > USED AT LINE 2479 IN MAIN.asm
NESTING4:           1038 DEFINED AT LINE 2490 IN MAIN.asm
                    > USED AT LINE 2485 IN MAIN.asm
                    > USED AT LINE 2487 IN MAIN.asm
PROMPT:             103A DEFINED AT LINE 2494 IN MAIN.asm
                    > USED AT LINE 2569 IN MAIN.asm
CRLF:               1043 DEFINED AT LINE 2499 IN MAIN.asm
                    > USED AT LINE 2634 IN MAIN.asm
PRINTSTR:           104A DEFINED AT LINE 2506 IN MAIN.asm
                    > USED AT LINE 2495 IN MAIN.asm
                    > USED AT LINE 2500 IN MAIN.asm
                    > USED AT LINE 2694 IN MAIN.asm
                    > USED AT LINE 2699 IN MAIN.asm
INIT:               1051 DEFINED AT LINE 2513 IN MAIN.asm
                    > USED AT LINE 2562 IN MAIN.asm
INIT1:              1059 DEFINED AT LINE 2517 IN MAIN.asm
                    > USED AT LINE 2523 IN MAIN.asm
WARMINIT:           1061 DEFINED AT LINE 2525 IN MAIN.asm
COLDBOOT0:          1074 DEFINED AT LINE 2532 IN MAIN.asm
                    > USED AT LINE 2520 IN MAIN.asm
                    > USED AT LINE 2558 IN MAIN.asm
COLDINIT:           107E DEFINED AT LINE 2538 IN MAIN.asm
COLDBOOT1:          108F DEFINED AT LINE 2547 IN MAIN.asm
                    > USED AT LINE 2550 IN MAIN.asm
COLDSTART:          109C DEFINED AT LINE 2556 IN MAIN.asm
                    > USED AT LINE 830 IN MAIN.asm
START:              10A5 DEFINED AT LINE 2560 IN MAIN.asm
                    > USED AT LINE 7
START1:             10AB DEFINED AT LINE 2563 IN MAIN.asm
                    > USED AT LINE 2530 IN MAIN.asm
                    > USED AT LINE 2559 IN MAIN.asm
INTERPRET:          10B1 DEFINED AT LINE 2567 IN MAIN.asm
                    > USED AT LINE 2671 IN MAIN.asm
                    > USED AT LINE 2687 IN MAIN.asm
INTERPRET2:         10BD DEFINED AT LINE 2575 IN MAIN.asm
                    > USED AT LINE 2612 IN MAIN.asm
                    > USED AT LINE 2692 IN MAIN.asm
                    > USED AT LINE 2696 IN MAIN.asm
                    > USED AT LINE 2714 IN MAIN.asm
INTERPRET3:         10C5 DEFINED AT LINE 2583 IN MAIN.asm
                    > USED AT LINE 2593 IN MAIN.asm
INTERPRET4:         10CB DEFINED AT LINE 2589 IN MAIN.asm
                    > USED AT LINE 2581 IN MAIN.asm
INTERPRET5:         10D0 DEFINED AT LINE 2596 IN MAIN.asm
                    > USED AT LINE 2622 IN MAIN.asm
                    > USED AT LINE 2637 IN MAIN.asm
INTERPRET5A:        10E9 DEFINED AT LINE 2611 IN MAIN.asm
INTERPRET6:         10EB DEFINED AT LINE 2614 IN MAIN.asm
                    > USED AT LINE 2600 IN MAIN.asm
INTERPRET7:         10F9 DEFINED AT LINE 2624 IN MAIN.asm
                    > USED AT LINE 2604 IN MAIN.asm
INTERPRET8:         110C DEFINED AT LINE 2639 IN MAIN.asm
                    > USED AT LINE 2602 IN MAIN.asm
NEXT:               1127 DEFINED AT LINE 2652 IN MAIN.asm
                    > USED AT LINE 2552 IN MAIN.asm
                    > USED AT LINE 2656 IN MAIN.asm
NEXT0:              113B DEFINED AT LINE 2666 IN MAIN.asm
                    > USED AT LINE 2664 IN MAIN.asm
NEXT1:              113C DEFINED AT LINE 2668 IN MAIN.asm
                    > USED AT LINE 2657 IN MAIN.asm
EXIT:               1143 DEFINED AT LINE 2673 IN MAIN.asm
                    > USED AT LINE 2670 IN MAIN.asm
RUN:                1147 DEFINED AT LINE 2678 IN MAIN.asm
                    > USED AT LINE 2685 IN MAIN.asm
ERROR:              114B DEFINED AT LINE 2683 IN MAIN.asm
                    > USED AT LINE 452 IN MAIN.asm
                    > USED AT LINE 1136 IN MAIN.asm
BACKSPACE_:         115D DEFINED AT LINE 2689 IN MAIN.asm
                    > USED AT LINE 2607 IN MAIN.asm
REEDIT_:            116D DEFINED AT LINE 2698 IN MAIN.asm
                    > USED AT LINE 2609 IN MAIN.asm
REEDIT0:            1179 DEFINED AT LINE 2703 IN MAIN.asm
                    > USED AT LINE 2709 IN MAIN.asm
REEDIT1:            117D DEFINED AT LINE 2706 IN MAIN.asm
                    > USED AT LINE 2702 IN MAIN.asm
F1:                 118D DEFINED AT LINE 10
                    > USED AT LINE 870 IN MAIN.asm
F2:                 118D DEFINED AT LINE 11
                    > USED AT LINE 872 IN MAIN.asm
F3:                 118D DEFINED AT LINE 12
                    > USED AT LINE 874 IN MAIN.asm
F4:                 118D DEFINED AT LINE 13
                    > USED AT LINE 876 IN MAIN.asm
STKSIZE:            0100 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 6 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
BUFSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
STACK:              2100 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 6
                    > USED AT LINE 1822 IN MAIN.asm
                    > USED AT LINE 2553 IN MAIN.asm
                    > USED AT LINE 2557 IN MAIN.asm
                    > USED AT LINE 2561 IN MAIN.asm
TIB:                2100 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 2572 IN MAIN.asm
                    > USED AT LINE 2580 IN MAIN.asm
                    > USED AT LINE 2616 IN MAIN.asm
                    > USED AT LINE 2626 IN MAIN.asm
                    > USED AT LINE 2641 IN MAIN.asm
                    > USED AT LINE 2644 IN MAIN.asm
                    > USED AT LINE 2701 IN MAIN.asm
                    > USED AT LINE 2710 IN MAIN.asm
BUFFER:             2200 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 1286 IN MAIN.asm
                    > USED AT LINE 1297 IN MAIN.asm
                    > USED AT LINE 2086 IN MAIN.asm
VARS:               2300 DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 982 IN MAIN.asm
                    > USED AT LINE 1349 IN MAIN.asm
                    > USED AT LINE 2544 IN MAIN.asm
RESTARTS:           23D0 DEFINED AT LINE 18 IN ram.asm
RST08:              23D0 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
RST10:              23D2 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 114 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
RST18:              23D4 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 121 IN IOSerial.asm
                    > USED AT LINE 455 IN IOSerial.asm
RST20:              23D6 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RST28:              23D8 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
RST30:              23DA DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
BAUD:               23DC DEFINED AT LINE 26 IN ram.asm
INTVEC:             23DE DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 149 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
NMIVEC:             23E0 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 197 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
GETCVEC:            23E2 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 441 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
PUTCVEC:            23E4 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
SYSVARS:            23E6 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 2540 IN MAIN.asm
VTIBPTR:            23E6 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 2573 IN MAIN.asm
                    > USED AT LINE 2643 IN MAIN.asm
VBUFPTR:            23E8 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 540 IN MAIN.asm
                    > USED AT LINE 550 IN MAIN.asm
                    > USED AT LINE 619 IN MAIN.asm
                    > USED AT LINE 622 IN MAIN.asm
                    > USED AT LINE 629 IN MAIN.asm
                    > USED AT LINE 639 IN MAIN.asm
                    > USED AT LINE 653 IN MAIN.asm
                    > USED AT LINE 666 IN MAIN.asm
                    > USED AT LINE 728 IN MAIN.asm
                    > USED AT LINE 747 IN MAIN.asm
                    > USED AT LINE 1281 IN MAIN.asm
                    > USED AT LINE 1298 IN MAIN.asm
                    > USED AT LINE 2087 IN MAIN.asm
                    > USED AT LINE 2089 IN MAIN.asm
VHEAPPTR:           23EA DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 473 IN MAIN.asm
                    > USED AT LINE 507 IN MAIN.asm
                    > USED AT LINE 511 IN MAIN.asm
                    > USED AT LINE 1160 IN MAIN.asm
                    > USED AT LINE 1290 IN MAIN.asm
                    > USED AT LINE 1294 IN MAIN.asm
                    > USED AT LINE 1550 IN MAIN.asm
                    > USED AT LINE 1567 IN MAIN.asm
                    > USED AT LINE 1575 IN MAIN.asm
                    > USED AT LINE 1654 IN MAIN.asm
                    > USED AT LINE 1673 IN MAIN.asm
                    > USED AT LINE 2098 IN MAIN.asm
                    > USED AT LINE 2133 IN MAIN.asm
                    > USED AT LINE 2200 IN MAIN.asm
                    > USED AT LINE 2203 IN MAIN.asm
                    > USED AT LINE 2225 IN MAIN.asm
                    > USED AT LINE 2230 IN MAIN.asm
                    > USED AT LINE 2261 IN MAIN.asm
                    > USED AT LINE 2327 IN MAIN.asm
VRECURPTR:          23EC DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 1223 IN MAIN.asm
                    > USED AT LINE 1810 IN MAIN.asm
                    > USED AT LINE 1817 IN MAIN.asm
VDATAWIDTH:         23EE DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 267 IN MAIN.asm
                    > USED AT LINE 484 IN MAIN.asm
                    > USED AT LINE 656 IN MAIN.asm
                    > USED AT LINE 736 IN MAIN.asm
                    > USED AT LINE 1074 IN MAIN.asm
                    > USED AT LINE 1105 IN MAIN.asm
                    > USED AT LINE 1930 IN MAIN.asm
                    > USED AT LINE 1992 IN MAIN.asm
                    > USED AT LINE 2340 IN MAIN.asm
VNUMBASE:           23EF DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 645 IN MAIN.asm
                    > USED AT LINE 1120 IN MAIN.asm
VHEXPREFIX:         23F0 DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 729 IN MAIN.asm
VECHO:              23F1 DEFINED AT LINE 43 IN ram.asm
                    > USED AT LINE 1127 IN MAIN.asm
                    > USED AT LINE 1558 IN MAIN.asm
VSTRMODE:           23F2 DEFINED AT LINE 44 IN ram.asm
                    > USED AT LINE 1274 IN MAIN.asm
                    > USED AT LINE 1280 IN MAIN.asm
                    > USED AT LINE 2081 IN MAIN.asm
VPOINTER:           23F8 DEFINED AT LINE 53 IN ram.asm
                    > USED AT LINE 414 IN MAIN.asm
                    > USED AT LINE 592 IN MAIN.asm
                    > USED AT LINE 593 IN MAIN.asm
                    > USED AT LINE 1713 IN MAIN.asm
                    > USED AT LINE 1927 IN MAIN.asm
                    > USED AT LINE 2338 IN MAIN.asm
VREMAIN:            23FA DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 1025 IN MAIN.asm
                    > USED AT LINE 1227 IN MAIN.asm
VSAVEDIP:           23FC DEFINED AT LINE 56 IN ram.asm
                    > USED AT LINE 2526 IN MAIN.asm
                    > USED AT LINE 2646 IN MAIN.asm
VSAVEDSP:           23FE DEFINED AT LINE 57 IN ram.asm
                    > USED AT LINE 2527 IN MAIN.asm
                    > USED AT LINE 2647 IN MAIN.asm
VSAVEDNEXT:         2400 DEFINED AT LINE 58 IN ram.asm
                    > USED AT LINE 2528 IN MAIN.asm
                    > USED AT LINE 2648 IN MAIN.asm
VSAVEDBP:           2402 DEFINED AT LINE 59 IN ram.asm
                    > USED AT LINE 2529 IN MAIN.asm
                    > USED AT LINE 2649 IN MAIN.asm
VTEMP1:             2404 DEFINED AT LINE 63 IN ram.asm
                    > USED AT LINE 466 IN MAIN.asm
                    > USED AT LINE 512 IN MAIN.asm
                    > USED AT LINE 1285 IN MAIN.asm
                    > USED AT LINE 1295 IN MAIN.asm
                    > USED AT LINE 1765 IN MAIN.asm
                    > USED AT LINE 1809 IN MAIN.asm
                    > USED AT LINE 1821 IN MAIN.asm
                    > USED AT LINE 1827 IN MAIN.asm
                    > USED AT LINE 1856 IN MAIN.asm
                    > USED AT LINE 1877 IN MAIN.asm
                    > USED AT LINE 1884 IN MAIN.asm
                    > USED AT LINE 1890 IN MAIN.asm
                    > USED AT LINE 1981 IN MAIN.asm
                    > USED AT LINE 2005 IN MAIN.asm
                    > USED AT LINE 2021 IN MAIN.asm
                    > USED AT LINE 2029 IN MAIN.asm
                    > USED AT LINE 2045 IN MAIN.asm
                    > USED AT LINE 2054 IN MAIN.asm
                    > USED AT LINE 2195 IN MAIN.asm
                    > USED AT LINE 2204 IN MAIN.asm
                    > USED AT LINE 2216 IN MAIN.asm
                    > USED AT LINE 2328 IN MAIN.asm
VTEMP2:             2406 DEFINED AT LINE 64 IN ram.asm
                    > USED AT LINE 1768 IN MAIN.asm
                    > USED AT LINE 1808 IN MAIN.asm
                    > USED AT LINE 1857 IN MAIN.asm
                    > USED AT LINE 1878 IN MAIN.asm
                    > USED AT LINE 2218 IN MAIN.asm
                    > USED AT LINE 2318 IN MAIN.asm
VTEMP3:             2408 DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 2215 IN MAIN.asm
                    > USED AT LINE 2329 IN MAIN.asm
TBPTR:              240C DEFINED AT LINE 67 IN ram.asm
TITLEBUF:           240E DEFINED AT LINE 69 IN ram.asm
                    > USED AT LINE 2515 IN MAIN.asm
                    > USED AT LINE 2534 IN MAIN.asm
                    > USED AT LINE 2564 IN MAIN.asm
HEAP:               2422 DEFINED AT LINE 71 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 2188 IN MAIN.asm
