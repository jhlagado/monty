0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $2000   ; TODO: set this to TEC 1G
0000                ROMSIZE:   EQU   $2000   
0000                RAMSIZE:   EQU   $2000   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   hl   
0009   2A D0 23               LD   hl,(RST08)   
000C   E3                     EX   (sp),hl   
000D   C9                     RET      
000E                             ; 
000E                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   hl   
0011   2A D2 23               LD   hl,(RST10)   
0014   E3                     EX   (sp),hl   
0015   C9                     RET      
0016                             ; 
0016                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   hl   
0019   2A D4 23               LD   hl,(RST18)   
001C   E3                     EX   (sp),hl   
001D   C9                     RET      
001E                             ; 
001E                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   hl   
0021   2A D6 23               LD   hl,(RST20)   
0024   E3                     EX   (sp),hl   
0025   C9                     RET      
0026                             ; 
0026                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   hl   
0029   2A D8 23               LD   hl,(RST28)   
002C   E3                     EX   (sp),hl   
002D   C9                     RET      
002E                             ; 
002E                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   hl   
0031   2A DA 23               LD   hl,(RST30)   
0034   E3                     EX   (sp),hl   
0035   ED 4D                  RETI      
0037                             ; 
0037                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   hl   
0039   2A DE 23               LD   hl,(INTVEC)   
003C   E3                     EX   (sp),hl   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A E0 23               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A E2 23               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A E4 23               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 21               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 D0 23               LD   (RST08),HL   
0094   22 D2 23               LD   (RST10),HL   
0097   22 D4 23               LD   (RST18),HL   
009A   22 D6 23               LD   (RST20),HL   
009D   22 D8 23               LD   (RST28),HL   
00A0   22 DA 23               LD   (RST30),HL   
00A3   22 DE 23               LD   (INTVEC),HL   
00A6   22 E0 23               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 E2 23               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 E4 23               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   31 00 21               LD   sp,STACK   ; start Monty
00C6   C3 C9 0E               JP   start   
00C9                             ; 
00C9                             ; *************************************************************************
00C9                             ; 
00C9                             ;  Monty programming language for the Z80
00C9                             ; 
00C9                             ;  by John Hardy 2023
00C9                             ; 
00C9                             ;  GNU GENERAL PUBLIC LICENSE    Version 3, 29 June 2007
00C9                             ; 
00C9                             ;  see the LICENSE file in this repo for more information
00C9                             ; 
00C9                             ;  Incorporating code from the MINT project by Ken Boak and Craig Jones.
00C9                             ;  Inspiration from Charles H. Moore, Peter Jakacki and Andr√© Staltz
00C9                             ; 
00C9                             ; *****************************************************************************
00C9                TRUE:     EQU   -1   ; C-style true
00C9                FALSE:    EQU   0   
00C9                NUL:      EQU   0   ; exit code
00C9                DQ:       EQU   $22   ; " double quote char
00C9                CTRL_C:   EQU   3   
00C9                CTRL_E:   EQU   5   
00C9                CTRL_H:   EQU   8   
00C9                CTRL_J:   EQU   10   
00C9                CTRL_L:   EQU   12   
00C9                CTRL_P:   EQU   16   
00C9                CTRL_S:   EQU   19   
00C9                ESC:      EQU   27   
00C9                             ; macros for inlining a onty function in assembly
00C9                             ; follow immediately with a null terminated block of Monty code
00C9                .macro FUNC,name,numLocals,argsStr
00C9                             ; 
00C9                name:
00C9                 call go
00C9                 dw NUL                      ; NUL closure
00C9                 dw name%%M
00C9                 dw $+2
00C9                 db numLocals                ; num_locals
00C9                 .pstr argsStr
00C9                name%%M:
00C9                .endm
00C9                 
00C9                .macro PERFORM,name
00C9                             ; 
00C9                 ld ix,perform%%M
00C9                 jp name
00C9                perform%%M:
00C9                .endm
00C9                 
0180                          .ORG   ROMSTART + $180   ; 0+180 put monty code from here	
0180                             ;********************** PAGE 1 BEGIN *********************************************
0180                OPCODES:      
0180   3E                     DB   lsb(bang_)   ; !
0181   F3                     DB   lsb(dquote_)   ; "
0182   EA                     DB   lsb(hash_)   ; #
0183   C0                     DB   lsb(dollar_)   ; $
0184   C9                     DB   lsb(percent_)   ; %
0185   20                     DB   lsb(amper_)   ; &
0186   D2                     DB   lsb(tick_)   ; '
0187   CC                     DB   lsb(lparen_)   ; (
0188   BD                     DB   lsb(rparen_)   ; )
0189   E7                     DB   lsb(star_)   ; *
018A   04                     DB   lsb(plus_)   ; +
018B   F0                     DB   lsb(comma_)   ; ,
018C   4E                     DB   lsb(minus_)   ; -
018D   D8                     DB   lsb(dot_)   ; .
018E   FF                     DB   lsb(slash_)   ; /	
018F   6B                     DB   lsb(num_)   ; 0
0190   6B                     DB   lsb(num_)   ; 1
0191   6B                     DB   lsb(num_)   ; 2
0192   6B                     DB   lsb(num_)   ; 3
0193   6B                     DB   lsb(num_)   ; 4
0194   6B                     DB   lsb(num_)   ; 5
0195   6B                     DB   lsb(num_)   ; 6
0196   6B                     DB   lsb(num_)   ; 7
0197   6B                     DB   lsb(num_)   ; 8
0198   6B                     DB   lsb(num_)   ; 9
0199   DB                     DB   lsb(colon_)   ; :
019A   D5                     DB   lsb(semicolon_)   ; ;
019B   86                     DB   lsb(lt_)   ; <
019C   6E                     DB   lsb(eq_)   ; =
019D   7B                     DB   lsb(gt_)   ; >
019E   E4                     DB   lsb(question_)   ; ?
019F   34                     DB   lsb(at_)   ; @
01A0   DE                     DB   lsb(upcase_)   ; A
01A1   DE                     DB   lsb(upcase_)   ; B
01A2   DE                     DB   lsb(upcase_)   ; C
01A3   DE                     DB   lsb(upcase_)   ; D
01A4   DE                     DB   lsb(upcase_)   ; E
01A5   DE                     DB   lsb(upcase_)   ; F
01A6   DE                     DB   lsb(upcase_)   ; G
01A7   DE                     DB   lsb(upcase_)   ; h
01A8   DE                     DB   lsb(upcase_)   ; I
01A9   DE                     DB   lsb(upcase_)   ; J
01AA   DE                     DB   lsb(upcase_)   ; K
01AB   DE                     DB   lsb(upcase_)   ; L
01AC   DE                     DB   lsb(upcase_)   ; M
01AD   DE                     DB   lsb(upcase_)   ; N
01AE   DE                     DB   lsb(upcase_)   ; O
01AF   DE                     DB   lsb(upcase_)   ; p
01B0   DE                     DB   lsb(upcase_)   ; Q
01B1   DE                     DB   lsb(upcase_)   ; R
01B2   DE                     DB   lsb(upcase_)   ; S
01B3   DE                     DB   lsb(upcase_)   ; T
01B4   DE                     DB   lsb(upcase_)   ; U
01B5   DE                     DB   lsb(upcase_)   ; V
01B6   DE                     DB   lsb(upcase_)   ; W
01B7   DE                     DB   lsb(upcase_)   ; X
01B8   DE                     DB   lsb(upcase_)   ; Y
01B9   DE                     DB   lsb(upcase_)   ; Z
01BA   C3                     DB   lsb(lbrack_)   ; [
01BB   F6                     DB   lsb(backslash_)   ; \
01BC   C6                     DB   lsb(rbrack_)   ; ]
01BD   ED                     DB   lsb(caret_)   ; ^
01BE   F9                     DB   lsb(underscore_)   ; _
01BF   F3                     DB   lsb(dquote_)   ; `     used for testing string   	
01C0   E1                     DB   lsb(lowcase_)   ; a
01C1   E1                     DB   lsb(lowcase_)   ; b
01C2   E1                     DB   lsb(lowcase_)   ; c
01C3   E1                     DB   lsb(lowcase_)   ; d
01C4   E1                     DB   lsb(lowcase_)   ; e
01C5   E1                     DB   lsb(lowcase_)   ; f
01C6   E1                     DB   lsb(lowcase_)   ; g
01C7   E1                     DB   lsb(lowcase_)   ; h
01C8   E1                     DB   lsb(lowcase_)   ; i
01C9   E1                     DB   lsb(lowcase_)   ; j
01CA   E1                     DB   lsb(lowcase_)   ; k
01CB   E1                     DB   lsb(lowcase_)   ; l
01CC   E1                     DB   lsb(lowcase_)   ; m
01CD   E1                     DB   lsb(lowcase_)   ; n
01CE   E1                     DB   lsb(lowcase_)   ; o
01CF   E1                     DB   lsb(lowcase_)   ; p
01D0   E1                     DB   lsb(lowcase_)   ; q
01D1   E1                     DB   lsb(lowcase_)   ; r
01D2   E1                     DB   lsb(lowcase_)   ; s
01D3   E1                     DB   lsb(lowcase_)   ; t
01D4   E1                     DB   lsb(lowcase_)   ; u
01D5   E1                     DB   lsb(lowcase_)   ; v
01D6   E1                     DB   lsb(lowcase_)   ; w
01D7   E1                     DB   lsb(lowcase_)   ; x
01D8   E1                     DB   lsb(lowcase_)   ; y
01D9   E1                     DB   lsb(lowcase_)   ; z
01DA   CC                     DB   lsb(lbrace_)   ; {
01DB   2B                     DB   lsb(pipe_)   ; |
01DC   CF                     DB   lsb(rbrace_)   ; }
01DD   FC                     DB   lsb(tilde_)   ; ~
01DE                             ;********************** PAGE 1 END *********************************************
01DE                             ; ***********************************************************************
01DE                             ; Initial values for system vars		
01DE                             ; ***********************************************************************		
01DE                ISYSVARS:      
01DE   02 00                  DW   2   ; vDataWidth in bytes of array operations (default 1 byte)
01E0   0A 00                  DW   10   ; vNumBase = 10
01E2   00 21                  DW   TIB   ; vTIBPtr pointer into TIB
01E4   00 22                  DW   BUF   ; vBUFPtr pointer into BUF
01E6   58 0F                  DW   next   ; nNext
01E8   20 24                  DW   HEAP   ; vHeapPtr \h start of the free mem
01EA   00 00                  DW   0   ; vRecur
01EC   00 00                  DW   0   ; vDefine
01EE   00 00                  DW   0   ; unused
01F0                             ; **********************************************************************			
01F0                             ; title string (also used by warm boot)
01F0                             ; **********************************************************************
01F0                TITLESTR:      
01F0   1B 5B 32 4A 4D 6F 6E 74 79 20 56 30 2E 31 0D 0A 00 00 00 00 .CSTR   ESC,"[2JMonty V0.1\r\n",0,0,0   
0204                             ;********************** PAGE 2 BEGIN *********************************************
0204                PLUS_:       ; add the top 2 members of the stack
0204                ADD:         
0204   03                     INC   bc   
0205   0A                     LD   a,(bc)   
0206   FE 2B                  CP   "+"   ; ++ increment variable
0208   20 05                  JR   nz,add1   
020A   E1                     POP   hl   
020B   23                     INC   hl   
020C   C3 75 09               JP   assign0   
020F                ADD1:        
020F   0B                     DEC   bc   
0210   D1                     POP   de   ; second term
0211   E1                     POP   hl   ; first term
0212   19                     ADD   hl,de   
0213                ADD3:        
0213   03                     INC   bc   
0214   0A                     LD   a,(bc)   
0215   FE 3D                  CP   "="   
0217   28 04                  JR   z,add4   
0219   0B                     DEC   bc   
021A   E5                     PUSH   hl   
021B   DD E9                  JP   (ix)   
021D                ADD4:        
021D   C3 75 09               JP   assign0   
0220                AMPER_:      
0220                AND:         
0220   D1                     POP   de   ; Bitwise and the top 2 elements of the stack
0221   E1                     POP   hl   
0222   7B                     LD   a,e   
0223   A5                     AND   l   
0224   6F                     LD   l,a   
0225   7A                     LD   a,d   
0226   A4                     AND   h   
0227                AND1:        
0227   67                     LD   h,a   
0228   E5                     PUSH   hl   
0229   DD E9                  JP   (ix)   
022B                PIPE_:       
022B                OR:          
022B   D1                     POP   de   ; Bitwise or the top 2 elements of the stack
022C   E1                     POP   hl   
022D   7B                     LD   a,e   
022E   B5                     OR   l   
022F   6F                     LD   l,a   
0230   7A                     LD   a,d   
0231   B4                     OR   h   
0232   18 F3                  JR   and1   
0234                             ; @ addr
0234                             ; -- ptr
0234                AT_:         
0234                ADDR:        
0234   ED 5B F6 23            LD   de,(vPointer)   
0238   21 F6 23               LD   hl,vPointer   
023B   C3 AF 04               JP   variable   
023E                BANG_:       ; logical invert, any non zero value
023E   03                     INC   bc   
023F   0A                     LD   a,(bc)   
0240   FE 3D                  CP   "="   
0242   20 04                  JR   nz,not   
0244   E1                     POP   hl   
0245   D1                     POP   de   
0246   18 55                  JR   notequals   
0248                NOT:         
0248   0B                     DEC   bc   
0249   21 00 00               LD   hl,0   ; is considered true
024C   18 2A                  JR   eq1   
024E                MINUS_:      
024E   03                     INC   bc   ; check if sign of a number
024F   0A                     LD   a,(bc)   
0250   0B                     DEC   bc   
0251   FE 30                  CP   "0"   
0253   38 04                  JR   c,sub   
0255   FE 3A                  CP   "9"+1   
0257   38 12                  JR   c,num_   
0259                SUB:         ; Subtract the value 2nd on stack from top of stack
0259   03                     INC   bc   
025A   FE 2D                  CP   "-"   
025C   20 05                  JR   nz,sub1   
025E   E1                     POP   hl   
025F   2B                     DEC   hl   
0260   C3 75 09               JP   assign0   
0263                SUB1:        
0263   0B                     DEC   bc   
0264   D1                     POP   de   
0265   E1                     POP   hl   
0266   B7                     OR   a   
0267   ED 52                  SBC   hl,de   
0269   18 A8                  JR   add3   
026B                NUM_:        
026B   C3 14 0C               JP   num   
026E                EQ_:         
026E   CD 0F 0E               CALL   jumpTable   
0271   3D                     DB   "="   
0272   77                     DB   lsb(eq0_)   
0273   00                     DB   NUL   
0274   C3 73 09               JP   assign   
0277                EQ0_:        
0277   E1                     POP   hl   
0278                EQ1:         
0278   D1                     POP   de   
0279   18 1B                  JR   equals   
027B                GT_:         
027B   03                     INC   bc   
027C   0A                     LD   a,(bc)   
027D   FE 3E                  CP   ">"   
027F   CA 5C 0C               JP   z,shiftRight   
0282   D1                     POP   de   
0283   E1                     POP   hl   
0284   18 09                  JR   lt1   
0286                LT_:         
0286   03                     INC   bc   
0287   0A                     LD   a,(bc)   
0288   FE 3C                  CP   "<"   
028A   CA 4C 0C               JP   z,shiftLeft   
028D   E1                     POP   hl   
028E   D1                     POP   de   
028F                LT1:         
028F   FE 3D                  CP   "="   
0291   28 11                  JR   z,lessthaneq   
0293   0B                     DEC   bc   
0294   18 13                  JR   lessthan   
0296                             ; hl = value1, de = value2
0296                             ; hl = result
0296                EQUALS:      
0296   B7                     OR   a   ; reset the carry flag
0297   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
0299   28 16                  JR   z,true1   
029B   18 1A                  JR   false1   
029D                NOTEQUALS:      
029D   B7                     OR   a   ; reset the carry flag
029E   ED 52                  SBC   hl,de   
02A0   20 0F                  JR   nz,true1   
02A2   18 13                  JR   false1   
02A4                             ; hl = value1 de = value2
02A4                             ; hl = result
02A4                LESSTHANEQ:      
02A4   B7                     OR   a   
02A5   ED 52                  SBC   hl,de   
02A7   18 05                  JR   lessthan1   
02A9                             ; hl = value1 de = value2
02A9                             ; hl = result
02A9                LESSTHAN:      
02A9   B7                     OR   a   
02AA   ED 52                  SBC   hl,de   
02AC   28 09                  JR   z,false1   
02AE                LESSTHAN1:      
02AE   FA B7 02               JP   m,false1   
02B1                TRUE1:       
02B1   21 FF FF               LD   hl,TRUE   
02B4   E5                     PUSH   hl   
02B5   DD E9                  JP   (ix)   
02B7                NULL1:       
02B7                FALSE1:      
02B7   21 00 00               LD   hl,FALSE   
02BA   E5                     PUSH   hl   
02BB                NOP_:        
02BB   DD E9                  JP   (ix)   
02BD                RPAREN_:      
02BD   C3 44 0C               JP   rparen   
02C0                DOLLAR_:      
02C0   C3 99 0B               JP   dollar   
02C3                LBRACK_:      
02C3   C3 EF 08               JP   lbrack   
02C6                RBRACK_:      
02C6   C3 0B 09               JP   rbrack   
02C9                PERCENT_:      
02C9   C3 BA 08               JP   percent   
02CC                LPAREN_:      
02CC                LBRACE_:      
02CC   C3 84 09               JP   lbrace   
02CF                RBRACE_:      
02CF   C3 89 09               JP   rbrace   
02D2                TICK_:       
02D2   C3 10 0A               JP   tick   
02D5                SEMICOLON_:      
02D5   C3 85 08               JP   semicolon   
02D8                DOT_:        
02D8   C3 B5 04               JP   dot   
02DB                COLON_:      
02DB   C3 4E 08               JP   colon   
02DE                UPCASE_:      
02DE   C3 B6 0B               JP   upcase   
02E1                LOWCASE_:      
02E1   C3 BB 0B               JP   lowcase   
02E4                QUESTION_:      
02E4   C3 CD 0B               JP   question   
02E7                STAR_:       
02E7   C3 F8 0B               JP   star   
02EA                HASH_:       
02EA   C3 5B 09               JP   hash   
02ED                CARET_:      
02ED   C3 FA 0A               JP   caret   
02F0                COMMA_:      
02F0   C3 4C 08               JP   comma   
02F3                DQUOTE_:      
02F3   C3 6F 0C               JP   dquote   
02F6                BACKSLASH_:      
02F6   C3 5B 08               JP   backslash   
02F9                UNDERSCORE_:      
02F9   C3 4C 08               JP   underscore   
02FC                TILDE_:      
02FC   C3 4C 08               JP   tilde   
02FF                SLASH_:      
02FF   18 00                  JR   slash   
0301                             ;********************** PAGE 2 END *********************************************
0301                             ;********************** PAGE 3 BEGIN *********************************************
0301                SLASH:       
0301                COMMAND:      
0301   03                     INC   bc   
0302   0A                     LD   a,(bc)   
0303   FE 2F                  CP   "/"   ; // comment
0305   CA E6 03               JP   z,comment   
0308   0B                     DEC   bc   
0309   CD FB 0D               CALL   commandTable   
030C   27                     DB   lsb(command_a_)   
030D   36                     DB   lsb(command_b_)   
030E   68                     DB   lsb(command_nop_)   
030F   6A                     DB   lsb(decimal_)   
0310   68                     DB   lsb(command_nop_)   
0311   E4                     DB   lsb(command_f_)   
0312   68                     DB   lsb(command_nop_)   
0313   7C                     DB   lsb(hexadecimal_)   
0314   41                     DB   lsb(command_i_)   
0315   68                     DB   lsb(command_nop_)   
0316   82                     DB   lsb(key_)   
0317   68                     DB   lsb(command_nop_)   
0318   4A                     DB   lsb(command_m_)   
0319   68                     DB   lsb(command_nop_)   
031A   85                     DB   lsb(output_)   
031B   4D                     DB   lsb(command_p_)   
031C   56                     DB   lsb(command_q_)   
031D   5F                     DB   lsb(command_r_)   
031E   62                     DB   lsb(command_s_)   
031F   88                     DB   lsb(true_)   
0320   68                     DB   lsb(command_nop_)   
0321   65                     DB   lsb(command_v_)   
0322   8B                     DB   lsb(words_)   
0323   8E                     DB   lsb(xor_)   
0324   68                     DB   lsb(command_nop_)   
0325   68                     DB   lsb(command_nop_)   
0326   72                     DB   lsb(div_)   
0327                COMMAND_A_:      
0327   CD 0F 0E               CALL   jumpTable   
032A   62                     DB   "b"   ; /ab absolute
032B   99                     DB   lsb(absolute_)   
032C   64                     DB   "d"   ; /ad address of
032D   A6                     DB   lsb(addrOf_)   
032E   69                     DB   "i"   ; /ad address of
032F   A9                     DB   lsb(arrayIter_)   
0330   73                     DB   "s"   ; /as array size
0331   AC                     DB   lsb(arraySize_)   
0332   00                     DB   NUL   
0333   C3 76 03               JP   error1_   
0336                COMMAND_B_:      
0336   CD 0F 0E               CALL   jumpTable   
0339   72                     DB   "r"   ; /br break
033A   B4                     DB   lsb(break_)   
033B   79                     DB   "y"   ; /by cold boot
033C   B7                     DB   lsb(coldStart_)   
033D   00                     DB   NUL   
033E   C3 BA 03               JP   bytes_   ; /b bytes
0341                COMMAND_I_:      
0341   CD 0F 0E               CALL   jumpTable   
0344   6E                     DB   "n"   ; /in input
0345   C2                     DB   lsb(input_)   
0346   00                     DB   NUL   
0347   C3 76 03               JP   error1_   
034A                COMMAND_M_:      
034A   C3 3E 04               JP   command_m   
034D                COMMAND_P_:      
034D   CD 0F 0E               CALL   jumpTable   
0350   63                     DB   "c"   ; /pc print chars
0351   CD                     DB   lsb(printChars_)   
0352   00                     DB   NUL   
0353   C3 76 03               JP   error1_   
0356                COMMAND_Q_:      
0356   CD 0F 0E               CALL   jumpTable   
0359   74                     DB   "t"   ; /qt quit
035A   D4                     DB   lsb(quit_)   
035B   00                     DB   NUL   
035C   C3 76 03               JP   error1_   
035F                COMMAND_R_:      
035F   C3 4A 04               JP   command_r   
0362                COMMAND_S_:      
0362   C3 63 04               JP   command_s   
0365                COMMAND_V_:      
0365   C3 72 04               JP   command_v   
0368                COMMAND_NOP_:      
0368   DD E9                  JP   (ix)   
036A                DECIMAL_:      
036A   21 0A 00               LD   hl,10   
036D                DECIMAL1:      
036D   22 E8 23               LD   (vNumBase),hl   
0370   DD E9                  JP   (ix)   
0372                DIV_:        
0372   00                     DB   NUL   
0373   C3 25 0A               JP   div   
0376                ERROR1_:      
0376   21 01 00               LD   hl,1   ; error 1: unknown command
0379   C3 77 0F               JP   error   
037C                HEXADECIMAL_:      
037C   21 10 00               LD   hl,16   
037F   C3 6D 03               JP   decimal1   
0382                KEY_:        
0382   C3 82 03               JP   key_   
0385                OUTPUT_:      
0385   C3 EF 0B               JP   output   
0388                TRUE_:       
0388   C3 B1 02               JP   true1   
038B                WORDS_:      
038B   C3 DE 03               JP   words   
038E                XOR_:        
038E   D1                     POP   de   ; Bitwise xor the top 2 elements of the stack
038F                XOR1:        
038F   E1                     POP   hl   
0390   7B                     LD   a,e   
0391   AD                     XOR   l   
0392   6F                     LD   l,a   
0393   7A                     LD   a,d   
0394   AC                     XOR   h   
0395   67                     LD   h,a   
0396   E5                     PUSH   hl   
0397   DD E9                  JP   (ix)   
0399                             ; /ab absolute
0399                             ; num -- num
0399                ABSOLUTE_:      
0399   E1                     POP   hl   
039A   CB 7C                  BIT   7,h   
039C   C8                     RET   z   
039D   AF                     XOR   a   
039E   95                     SUB   l   
039F   6F                     LD   l,a   
03A0   9F                     SBC   a,a   
03A1   94                     SUB   h   
03A2   67                     LD   h,a   
03A3   E5                     PUSH   hl   
03A4   DD E9                  JP   (ix)   
03A6                ADDROF_:      
03A6   C3 99 08               JP   addrOf   
03A9                ARRAYITER_:      
03A9   C3 86 05               JP   arrayIter   
03AC                             ; /as size of an array, num elements, ignores vDataWidth :-/
03AC                             ; array* -- num
03AC                ARRAYSIZE_:      
03AC   E1                     POP   hl   
03AD   2B                     DEC   hl   ; msb size
03AE   56                     LD   d,(hl)   
03AF   2B                     DEC   hl   ; lsb size
03B0   5E                     LD   e,(hl)   
03B1   D5                     PUSH   de   
03B2   DD E9                  JP   (ix)   
03B4                BREAK_:      
03B4   C3 F6 09               JP   break   
03B7                             ; /by
03B7                COLDSTART_:      
03B7   C3 C0 0E               JP   coldStart   
03BA                             ; /b
03BA                BYTES_:      
03BA   21 01 00               LD   hl,1   
03BD                BYTES1:      
03BD   22 E6 23               LD   (vDataWidth),hl   
03C0   DD E9                  JP   (ix)   
03C2                             ; Z80 port input
03C2                             ; port -- value
03C2                INPUT_:      
03C2   E1                     POP   hl   
03C3   59                     LD   e,c   ; save IP
03C4   4D                     LD   c,l   
03C5   ED 68                  IN   l,(c)   
03C7   26 00                  LD   h,0   
03C9   4B                     LD   c,e   ; restore IP
03CA   E5                     PUSH   hl   
03CB   DD E9                  JP   (ix)   
03CD                             ; /pc printChars
03CD                             ; char* len --
03CD                PRINTCHARS_:      
03CD   E1                     POP   hl   ; hl = count
03CE   D1                     POP   de   ; de = char*
03CF   CD 9D 0C               CALL   printChars2   
03D2   DD E9                  JP   (ix)   
03D4                             ; /qt
03D4                             ; bool --
03D4                QUIT_:       
03D4   E1                     POP   hl   ; hl = condition, exit if true
03D5   7D                     LD   a,l   
03D6   B4                     OR   h   
03D7   20 02                  JR   nz,quit1   
03D9   DD E9                  JP   (ix)   
03DB                QUIT1:       
03DB   C3 89 09               JP   blockEnd   
03DE                             ; /w
03DE                WORDS:       
03DE   21 02 00               LD   hl,2   
03E1   C3 BD 03               JP   bytes1   
03E4                COMMAND_F_:      
03E4   18 1A                  JR   command_f   
03E6                             ; //
03E6                COMMENT:      
03E6   03                     INC   bc   ; point to next char
03E7   0A                     LD   a,(bc)   
03E8   FE 20                  CP   " "   ; terminate on any char less than SP
03EA   30 FA                  JR   nc,comment   
03EC   0B                     DEC   bc   
03ED   DD E9                  JP   (ix)   
03EF                             ;********************** PAGE 3 END *********************************************
03EF                          ALIGN   $100   
0400                             ;********************** PAGE 4 BEGIN *********************************************
0400                COMMAND_F:      
0400   CD 0F 0E               CALL   jumpTable   
0403   64                     DB   "d"   ; /fd fold
0404   26                     DB   lsb(fold_)   
0405   65                     DB   "e"   ; /fe forEach
0406   1B                     DB   lsb(forEach_)   
0407   6C                     DB   "l"   ; /fl flush output buffer
0408   1E                     DB   lsb(flush_)   
0409   73                     DB   "s"   ; /fs funcSrc
040A   29                     DB   lsb(funcSrc_)   
040B   74                     DB   "t"   ; /ft filter
040C   23                     DB   lsb(filter_)   
040D   31                     DB   "1"   
040E   2C                     DB   lsb(f1_)   
040F   32                     DB   "2"   
0410   2F                     DB   lsb(f2_)   
0411   33                     DB   "3"   
0412   32                     DB   lsb(f3_)   
0413   34                     DB   "4"   
0414   35                     DB   lsb(f4_)   
0415   7A                     DB   "z"   
0416   38                     DB   lsb(fz_)   
0417   00                     DB   NUL   
0418   C3 3B 04               JP   false_   
041B                FOREACH_:      
041B   C3 7F 07               JP   forEach   
041E                             ; /fl flush
041E                             ; --
041E                FLUSH_:      
041E   CD E4 0D               CALL   flushBuffer   
0421   DD E9                  JP   (ix)   
0423                FILTER_:      
0423   C3 CF 06               JP   filter   
0426                FOLD_:       
0426   C3 2D 07               JP   fold   
0429                FUNCSRC_:      
0429   C3 CB 07               JP   funcSrc   
042C                F1_:         
042C   C3 C0 0F               JP   f1   
042F                F2_:         
042F   C3 C0 0F               JP   f2   
0432                F3_:         
0432   C3 C0 0F               JP   f3   
0435                F4_:         
0435   C3 C0 0F               JP   f4   
0438                FZ_:         
0438   C3 ED 0A               JP   fz   
043B                FALSE_:      
043B   C3 B7 02               JP   false1   
043E                COMMAND_M:      
043E   CD 0F 0E               CALL   jumpTable   
0441   70                     DB   "p"   ; /mp map
0442   47                     DB   lsb(map_)   
0443   00                     DB   NUL   
0444   C3 76 03               JP   error1_   
0447                MAP_:        
0447   C3 8D 06               JP   map   
044A                COMMAND_R:      
044A   CD 0F 0E               CALL   jumpTable   
044D   63                     DB   "c"   ; /rc tail call optimisation
044E   57                     DB   lsb(recur_)   
044F   65                     DB   "e"   ; /re remainder
0450   5D                     DB   lsb(remain_)   
0451   67                     DB   "g"   ; /rg range src
0452   6F                     DB   lsb(rangeSrc_)   
0453   00                     DB   NUL   
0454   C3 76 03               JP   error1_   
0457                RECUR_:      
0457   E1                     POP   hl   
0458   22 F2 23               LD   (vRecur),hl   
045B   DD E9                  JP   (ix)   
045D                REMAIN_:      
045D   2A F8 23               LD   hl,(vRemain)   
0460   E5                     PUSH   hl   
0461   DD E9                  JP   (ix)   
0463                COMMAND_S:      
0463   CD 0F 0E               CALL   jumpTable   
0466   69                     DB   "i"   
0467   6C                     DB   lsb(stringIter_)   
0468   00                     DB   NUL   
0469   C3 76 03               JP   error1_   
046C                STRINGITER_:      
046C   C3 07 06               JP   stringIter   
046F                RANGESRC_:      
046F   C3 0A 05               JP   rangeSrc   
0472                COMMAND_V:      
0472   CD 0F 0E               CALL   jumpTable   
0475   62                     DB   "b"   
0476   94                     DB   lsb(varBufPtr_)   
0477   68                     DB   "h"   
0478   9D                     DB   lsb(varHeapPtr_)   
0479   74                     DB   "t"   
047A   A6                     DB   lsb(varTIBPtr_)   
047B   42                     DB   "B"   
047C   85                     DB   lsb(constBufStart_)   
047D   48                     DB   "H"   
047E   8A                     DB   lsb(constHeapStart_)   
047F   54                     DB   "T"   
0480   8F                     DB   lsb(constTIBStart_)   
0481   00                     DB   NUL   
0482   C3 76 03               JP   error1_   
0485                CONSTBUFSTART_:      
0485   11 00 22               LD   de,BUF   
0488   18 28                  JR   constant   
048A                CONSTHEAPSTART_:      
048A   11 20 24               LD   de,HEAP   
048D   18 23                  JR   constant   
048F                CONSTTIBSTART_:      
048F   11 00 21               LD   de,TIB   
0492   18 1E                  JR   constant   
0494                VARBUFPTR_:      
0494   ED 5B EC 23            LD   de,(vBufPtr)   
0498   21 EC 23               LD   hl,vBufPtr   
049B   18 12                  JR   variable   
049D                VARHEAPPTR_:      
049D   ED 5B F0 23            LD   de,(vHeapPtr)   
04A1   21 F0 23               LD   hl,vHeapPtr   
04A4   18 09                  JR   variable   
04A6                VARTIBPTR_:      
04A6   ED 5B EA 23            LD   de,(vTIBPtr)   
04AA   21 EA 23               LD   hl,vTIBPtr   
04AD   18 00                  JR   variable   
04AF                VARIABLE:      
04AF   22 F6 23               LD   (vPointer),hl   
04B2                CONSTANT:      
04B2   D5                     PUSH   de   
04B3   DD E9                  JP   (ix)   
04B5                DOT:         
04B5   CD 0F 0E               CALL   jumpTable   
04B8   61                     DB   "a"   ; .a print array
04B9   04                     DB   lsb(dotArray)   
04BA   63                     DB   "c"   ; .c print char
04BB   E9                     DB   lsb(dotChar_)   
04BC   73                     DB   "s"   ; .s print string
04BD   CF                     DB   lsb(dotString_)   
04BE   78                     DB   "x"   ; .x print x chars
04BF   EE                     DB   lsb(dotXChars_)   
04C0   00                     DB   NUL   ; .  print number
04C1   C3 C4 04               JP   dotNumber_   
04C4                             ; /bd buffer decimal
04C4                             ; value --
04C4                DOTNUMBER_:      
04C4   3A E8 23               LD   a,(vNumBase)   
04C7   FE 10                  CP   16   
04C9   CA 9C 0A               JP   z,bufferHex   ; else falls through
04CC   C3 36 0A               JP   bufferDec   
04CF                             ; /bs buffered string
04CF                             ; string* --
04CF                DOTSTRING_:      
04CF   E1                     POP   hl   ; hl = string*
04D0   ED 5B EC 23            LD   de,(vBufPtr)   ; de = buffer*
04D4   18 06                  JR   dotString1   
04D6                DOTSTRING0:      
04D6   12                     LD   (de),a   ; a -> buffer*
04D7   1C                     INC   e   ; buffer*++, wraparound
04D8   CC E4 0D               CALL   z,flushBuffer   
04DB   23                     INC   hl   
04DC                DOTSTRING1:      
04DC   7E                     LD   a,(hl)   ; a <- string*
04DD   B7                     OR   a   ; if NUL exit loop
04DE   20 F6                  JR   nz,dotString0   
04E0   2A EC 23               LD   hl,(vBufPtr)   ; de = buffer*' hl = buffer*
04E3   ED 53 EC 23            LD   (vBufPtr),de   ; save buffer*' in pointer
04E7   DD E9                  JP   (ix)   
04E9                             ; /bc buffer char
04E9                             ; char --
04E9                DOTCHAR_:      
04E9   21 01 00               LD   hl,1   
04EC   18 01                  JR   dotXChars0   
04EE                             ; /bx buffered x chars
04EE                             ; char length --
04EE                DOTXCHARS_:      
04EE   E1                     POP   hl   ; hl = length
04EF                DOTXCHARS0:      
04EF   D1                     POP   de   ; a' = char
04F0   7B                     LD   a,e   
04F1   08                     EX   af,af'   
04F2   ED 5B EC 23            LD   de,(vBufPtr)   ; de = buffer*
04F6   18 08                  JR   dotXChars2   
04F8                DOTXCHARS1:      
04F8   08                     EX   af,af'   
04F9   12                     LD   (de),a   
04FA   08                     EX   af,af'   
04FB   1C                     INC   e   ; buffer*++, wraparound
04FC   CC E4 0D               CALL   z,flushBuffer   
04FF   2B                     DEC   hl   
0500                DOTXCHARS2:      
0500   7D                     LD   a,l   
0501   B4                     OR   h   
0502   20 F4                  JR   nz,dotXChars1   
0504   ED 53 EC 23            LD   (vBufPtr),de   ; save buffer*'
0508   DD E9                  JP   (ix)   
050A                             ;********************** PAGE 4 END *********************************************
050A                             ;*******************************************************************
050A                             ; Monty implementations
050A                             ;*******************************************************************
050A                             ; /rg rangeSrc
050A                             ; begin end step -- src
050A                          ;*Macro unroll: FUNC rangeSrc, 1, "besL"            ; range source: begin, end, step, local: L
050A                RANGESRC:      ; range source: begin, end, step, local: L
050A   CD FA 0A               CALL   go   
050D   00 00                  DW   NUL   
050F   19 05                  DW   rangeSrcM_1297S870   
0511   13 05                  DW   $+2   
0513   01                     DB   1   
0514   04 62 65 73 4C         .PSTR   "besL"   
0519                RANGESRCM_1297S870:      
0519   7B                     DB   "{"   
051A   5B 25 62 20 2F 74 5D 20 25 4C 3D DB   "[%b /t] %L="   ; init mutable L [index active]
0525   5C 6B 74 7B            DB   "\\kt{"   
0529   30 25 74 21 3D 2F 71 74 DB   "0%t!=/qt"   ; break if type != 0
0531   5C 64 74 3A 61 7B      DB   "\\dt:a{"   ; return talkback to receive data
0537   25 4C 31 23 21 2F 71 74 DB   "%L1#!/qt"   ; if not active don't send
053F   25 4C 30 23 20 25 61 3D DB   "%L0# %a="   ; store current index in A
0547   25 73 20 25 4C 30 23 20 2B 3D DB   "%s %L0# +="   ; inc value of index by step
0551   31 25 74 21 3D 2F 71 74 DB   "1%t!=/qt"   ; break if type != 0
0559   25 61 20 25 65 20 3C   DB   "%a %e <"   ; ifte: in range?
0560   7B 25 61 20 31 7D 7B 2F 66 20 25 4C 31 23 3D 20 30 20 32 7D DB   "{%a 1}{/f %L1#= 0 2}"   ; ifte: /t index, /f active = false, quit
0574   3F 3F 20 25 6B 2F 72 63 DB   "?? %k/rc"   ; ifte: send to sink note: /rc recur
057C   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0583   7D                     DB   "}"   
0584   7D                     DB   "}"   
0585   00                     DB   0   
0586                             ; /ai arrayIter
0586                             ; array* -- src
0586                          ;*Macro unroll: FUNC arrayIter, 1, "aL"
0586                ARRAYITER:      
0586   CD FA 0A               CALL   go   
0589   00 00                  DW   NUL   
058B   93 05                  DW   arrayIterM_1316S890   
058D   8F 05                  DW   $+2   
058F   01                     DB   1   
0590   02 61 4C               .PSTR   "aL"   
0593                ARRAYITERM_1316S890:      
0593   7B                     DB   "{"   
0594   5B 30 20 2F 74 20 25 61 2F 61 73 5D 20 25 4C 3D DB   "[0 /t %a/as] %L="   ; init mutable L [index active size]
05A4   5C 6B 74 7B            DB   "\\kt{"   
05A8   30 25 74 21 3D 2F 71 74 DB   "0%t!=/qt"   ; break if type != 0
05B0   5C 64 74 3A 69 7B      DB   "\\dt:i{"   ; return talkback to receive data
05B6   25 4C 31 23 21 2F 71 74 DB   "%L1#!/qt"   ; if not active don't send
05BE   25 4C 30 23 20 25 69 3D DB   "%L0# %i="   ; store current index in i
05C6   25 4C 30 23 20 2B 2B   DB   "%L0# ++"   ; inc value of index
05CD   31 25 74 21 3D 2F 71 74 DB   "1%t!=/qt"   ; break if type != 0
05D5   25 69 20 25 4C 32 23 20 3C DB   "%i %L2# <"   ; ifte: index < size
05DE   7B 25 61 25 69 23 20 31 7D 7B 2F 66 20 25 4C 31 23 3D 20 30 20 32 7D DB   "{%a%i# 1}{/f %L1#= 0 2}"   ; ifte: /t value, /f active = false, quit
05F5   3F 3F 20 25 6B 2F 72 63 DB   "?? %k/rc"   ; ifte: send to sink note: /rc recur
05FD   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0604   7D                     DB   "}"   
0605   7D                     DB   "}"   
0606   00                     DB   0   
0607                             ; /si stringIter
0607                             ; string* -- src
0607                          ;*Macro unroll: FUNC stringIter, 1, "sL"
0607                STRINGITER:      
0607   CD FA 0A               CALL   go   
060A   00 00                  DW   NUL   
060C   14 06                  DW   stringIterM_1335S910   
060E   10 06                  DW   $+2   
0610   01                     DB   1   
0611   02 73 4C               .PSTR   "sL"   
0614                STRINGITERM_1335S910:      
0614   7B                     DB   "{"   
0615   5B 30 20 2F 74 5D 20 25 4C 3D DB   "[0 /t] %L="   ; init mutable L [index active]
061F   5C 6B 74 7B            DB   "\\kt{"   
0623   30 25 74 21 3D 2F 71 74 DB   "0%t!=/qt"   ; break if type != 0
062B   5C 64 74 3A 69 63 7B   DB   "\\dt:ic{"   ; return talkback to receive data
0632   25 4C 31 23 21 2F 71 74 DB   "%L1#!/qt"   ; if not active don't send
063A   25 4C 30 23 20 25 69 3D DB   "%L0# %i="   ; store current index in A
0642   25 4C 30 23 20 2B 2B   DB   "%L0# ++"   ; inc value of index by step
0649   2F 62 20 25 73 25 69 23 20 2F 77 20 25 63 3D DB   "/b %s%i# /w %c="   ; read byte at i, store in c as word
0658   31 25 74 21 3D 2F 71 74 DB   "1%t!=/qt"   ; break if type != 0
0660   25 63 20 30 20 21 3D   DB   "%c 0 !="   ; ifte: c != NUL ?
0667   7B 25 63 20 31 7D 7B 2F 66 20 25 4C 31 23 3D 20 30 20 32 7D DB   "{%c 1}{/f %L1#= 0 2}"   ; ifte: 1: send c, 2: active = false, send quit
067B   3F 3F 20 25 6B 2F 72 63 DB   "?? %k/rc"   ; ifte: call sink note: /rc recur
0683   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
068A   7D                     DB   "}"   
068B   7D                     DB   "}"   
068C   00                     DB   0   
068D                             ; /mp map
068D                             ; src func -- src1
068D                          ;*Macro unroll: FUNC map, 0, "sf"                   ; map: source, function
068D                MAP:         ; map: source, function
068D   CD FA 0A               CALL   go   
0690   00 00                  DW   NUL   
0692   9A 06                  DW   mapM_1355S932   
0694   96 06                  DW   $+2   
0696   00                     DB   0   
0697   02 73 66               .PSTR   "sf"   
069A                MAPM_1355S932:      
069A   7B                     DB   "{"   
069B   5C 6B 74 7B            DB   "\\kt{"   
069F   30 25 74 21 3D 2F 71 74 DB   "0%t!=/qt"   ; break if type != 0
06A7   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
06AB   31 25 74 3D 3D         DB   "1%t=="   ; ifte: type == 1 ?
06B0   7B 25 64 20 25 66 5E 7D 7B 25 64 7D DB   "{%d %f^}{%d}"   ; ifte: func(data) or data
06BC   3F 3F 20 25 74 20 25 6B 5E DB   "?? %t %k^"   ; ifte: send to sink
06C5   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
06CC   7D                     DB   "}"   
06CD   7D                     DB   "}"   
06CE   00                     DB   0   
06CF                             ; /ft filter
06CF                             ; src pred -- src1
06CF                          ;*Macro unroll: FUNC filter, 1, "spT"               ; filter: source, predicate, local: T
06CF                FILTER:      ; filter: source, predicate, local: T
06CF   CD FA 0A               CALL   go   
06D2   00 00                  DW   NUL   
06D4   DD 06                  DW   filterM_1369S947   
06D6   D8 06                  DW   $+2   
06D8   01                     DB   1   
06D9   03 73 70 54            .PSTR   "spT"   
06DD                FILTERM_1369S947:      
06DD   7B                     DB   "{"   
06DE   5B 30 5D 25 54 3D      DB   "[0]%T="   
06E4   5C 6B 74 7B            DB   "\\kt{"   ; return talkback to receive data
06E8   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
06EC   5B                     DB   "["   
06ED   7B 25 64 20 25 54 30 23 3D 20 2F 74 7D DB   "{%d %T0#= /t}"   ; case 0: store talkback in T[0], return true
06FA   7B 25 64 20 25 70 5E 7D DB   "{%d %p^}"   ; case 1: return boolean based on predicate
0702   7B 2F 74 7D            DB   "{/t}"   ; case 2: return true
0706   5D 25 74 23 5E         DB   "]%t#^"   ; select on %t
070B   7B 25 64 20 25 74 20 25 6B 5E 7D 7B 30 20 31 20 25 54 30 23 5E 7D DB   "{%d %t %k^}{0 1 %T0#^}"   ; ifte: true send d to sink, false send 1 to talkback
0721   3F 3F                  DB   "??"   
0723   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
072A   7D                     DB   "}"   
072B   7D                     DB   "}"   
072C   00                     DB   0   
072D                             ; /fd fold
072D                             ; reducer is a function like: \\da00bbLi4u
072D                             ; src init reducer -- src1
072D                          ;*Macro unroll: FUNC fold, 1, "sirA"                    ; src, init, reducer
072D                FOLD:        ; src, init, reducer
072D   CD FA 0A               CALL   go   
0730   00 00                  DW   NUL   
0732   3C 07                  DW   foldM_1388S967   
0734   36 07                  DW   $+2   
0736   01                     DB   1   
0737   04 73 69 72 41         .PSTR   "sirA"   
073C                FOLDM_1388S967:      
073C   7B                     DB   "{"   ; reducer: \\da00bbLi4u
073D   5B 25 69 5D 25 41 3D   DB   "[%i]%A="   
0744   5C 6B 74 7B            DB   "\\kt{"   ; return talkback to receive data
0748   5C 64 74 7B            DB   "\\dt{"   ; call source with tb
074C   31 25 74 3D 3D         DB   "1%t=="   ; ifte: type == 1 ?
0751   7B 25 64 20 25 41 30 23 20 25 72 5E 25 41 30 23 3D 20 25 41 30 23 7D 7B 25 64 7D DB   "{%d %A0# %r^%A0#= %A0#}{%d}"   ; ifte: reduce -> acc, acc or data
076C   3F 3F 20 25 74 20 25 6B 5E DB   "?? %t %k^"   ; ifte: send to sink
0775   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
077C   7D                     DB   "}"   
077D   7D                     DB   "}"   
077E   00                     DB   0   
077F                             ; /fe forEach
077F                             ; src proc --
077F                          ;*Macro unroll: FUNC forEach, 1, "spT"              ; forEach: source, procedure, local: T
077F                FOREACH:      ; forEach: source, procedure, local: T
077F   CD FA 0A               CALL   go   
0782   00 00                  DW   NUL   
0784   8D 07                  DW   forEachM_1402S982   
0786   88 07                  DW   $+2   
0788   01                     DB   1   
0789   03 73 70 54            .PSTR   "spT"   
078D                FOREACHM_1402S982:      
078D   7B                     DB   "{"   
078E   5B 30 5D 25 54 3D      DB   "[0]%T="   
0794   5C 64 74 7B            DB   "\\dt{"   ; return talkback to receive data ; $56AA
0798   32 25 74 3D 3D 2F 71 74 DB   "2%t==/qt"   ; if type == 2 skip
07A0   30 25 74 3D 3D         DB   "0%t=="   ; ifte: type = 0 ?
07A5   7B 25 64 20 25 54 30 23 3D 7D 7B 25 64 20 25 70 5E 7D DB   "{%d %T0#=}{%d %p^}"   ; ifte: 0: store talkback, 1: send data
07B7   3F 3F                  DB   "??"   ; ifte:
07B9   30 20 31 20 25 54 30 23 5E DB   "0 1 %T0#^"   ; 0 or 1: get next src data item
07C2   7D 20 30 20 25 73 5E   DB   "} 0 %s^"   
07C9   7D                     DB   "}"   
07CA   00                     DB   0   
07CB                             ; ; /fs funcSrc
07CB                             ; ; func -- src
07CB                          ;*Macro unroll: FUNC funcSrc, 0, "f"                      ; :f func or block
07CB                FUNCSRC:      ; :f func or block
07CB   CD FA 0A               CALL   go   
07CE   00 00                  DW   NUL   
07D0   D7 07                  DW   funcSrcM_1416S997   
07D2   D4 07                  DW   $+2   
07D4   00                     DB   0   
07D5   01 66                  .PSTR   "f"   
07D7                FUNCSRCM_1416S997:      
07D7   7B                     DB   "{"   
07D8   5C 6B 74 7B            DB   "\\kt{"   ; :kt sink, type
07DC   30 25 74 3D 3D 2F 62 72 DB   "0%t==/br"   ; break if t != 0
07E4   5C 64 74 7B            DB   "\\dt{"   
07E8   31 25 74 3D 3D 2F 62 72 20 25 66 5E 20 31 20 25 6B 5E DB   "1%t==/br %f^ 1 %k^"   ; if t == 1 send data to sink
07FA   7D 20 30 20 25 6B 5E   DB   "} 0 %k^"   ; init sink
0801   7D                     DB   "}"   
0802   7D                     DB   "}"   
0803   00                     DB   0   
0804                          ;*Macro unroll: FUNC dotArray, 2, "abc"
0804                DOTARRAY:      
0804   CD FA 0A               CALL   go   
0807   00 00                  DW   NUL   
0809   12 08                  DW   dotArrayM_1426S1008   
080B   0D 08                  DW   $+2   
080D   02                     DB   2   
080E   03 61 62 63            .PSTR   "abc"   
0812                DOTARRAYM_1426S1008:      
0812   7B                     DB   "{"   
0813   60 5B 20 60 2E 73 20 25 61 2F 61 73 25 63 3D 20 30 25 62 3D 20 28 25 61 20 25 62 20 23 2E 20 25 62 20 2B 2B 20 25 62 20 25 63 20 3C 2F 62 72 29 5E 20 60 5D 60 2E 73 DB   "`[ `.s %a/as%c= 0%b= (%a %b #. %b ++ %b %c </br)^ `]`.s"   
084A   7D                     DB   "}"   
084B   00                     DB   0   
084C                             ;*******************************************************************
084C                             ; unused opcodes (reserved)
084C                             ;*******************************************************************
084C                UNDERSCORE:      
084C                TILDE:       
084C                COMMA:       
084C   DD E9                  JP   (ix)   
084E                             ;*******************************************************************
084E                             ; implementations
084E                             ;*******************************************************************
084E                             ; _ func
084E                             ; -- func*
084E                COLON:       
084E   03                     INC   bc   ; arg_list must ve immediately followed by {
084F   0A                     LD   a,(bc)   
0850   FE 3D                  CP   "="   ; := definition
0852   28 28                  JR   z,defineStart   
0854   0B                     DEC   bc   
0855   21 01 00               LD   hl,1   
0858   C3 77 0F               JP   error   
085B                BACKSLASH:      
085B                LAMBDA:      
085B   DD E5                  PUSH   ix   
085D   CD A2 0C               CALL   parseArgs   
0860                LAMBDA1:      
0860   03                     INC   bc   ; arg_list must ve immediately followed by {
0861   0A                     LD   a,(bc)   
0862   FE 21                  CP   " "+1   ; skip white space
0864   38 FA                  JR   c,lambda1   
0866   FE 7B                  CP   "{"   
0868   28 06                  JR   z,lambda2   
086A   21 02 00               LD   hl,2   ; error 2: parse error
086D   C3 77 0F               JP   error   
0870                LAMBDA2:      
0870   CD D8 0C               CALL   parseBlock   
0873   CD 42 0D               CALL   createFunc   
0876   E1                     POP   hl   
0877   DD E1                  POP   ix   
0879   E5                     PUSH   hl   
087A   DD E9                  JP   (ix)   
087C                DEFINESTART:      
087C   E1                     POP   hl   ; discard variable value
087D   2A F6 23               LD   hl,(vPointer)   ; vDefine = vPointer
0880   22 F4 23               LD   (vDefine),hl   
0883   DD E9                  JP   (ix)   
0885                SEMICOLON:      
0885                DEFINEEND:      
0885   2A F4 23               LD   hl,(vDefine)   ; hl = define*
0888   7D                     LD   a,l   
0889   B4                     OR   h   
088A   28 0B                  JR   z,defineEnd1   
088C   11 00 00               LD   de,NUL   ; set vDefine=NUL
088F   ED 53 F4 23            LD   (vDefine),de   
0893   D1                     POP   de   ; de = value
0894   C3 79 09               JP   assign1   
0897                DEFINEEND1:      
0897   DD E9                  JP   (ix)   
0899                             ; /ad addrOf
0899                             ; char -- addr
0899                ADDROF:      
0899   E1                     POP   hl   ; a = char
089A   7D                     LD   a,l   
089B   FE 7B                  CP   "z"+1   ; if a > z then exit
089D   30 19                  JR   nc,addrOf2   
089F   D6 41                  SUB   "A"   ; a - 65
08A1   38 15                  JR   c,addrOf2   ; if < A then exit
08A3   FE 1A                  CP   "Z"+1-"A"   ; if > Z then subtract 7
08A5   38 06                  JR   c,addrOf1   
08A7   D6 06                  SUB   "a"-("Z"+1)   
08A9   FE 1A                  CP   "Z"-"A"+1   
08AB   38 0B                  JR   c,addrOf2   ; if < a then exit
08AD                ADDROF1:      
08AD   87                     ADD   a,a   ; double a
08AE   21 00 23               LD   hl,VARS   ; hl = VARS + a
08B1   85                     ADD   a,l   
08B2   6F                     LD   l,a   
08B3   3E 00                  LD   a,0   
08B5   8C                     ADC   a,h   
08B6   67                     LD   h,a   
08B7   E5                     PUSH   hl   
08B8                ADDROF2:      
08B8   DD E9                  JP   (ix)   
08BA                             ; %a .. %z
08BA                             ; -- value
08BA                             ; returns value of arg
08BA                PERCENT:      
08BA                ARG:         
08BA   FD 5E 04               LD   e,(iy+4)   ; hl = arg_list*
08BD   FD 56 05               LD   d,(iy+5)   
08C0   EB                     EX   de,hl   
08C1   7D                     LD   a,l   ; arg_list* == null, skip
08C2   B4                     OR   h   
08C3   28 1A                  JR   z,arg0a   
08C5   23                     INC   hl   ; a = num_args, hl = arg_list*
08C6   7E                     LD   a,(hl)   
08C7   23                     INC   hl   
08C8   B7                     OR   a   
08C9   28 14                  JR   z,arg0a   ; num_args == 0, skip
08CB   5F                     LD   e,a   ; e = a = num_args
08CC   03                     INC   bc   ; a = next char = dollar_name
08CD   0A                     LD   a,(bc)   
08CE   C5                     PUSH   bc   ; save IP
08CF   43                     LD   b,e   ; b = e = num_args
08D0   FD 5E 02               LD   e,(iy+2)   ; de = first_arg*, hl = argslist*
08D3   FD 56 03               LD   d,(iy+3)   
08D6                ARG0:        
08D6   1B                     DEC   de   ; a = dollar_name, de = next arg*
08D7   1B                     DEC   de   
08D8   BE                     CP   (hl)   
08D9   28 09                  JR   z,arg1   
08DB   23                     INC   hl   ; hl = next arg_list*
08DC   10 F8                  DJNZ   arg0   
08DE   C1                     POP   bc   ; no match, restore IP
08DF                ARG0A:       
08DF   11 00 00               LD   de,0   ; return 0
08E2   18 08                  JR   arg1a   
08E4                ARG1:        
08E4   C1                     POP   bc   ; restore IP
08E5   EB                     EX   de,hl   ; hl = arg*
08E6   22 F6 23               LD   (vPointer),hl   ; store arg* in setter
08E9   5E                     LD   e,(hl)   
08EA   23                     INC   hl   
08EB   56                     LD   d,(hl)   ; de = arg
08EC                ARG1A:       
08EC   D5                     PUSH   de   ; push arg
08ED   DD E9                  JP   (ix)   
08EF                LBRACK:      
08EF                ARRAYSTART:      
08EF   11 00 00               LD   de,0   ; create stack frame
08F2   D5                     PUSH   de   ; push null for IP
08F3   FD 5E 04               LD   e,(iy+4)   ; push arg_list* from parent stack frame
08F6   FD 56 05               LD   d,(iy+5)   ; 
08F9   D5                     PUSH   de   ; 
08FA   FD 5E 02               LD   e,(iy+2)   ; push first_arg* from parent stack frame
08FD   FD 56 03               LD   d,(iy+3)   ; 
0900   D5                     PUSH   de   ; 
0901   FD E5                  PUSH   iy   ; push BP
0903   FD 21 00 00            LD   iy,0   ; BP = SP
0907   FD 39                  ADD   iy,sp   
0909   DD E9                  JP   (ix)   
090B                RBRACK:      
090B                ARRAYEND:      
090B   FD 54                  LD   d,iyh   ; de = BP
090D   FD 5D                  LD   e,iyl   
090F   ED 43 02 24            LD   (vTemp1),bc   ; save IP
0913   62 6B                  LD   hl,de   ; hl = de = BP
0915   B7                     OR   a   
0916   ED 72                  SBC   hl,sp   ; hl = array count (items on stack)
0918   CB 3C                  SRL   h   ; 
091A   CB 1D                  RR   l   
091C   44 4D                  LD   bc,hl   ; bc = count
091E   2A F0 23               LD   hl,(vHeapPtr)   ; hl = array[-4]
0921   71                     LD   (hl),c   ; write num items in length word
0922   23                     INC   hl   
0923   70                     LD   (hl),b   
0924   23                     INC   hl   ; hl = array[0], bc = count
0925                             ; de = BP, hl = array[0], bc = count
0925   18 15                  JR   arrayEnd3   
0927                ARRAYEND1:      
0927   FD 7E FE               LD   a,(iy-2)   ; a = lsb of stack item
092A   77                     LD   (hl),a   ; write lsb of array item
092B   23                     INC   hl   ; move to msb of array item
092C   3A E6 23               LD   a,(vDataWidth)   ; vDataWidth=1?
092F   3D                     DEC   a   
0930   28 05                  JR   z,arrayEnd2   
0932   FD 7E FF               LD   a,(iy-1)   ; a = msb of stack item
0935   77                     LD   (hl),a   ; write msb of array item
0936   23                     INC   hl   ; move to next word in array
0937                ARRAYEND2:      
0937   FD 2B                  DEC   iy   ; move to next word on stack
0939   FD 2B                  DEC   iy   
093B   0B                     DEC   bc   ; dec items count
093C                ARRAYEND3:      
093C   79                     LD   a,c   ; if not zero loop
093D   B0                     OR   b   
093E   20 E7                  JR   nz,arrayEnd1   
0940   EB                     EX   de,hl   ; de = end of array, hl = BP
0941   F9                     LD   sp,hl   ; sp = BP
0942   E1                     POP   hl   ; de = end of array, hl = old BP
0943   EB                     EX   de,hl   ; iy = de = old BP, hl = end of array
0944   FD 62                  LD   iyh,d   
0946   FD 6B                  LD   iyl,e   
0948   D1                     POP   de   ; pop arg_list (discard)
0949   D1                     POP   de   ; pop first_arg* (discard)
094A   D1                     POP   de   ; pop IP (discard)
094B   ED 5B F0 23            LD   de,(vHeapPtr)   ; de = array[-2]
094F   13                     INC   de   
0950   13                     INC   de   
0951   D5                     PUSH   de   ; return array[0]
0952   22 F0 23               LD   (vHeapPtr),hl   ; move heap* to end of array
0955   ED 4B 02 24            LD   bc,(vTemp1)   ; restore IP
0959   DD E9                  JP   (ix)   
095B                             ; index of an array, based on vDataWidth
095B                             ; array* num -- value    ; also sets vPointer to address
095B                HASH:        
095B                ARRAYINDEX:      
095B   E1                     POP   hl   ; hl = index
095C   D1                     POP   de   ; de = array
095D   3A E6 23               LD   a,(vDataWidth)   ; a = data width
0960   3D                     DEC   a   
0961   28 01                  JR   z,arrayIndex1   
0963                ARRAYINDEX0:      
0963   29                     ADD   hl,hl   ; if data width = 2 then double
0964                ARRAYINDEX1:      
0964   19                     ADD   hl,de   ; add addr
0965   22 F6 23               LD   (vPointer),hl   ; store address in setter
0968   16 00                  LD   d,0   
096A   5E                     LD   e,(hl)   
096B   B7                     OR   a   ; check data width again
096C   28 02                  JR   z,arrayIndex2   
096E   23                     INC   hl   
096F   56                     LD   d,(hl)   
0970                ARRAYINDEX2:      
0970   D5                     PUSH   de   
0971   DD E9                  JP   (ix)   
0973                             ; value _oldValue --            ; uses address in vPointer
0973                ASSIGN:      
0973   E1                     POP   hl   ; discard last accessed value
0974   E1                     POP   hl   ; hl = new value
0975                ASSIGN0:      
0975   EB                     EX   de,hl   ; de = new value
0976   2A F6 23               LD   hl,(vPointer)   
0979                ASSIGN1:      ; entry point from defineEnd
0979   73                     LD   (hl),e   
097A   3A E6 23               LD   a,(vDataWidth)   
097D   3D                     DEC   a   ; is it byte?
097E   28 02                  JR   z,assign2   
0980   23                     INC   hl   
0981   72                     LD   (hl),d   
0982                ASSIGN2:      
0982   DD E9                  JP   (ix)   
0984                             ; { block start
0984                             ; -- block*
0984                LBRACE:      
0984   CD D8 0C               CALL   parseBlock   
0987   DD E9                  JP   (ix)   
0989                RBRACE:      
0989                BLOCKEND:      
0989   FD 5E 00               LD   e,(iy+0)   ; vTemp1 = oldBP
098C   FD 56 01               LD   d,(iy+1)   
098F   ED 53 02 24            LD   (vTemp1),de   
0993   FD 5E 06               LD   e,(iy+6)   ; vTemp2 = oldIP
0996   FD 56 07               LD   d,(iy+7)   
0999   ED 53 04 24            LD   (vTemp2),de   
099D   FD 5E 02               LD   e,(iy+2)   ; hl = first_arg*, is it in this scope?
09A0   FD 56 03               LD   d,(iy+3)   
09A3   EB                     EX   de,hl   
09A4   FD 5E 00               LD   e,(iy+0)   ; de = oldBP
09A7   FD 56 01               LD   d,(iy+1)   
09AA   13                     INC   de   ; for carry flag <=
09AB   B7                     OR   a   
09AC   ED 52                  SBC   hl,de   
09AE   38 0B                  JR   c,blockEnd1   ; oldBP >= first_arg, same scope skip
09B0   FD 54                  LD   d,iyh   ; de = BP = first_result*, no args in this scope
09B2   FD 5D                  LD   e,iyl   
09B4   21 08 00               LD   hl,8   
09B7   19                     ADD   hl,de   ; de = BP = first_result* (BP), hl = first_arg* (BP+8)
09B8   EB                     EX   de,hl   ; de = first_arg*, hl = first_result*
09B9   18 0C                  JR   blockEnd2   
09BB                BLOCKEND1:      ; same scope
09BB   FD 5E 02               LD   e,(iy+2)   ; hl = first_arg*, in scope
09BE   FD 56 03               LD   d,(iy+3)   
09C1   EB                     EX   de,hl   
09C2   FD 54                  LD   d,iyh   ; de = first_arg*, hl = BP = first_result*
09C4   FD 5D                  LD   e,iyl   
09C6   EB                     EX   de,hl   
09C7                BLOCKEND2:      
09C7   44 4D                  LD   bc,hl   ; bc = hl = BP
09C9   B7                     OR   a   ; hl = BP - SP = count
09CA   ED 72                  SBC   hl,sp   
09CC   7D                     LD   a,l   
09CD   B4                     OR   h   
09CE   28 09                  JR   z,blockEnd3   
09D0   C5                     PUSH   bc   ; bc = count, hl = BP
09D1   44 4D                  LD   bc,hl   
09D3   E1                     POP   hl   
09D4   2B                     DEC   hl   ; hl = BP-1
09D5   1B                     DEC   de   ; de = args*-1
09D6   ED B8                  LDDR      
09D8   13                     INC   de   
09D9                BLOCKEND3:      
09D9   EB                     EX   de,hl   ; sp = de = new tos*
09DA   F9                     LD   sp,hl   
09DB   ED 4B 04 24            LD   bc,(vTemp2)   
09DF   FD 2A 02 24            LD   iy,(vTemp1)   
09E3   ED 5B F2 23            LD   de,(vRecur)   ; de = recur vector
09E7   7B                     LD   a,e   ; check for NUL
09E8   B2                     OR   d   
09E9   20 02                  JR   nz,blockEnd4   
09EB   DD E9                  JP   (ix)   
09ED                BLOCKEND4:      
09ED   21 00 00               LD   hl,0   ; clear recur vector
09F0   22 F2 23               LD   (vRecur),hl   
09F3   C3 FB 0A               JP   go1   ; execute de
09F6                             ; /br break from loop
09F6                             ; --
09F6                BREAK:       
09F6   E1                     POP   hl   ; hl = condition, break if false
09F7   7D                     LD   a,l   
09F8   B4                     OR   h   
09F9   28 02                  JR   z,break1   
09FB   DD E9                  JP   (ix)   
09FD                BREAK1:      
09FD   FD 5D                  LD   e,iyl   ; get block* just under stack frame
09FF   FD 54                  LD   d,iyh   
0A01   21 08 00               LD   hl,8   
0A04   19                     ADD   hl,de   
0A05   23                     INC   hl   
0A06   23                     INC   hl   
0A07   FD 75 02               LD   (iy+2),l   ; force first_arg* into this scope for clean up
0A0A   FD 74 03               LD   (iy+3),h   ; first_arg* = address of block*
0A0D   C3 89 09               JP   blockEnd   
0A10                TICK:        
0A10                CHAR:        
0A10   21 00 00               LD   hl,0   ; if "" is empty or null
0A13                CHAR1:       
0A13   03                     INC   bc   ; point to next char
0A14   0A                     LD   a,(bc)   
0A15   FE 27                  CP   "'"   ; ' is the terminator
0A17   28 09                  JR   z,char3   
0A19   FE 5C                  CP   $5c   ; \ is the escape
0A1B   20 02                  JR   nz,char2   
0A1D   03                     INC   bc   
0A1E   0A                     LD   a,(bc)   
0A1F                CHAR2:       
0A1F   6F                     LD   l,a   
0A20   18 F1                  JR   char1   
0A22                CHAR3:       
0A22   E5                     PUSH   hl   
0A23   DD E9                  JP   (ix)   
0A25                DIV:         
0A25   D1                     POP   de   
0A26   E1                     POP   hl   
0A27   C5                     PUSH   bc   ; preserve the IP
0A28   44 4D                  LD   bc,hl   
0A2A   CD D4 0A               CALL   divide   
0A2D   EB                     EX   de,hl   
0A2E   ED 53 F8 23            LD   (vRemain),de   
0A32   C1                     POP   bc   
0A33   C3 13 02               JP   add3   
0A36                             ; /bd buffer decimal
0A36                             ; value --
0A36                BUFFERDEC:      
0A36   ED 5B EC 23            LD   de,(vBufPtr)   ; de"= buffer* bc" = IP
0A3A   D9                     EXX      
0A3B   E1                     POP   hl   ; hl = value
0A3C   CD 50 0A               CALL   bufferDec0   
0A3F   D9                     EXX      ; de = buffer*' bc = IP
0A40   3E 20                  LD   a," "   ; append space to buffer
0A42   12                     LD   (de),a   
0A43   1C                     INC   e   ; buffer*++, wraparound
0A44   CC E4 0D               CALL   z,flushBuffer   
0A47   2A EC 23               LD   hl,(vBufPtr)   ; hl = buffer*
0A4A   ED 53 EC 23            LD   (vBufPtr),de   ; update buffer* with buffer*'
0A4E   DD E9                  JP   (ix)   
0A50                             ; hl = value
0A50                             ; de' = buffer*
0A50                             ; a, bc, de, hl destroyed
0A50                BUFFERDEC0:      
0A50   CB 7C                  BIT   7,h   
0A52   28 0C                  JR   z,bufferDec1   
0A54   D9                     EXX      
0A55   3E 2D                  LD   a,"-"   
0A57   12                     LD   (de),a   
0A58   13                     INC   de   
0A59   D9                     EXX      
0A5A   AF                     XOR   a   
0A5B   95                     SUB   l   
0A5C   6F                     LD   l,a   
0A5D   9F                     SBC   a,a   
0A5E   94                     SUB   h   
0A5F   67                     LD   h,a   
0A60                BUFFERDEC1:      
0A60   0E 00                  LD   c,0   ; leading zeros flag = false
0A62   11 F0 D8               LD   de,-10000   
0A65   CD 80 0A               CALL   bufferDec2   
0A68   11 18 FC               LD   de,-1000   
0A6B   CD 80 0A               CALL   bufferDec2   
0A6E   11 9C FF               LD   de,-100   
0A71   CD 80 0A               CALL   bufferDec2   
0A74   1E F6                  LD   e,-10   
0A76   CD 80 0A               CALL   bufferDec2   
0A79   0C                     INC   c   ; flag = true for at least digit
0A7A   1E FF                  LD   e,-1   
0A7C   CD 80 0A               CALL   bufferDec2   
0A7F   C9                     RET      
0A80                BUFFERDEC2:      
0A80   06 2F                  LD   b,"0"-1   
0A82                BUFFERDEC3:      
0A82   04                     INC   b   
0A83   19                     ADD   hl,de   
0A84   38 FC                  JR   c,bufferDec3   
0A86   ED 52                  SBC   hl,de   
0A88   3E 30                  LD   a,"0"   
0A8A   B8                     CP   b   
0A8B   20 05                  JR   nz,bufferDec4   
0A8D   AF                     XOR   a   
0A8E   B1                     OR   c   
0A8F   C8                     RET   z   
0A90   18 01                  JR   bufferDec5   
0A92                BUFFERDEC4:      
0A92   0C                     INC   c   
0A93                BUFFERDEC5:      
0A93   78                     LD   a,b   
0A94   D9                     EXX      
0A95   12                     LD   (de),a   
0A96   1C                     INC   e   
0A97   CC E4 0D               CALL   z,flushBuffer   
0A9A   D9                     EXX      
0A9B   C9                     RET      
0A9C                             ; /bh buffer hex
0A9C                             ; value --
0A9C                BUFFERHEX:      
0A9C   E1                     POP   hl   ; hl = value
0A9D   ED 5B EC 23            LD   de,(vBufPtr)   
0AA1   3E 24                  LD   a,"$"   ; # prefix
0AA3   12                     LD   (de),a   
0AA4   1C                     INC   e   ; buffer*++, wraparound
0AA5   CC E4 0D               CALL   z,flushBuffer   
0AA8   7C                     LD   a,h   
0AA9   CD BD 0A               CALL   bufferHex1   
0AAC   7D                     LD   a,l   
0AAD   CD BD 0A               CALL   bufferHex1   
0AB0   3E 20                  LD   a," "   ; append space to buffer
0AB2   12                     LD   (de),a   
0AB3   1C                     INC   e   ; buffer*++, wraparound
0AB4   CC E4 0D               CALL   z,flushBuffer   
0AB7   ED 53 EC 23            LD   (vBufPtr),de   
0ABB   DD E9                  JP   (ix)   
0ABD                BUFFERHEX1:      
0ABD   F5                     PUSH   af   
0ABE   1F                     RRA      
0ABF   1F                     RRA      
0AC0   1F                     RRA      
0AC1   1F                     RRA      
0AC2   CD C6 0A               CALL   bufferHex2   
0AC5   F1                     POP   af   
0AC6                BUFFERHEX2:      
0AC6   E6 0F                  AND   0x0F   
0AC8   C6 90                  ADD   a,0x90   
0ACA   27                     DAA      
0ACB   CE 40                  ADC   a,0x40   
0ACD   27                     DAA      
0ACE   12                     LD   (de),a   
0ACF   1C                     INC   e   ; buffer*++, wraparound
0AD0   CC E4 0D               CALL   z,flushBuffer   
0AD3   C9                     RET      
0AD4                             ; division subroutine.
0AD4                             ; bc: divisor, de: dividend, hl: remainder
0AD4                DIVIDE:      
0AD4   21 00 00               LD   hl,0   ; zero the remainder
0AD7   3E 10                  LD   a,16   ; loop counter
0AD9                DIVIDE1:      ; shift the bits from bc (numerator) into hl (accumulator)
0AD9   CB 21                  SLA   c   
0ADB   CB 10                  RL   b   
0ADD   ED 6A                  ADC   hl,hl   
0ADF   ED 52                  SBC   hl,de   ; check if remainder >= denominator (hl>=de)
0AE1   38 03                  JR   c,divide2   
0AE3   0C                     INC   c   
0AE4   18 01                  JR   divide3   
0AE6                DIVIDE2:      ; remainder is not >= denominator, so we have to add de back to hl
0AE6   19                     ADD   hl,de   
0AE7                DIVIDE3:      
0AE7   3D                     DEC   a   
0AE8   20 EF                  JR   nz,divide1   
0AEA   50 59                  LD   de,bc   ; result from bc to de
0AEC   C9                     RET      
0AED                FZ:          
0AED   21 00 21               LD   hl,STACK   
0AF0   ED 72                  SBC   hl,sp   
0AF2   CB 3C                  SRL   h   
0AF4   CB 1D                  RR   l   
0AF6   E5                     PUSH   hl   
0AF7   C3 C4 04               JP   dotNumber_   
0AFA                             ; execute a block of code which ends with }
0AFA                             ; creates a root scope if BP == stack
0AFA                             ; else uses outer scope
0AFA                CARET:       
0AFA                GO:          
0AFA   D1                     POP   de   ; de = block*
0AFB                GO1:         
0AFB   7B                     LD   a,e   ; if block* == null, exit
0AFC   B2                     OR   d   
0AFD   20 02                  JR   nz,go2   
0AFF   DD E9                  JP   (ix)   
0B01                GO2:         
0B01   1A                     LD   a,(de)   
0B02   FE 7B                  CP   "{"   
0B04   28 06                  JR   z,goBlock   
0B06   FE 28                  CP   "("   
0B08   C2 3F 0B               JP   nz,goFunc   
0B0B   D5                     PUSH   de   ; push de just before stack frame
0B0C                GOBLOCK:      
0B0C   ED 53 02 24            LD   (vTemp1),de   ; save de
0B10   21 00 21               LD   hl,stack   ; de = BP, hl = stack, (sp) = code*
0B13   FD 54                  LD   d,iyh   
0B15   FD 5D                  LD   e,iyl   
0B17   B7                     OR   a   ; if stack* == BP then this is the root_scope
0B18   ED 52                  SBC   hl,de   
0B1A   ED 5B 02 24            LD   de,(vTemp1)   ; restore de
0B1E   7D                     LD   a,l   ; if (not root_scope) then inherit scope vars from parent
0B1F   B4                     OR   h   
0B20   3E 00                  LD   a,0   
0B22   28 6A                  JR   z,goFunc8   
0B24   C5                     PUSH   bc   ; push IP
0B25   FD 4E 04               LD   c,(iy+4)   ; push arg_list* (parent)
0B28   FD 46 05               LD   b,(iy+5)   
0B2B   FD 6E 02               LD   l,(iy+2)   ; push first_arg* (parent)
0B2E   FD 66 03               LD   h,(iy+3)   
0B31                GOBLOCK2:      
0B31   C5                     PUSH   bc   ; arg_list*
0B32   E5                     PUSH   hl   ; first_arg*
0B33   FD E5                  PUSH   iy   ; push BP
0B35   FD 21 00 00            LD   iy,0   ; BP = SP
0B39   FD 39                  ADD   iy,sp   
0B3B                GOBLOCK3:      
0B3B   42 4B                  LD   bc,de   ; bc = de = block*-1
0B3D   DD E9                  JP   (ix)   
0B3F                GOFUNC:      ; execute func
0B3F   EB                     EX   de,hl   ; hl = func*
0B40   5E                     LD   e,(hl)   ; de = partial_array*
0B41   23                     INC   hl   
0B42   56                     LD   d,(hl)   
0B43   23                     INC   hl   
0B44   7B                     LD   a,e   ; if partial_array* == null skip
0B45   B2                     OR   d   
0B46   28 21                  JR   z,goFunc3   
0B48   ED 43 02 24            LD   (vTemp1),bc   
0B4C   22 04 24               LD   (vTemp2),hl   ; save bc,hl
0B4F   EB                     EX   de,hl   ; hl = partial_array*
0B50   2B                     DEC   hl   ; bc = count
0B51   46                     LD   b,(hl)   
0B52   2B                     DEC   hl   
0B53   4E                     LD   c,(hl)   
0B54   23                     INC   hl   ; hl = array data*
0B55   23                     INC   hl   
0B56   18 06                  JR   goFunc2   ; push each item on stack
0B58                GOFUNC1:      
0B58   5E                     LD   e,(hl)   ; de = partial item
0B59   23                     INC   hl   
0B5A   56                     LD   d,(hl)   
0B5B   23                     INC   hl   
0B5C   D5                     PUSH   de   ; push on stack
0B5D   0B                     DEC   bc   
0B5E                GOFUNC2:      
0B5E   79                     LD   a,c   ; if count != 0 then loop
0B5F   B0                     OR   b   
0B60   20 F6                  JR   nz,goFunc1   
0B62   ED 4B 02 24            LD   bc,(vTemp1)   ; restore bc
0B66   2A 04 24               LD   hl,(vTemp2)   ; restore hl
0B69                GOFUNC3:      
0B69   5E                     LD   e,(hl)   ; de = block*
0B6A   23                     INC   hl   
0B6B   56                     LD   d,(hl)   
0B6C   23                     INC   hl   
0B6D   ED 53 02 24            LD   (vTemp1),de   ; save block*
0B71   5E                     LD   e,(hl)   ; de = arg_list*
0B72   23                     INC   hl   
0B73   56                     LD   d,(hl)   
0B74   23                     INC   hl   
0B75   EB                     EX   de,hl   ; hl = arg_list*
0B76   ED 5B 02 24            LD   de,(vTemp1)   ; restore de = block*
0B7A   7D                     LD   a,l   ; if arg_list* == null a = 0
0B7B   B4                     OR   h   
0B7C   20 03                  JR   nz,goFunc4   
0B7E   AF                     XOR   a   ; a = num_args (zero), num_locals (zero)
0B7F   18 0D                  JR   goFunc8   
0B81                GOFUNC4:      ; allocate locals
0B81   7E                     LD   a,(hl)   ; a = num_locals*, de = hblock* hl = arg_list*
0B82   18 03                  JR   goFunc6   
0B84                GOFUNC5:      ; loop
0B84   3B                     DEC   sp   
0B85   3B                     DEC   sp   
0B86   3D                     DEC   a   
0B87                GOFUNC6:      
0B87   B7                     OR   a   
0B88   20 FA                  JR   nz,goFunc5   ; end loop
0B8A                GOFUNC7:      
0B8A   23                     INC   hl   ; a = num_args* x 2
0B8B   7E                     LD   a,(hl)   
0B8C   2B                     DEC   hl   
0B8D   87                     ADD   a,a   ; a *= 2
0B8E                GOFUNC8:      
0B8E   C5                     PUSH   bc   ; push IP
0B8F   44 4D                  LD   bc,hl   
0B91   21 02 00               LD   hl,2   ; hl = first_arg* (BP+8), a = num args offset
0B94   85                     ADD   a,l   
0B95   6F                     LD   l,a   
0B96   39                     ADD   hl,sp   
0B97   18 98                  JR   goBlock2   
0B99                DOLLAR:      
0B99                HEXNUM:      
0B99   21 00 00               LD   hl,0   ; Clear hl to accept the number
0B9C                HEXNUM1:      
0B9C   03                     INC   bc   
0B9D   0A                     LD   a,(bc)   ; Get the character which is a numeral
0B9E   CB 77                  BIT   6,a   ; is it uppercase alpha?
0BA0   28 02                  JR   z,hexnum2   ; no a decimal
0BA2   D6 07                  SUB   7   ; sub 7  to make $a - $F
0BA4                HEXNUM2:      
0BA4   D6 30                  SUB   $30   ; form decimal digit
0BA6   DA 36 0C               JP   c,num2   
0BA9   FE 10                  CP   $0F+1   
0BAB   D2 36 0C               JP   nc,num2   
0BAE   29                     ADD   hl,hl   ; 2X ; Multiply digit(s) in hl by 16
0BAF   29                     ADD   hl,hl   ; 4X
0BB0   29                     ADD   hl,hl   ; 8X
0BB1   29                     ADD   hl,hl   ; 16X
0BB2   85                     ADD   a,l   ; add into bottom of hl
0BB3   6F                     LD   l,a   
0BB4   18 E6                  JR   hexnum1   
0BB6                UPCASE:      
0BB6   0A                     LD   a,(bc)   ; a = identifier char
0BB7   D6 41                  SUB   "A"   ; "A" = 0
0BB9   18 05                  JR   ident1   
0BBB                LOWCASE:      
0BBB   0A                     LD   a,(bc)   
0BBC   D6 61                  SUB   "a"   
0BBE   C6 1A                  ADD   a,26   
0BC0                IDENT1:      
0BC0   87                     ADD   a,a   ; l = a * 2
0BC1   6F                     LD   l,a   
0BC2   26 23                  LD   h,msb(vars)   
0BC4   22 F6 23               LD   (vPointer),hl   ; store address in setter
0BC7   5E                     LD   e,(hl)   
0BC8   23                     INC   hl   
0BC9   56                     LD   d,(hl)   
0BCA   D5                     PUSH   de   
0BCB   DD E9                  JP   (ix)   
0BCD                             ; if
0BCD                             ; condition then -- value
0BCD                QUESTION:      
0BCD                IF:          
0BCD   03                     INC   bc   
0BCE   0A                     LD   a,(bc)   
0BCF   FE 3F                  CP   "?"   
0BD1   28 06                  JR   z,ifte   
0BD3   0B                     DEC   bc   
0BD4   11 00 00               LD   de,NUL   ; NUL pointer for else
0BD7   18 01                  JR   ifte1   
0BD9                             ; ifte
0BD9                             ; condition then else -- value
0BD9                IFTE:        
0BD9   D1                     POP   de   ; de = else
0BDA                IFTE1:       
0BDA   E1                     POP   hl   ; hl = then
0BDB   E3                     EX   (sp),hl   ; hl = condition, (sp) = then
0BDC   7C                     LD   a,h   
0BDD   B5                     OR   l   
0BDE   E1                     POP   hl   ; hl = then
0BDF   CA FB 0A               JP   z,go1   ; if z de = else
0BE2   EB                     EX   de,hl   ; condition = false, de = then
0BE3   C3 FB 0A               JP   go1   
0BE6                KEY:         
0BE6   CD 81 00               CALL   getchar   
0BE9   26 00                  LD   h,0   
0BEB   6F                     LD   l,a   
0BEC   E5                     PUSH   hl   
0BED   DD E9                  JP   (ix)   
0BEF                             ; Z80 port output
0BEF                             ; value port --
0BEF                OUTPUT:      
0BEF   E1                     POP   hl   
0BF0   59                     LD   e,c   ; save IP
0BF1   4D                     LD   c,l   
0BF2   E1                     POP   hl   
0BF3   ED 69                  OUT   (c),l   
0BF5   4B                     LD   c,e   ; restore IP
0BF6   DD E9                  JP   (ix)   
0BF8                STAR:        
0BF8                MUL:         
0BF8   D1                     POP   de   ; get first value
0BF9   E1                     POP   hl   
0BFA                MUL2:        
0BFA   C5                     PUSH   bc   ; Preserve the IP
0BFB   44 4D                  LD   bc,hl   ; bc = 2nd value
0BFD   21 00 00               LD   hl,0   
0C00   3E 10                  LD   a,16   
0C02                MUL3:        
0C02   29                     ADD   hl,hl   
0C03   CB 13                  RL   e   
0C05   CB 12                  RL   d   
0C07   30 04                  JR   nc,$+6   
0C09   09                     ADD   hl,bc   
0C0A   30 01                  JR   nc,$+3   
0C0C   13                     INC   de   
0C0D   3D                     DEC   a   
0C0E   20 F2                  JR   nz,mul3   
0C10   C1                     POP   bc   ; Restore the IP
0C11   C3 13 02               JP   add3   
0C14                NUM:         
0C14   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
0C17   0A                     LD   a,(bc)   ; Get numeral or -
0C18   FE 2D                  CP   "-"   
0C1A   20 01                  JR   nz,num0   
0C1C   03                     INC   bc   ; move to next char, no flags affected
0C1D                NUM0:        
0C1D   08                     EX   af,af'   ; save zero flag = 0 for later
0C1E                NUM1:        
0C1E   0A                     LD   a,(bc)   ; read digit
0C1F   D6 30                  SUB   "0"   ; less than 0?
0C21   38 13                  JR   c,num2   ; not a digit, exit loop
0C23   FE 0A                  CP   10   ; greater that 9?
0C25   30 0F                  JR   nc,num2   ; not a digit, exit loop
0C27   03                     INC   bc   ; inc IP
0C28   54 5D                  LD   de,hl   ; multiply hl * 10
0C2A   29                     ADD   hl,hl   
0C2B   29                     ADD   hl,hl   
0C2C   19                     ADD   hl,de   
0C2D   29                     ADD   hl,hl   
0C2E   85                     ADD   a,l   ; add digit in a to hl
0C2F   6F                     LD   l,a   
0C30   3E 00                  LD   a,0   
0C32   8C                     ADC   a,h   
0C33   67                     LD   h,a   
0C34   18 E8                  JR   num1   
0C36                NUM2:        
0C36   0B                     DEC   bc   
0C37   08                     EX   af,af'   ; restore zero flag
0C38   20 07                  JR   nz,num3   
0C3A   EB                     EX   de,hl   ; negate the value of hl
0C3B   21 00 00               LD   hl,0   
0C3E   B7                     OR   a   ; jump to sub2
0C3F   ED 52                  SBC   hl,de   
0C41                NUM3:        
0C41   E5                     PUSH   hl   ; Put the number on the stack
0C42   DD E9                  JP   (ix)   ; and process the next character
0C44                RPAREN:      
0C44   FD 4E 08               LD   c,(iy+8)   ; IP = block* just under stack frame
0C47   FD 46 09               LD   b,(iy+9)   
0C4A   DD E9                  JP   (ix)   
0C4C                             ; shiftLeft
0C4C                             ; value count -- value2          shift left count places
0C4C                SHIFTLEFT:      
0C4C   50 59                  LD   de,bc   ; save IP
0C4E   C1                     POP   bc   ; bc = count
0C4F   41                     LD   b,c   ; b = loop counter
0C50   E1                     POP   hl   
0C51   04                     INC   b   ; test for counter=0 case
0C52   18 01                  JR   shiftLeft2   
0C54                SHIFTLEFT1:      
0C54   29                     ADD   hl,hl   ; left shift hl
0C55                SHIFTLEFT2:      
0C55   10 FD                  DJNZ   shiftLeft1   
0C57   E5                     PUSH   hl   
0C58   42 4B                  LD   bc,de   ; restore IP
0C5A   DD E9                  JP   (ix)   
0C5C                             ; shiftRight
0C5C                             ; value count -- value2          shift left count places
0C5C                SHIFTRIGHT:      
0C5C   50 59                  LD   de,bc   ; save IP
0C5E   C1                     POP   bc   ; bc = count
0C5F   41                     LD   b,c   ; b = loop counter
0C60   E1                     POP   hl   
0C61   04                     INC   b   ; test for counter=0 case
0C62   18 04                  JR   shiftRight2   
0C64                SHIFTRIGHT1:      
0C64   CB 3C                  SRL   h   ; right shift hl
0C66   CB 1D                  RR   l   
0C68                SHIFTRIGHT2:      
0C68   10 FA                  DJNZ   shiftRight1   
0C6A   E5                     PUSH   hl   
0C6B   42 4B                  LD   bc,de   ; restore IP
0C6D   DD E9                  JP   (ix)   
0C6F                             ; string
0C6F                             ; -- ptr                        ; points to start of string chars,
0C6F                             ; length is stored at start - 2 bytes
0C6F                DQUOTE:      
0C6F                STRING:      
0C6F   2A F0 23               LD   hl,(vHeapPtr)   ; hl = heap*
0C72   23                     INC   hl   ; skip length field to start
0C73   23                     INC   hl   
0C74   E5                     PUSH   hl   ; save start of string
0C75   03                     INC   bc   ; point to next char
0C76   18 03                  JR   string2   
0C78                STRING1:      
0C78   77                     LD   (hl),a   
0C79   23                     INC   hl   ; increase count
0C7A   03                     INC   bc   ; point to next char
0C7B                STRING2:      
0C7B   0A                     LD   a,(bc)   
0C7C   FE 22                  CP   DQ   ; " is the string terminator
0C7E   28 04                  JR   z,string3   
0C80   FE 60                  CP   "`"   ; ` is the string terminator used in testing
0C82   20 F4                  JR   nz,string1   
0C84                STRING3:      
0C84   AF                     XOR   a   ; write NUL to terminate string
0C85   77                     LD   (hl),a   ; hl = end of string
0C86   23                     INC   hl   
0C87   22 F0 23               LD   (vHeapPtr),hl   ; bump heap* to after end of string
0C8A   2B                     DEC   hl   ; hl = end of string without terminator
0C8B   D1                     POP   de   ; de = start of string
0C8C   D5                     PUSH   de   ; return start of string
0C8D   B7                     OR   a   ; hl = length bytes, de = start of string
0C8E   ED 52                  SBC   hl,de   
0C90   EB                     EX   de,hl   
0C91   2B                     DEC   hl   ; write length bytes to length field at start - 2
0C92   72                     LD   (hl),d   
0C93   2B                     DEC   hl   
0C94   73                     LD   (hl),e   
0C95   DD E9                  JP   (ix)   
0C97                PRINTCHARS1:      
0C97   1A                     LD   a,(de)   ; print char at char*
0C98   CD 85 00               CALL   putchar   
0C9B   13                     INC   de   ; char*++
0C9C   2B                     DEC   hl   ; count--
0C9D                PRINTCHARS2:      
0C9D   7D                     LD   a,l   ; count == 0?
0C9E   B4                     OR   h   
0C9F   C8                     RET   z   
0CA0   18 F5                  JR   printChars1   ; if not loop
0CA2                             ; 
0CA2                             ;*******************************************************************
0CA2                             ; general routines
0CA2                             ;*******************************************************************
0CA2                             ; arg_list - parses arg_list e.g. ab:c
0CA2                             ; -- arg_list*
0CA2                PARSEARGS:      
0CA2   11 00 00               LD   de,0   ; d = count locals, e = count args ()
0CA5   2A F0 23               LD   hl,(vHeapPtr)   ; hl = heap*
0CA8   E5                     PUSH   hl   ; save start of arg_list
0CA9   23                     INC   hl   ; skip length fields to start of string
0CAA   23                     INC   hl   
0CAB   03                     INC   bc   ; point to next char
0CAC                PARSEARGS1:      
0CAC   0A                     LD   a,(bc)   
0CAD   FE 3A                  CP   ":"   ; ":" switches from args to locals
0CAF   20 03                  JR   nz,parseArgs1a   
0CB1   14                     INC   d   ; non zero value local count acts as flag
0CB2   18 10                  JR   parseArgs3   
0CB4                PARSEARGS1A:      
0CB4   FE 61                  CP   "a"   ; < "a" terminates arg_list
0CB6   38 0F                  JR   c,parseArgs4   
0CB8   FE 7B                  CP   "z"+1   ; > "z" terminates arg_list
0CBA   30 0B                  JR   nc,parseArgs4   
0CBC                PARSEARGS2:      
0CBC   77                     LD   (hl),a   
0CBD   23                     INC   hl   
0CBE   1C                     INC   e   ; increase arg count
0CBF   AF                     XOR   a   
0CC0   B2                     OR   d   
0CC1   28 01                  JR   z,parseArgs3   
0CC3   14                     INC   d   ; if d > 0 increase local count
0CC4                PARSEARGS3:      
0CC4   03                     INC   bc   ; point to next char
0CC5   18 E5                  JR   parseArgs1   
0CC7                PARSEARGS4:      
0CC7   0B                     DEC   bc   
0CC8   AF                     XOR   a   
0CC9   B2                     OR   d   
0CCA   28 01                  JR   z,parseArgs5   
0CCC   15                     DEC   d   ; remove initial inc
0CCD                PARSEARGS5:      
0CCD   23                     INC   hl   
0CCE   22 F0 23               LD   (vHeapPtr),hl   ; bump heap* to after end of string
0CD1   E1                     POP   hl   ; hl = start of arg_list
0CD2   72                     LD   (hl),d   ; write number of locals at start - 1
0CD3   23                     INC   hl   
0CD4   73                     LD   (hl),e   ; write number of args + locals at start - 2
0CD5   2B                     DEC   hl   
0CD6   E3                     EX   (sp),hl   
0CD7   E9                     JP   (hl)   
0CD8                             ; create block: parses block e.g. 00bbIC4uLi4g
0CD8                             ; -- block*
0CD8                PARSEBLOCK:      
0CD8   C5                     PUSH   bc   ; return pointer to first { of block
0CD9   03                     INC   bc   
0CDA   16 01                  LD   d,1   ; nesting: count first parenthesis
0CDC                PARSEBLOCK1:      ; Skip to end of definition
0CDC   0A                     LD   a,(bc)   ; Get the next character
0CDD   03                     INC   bc   ; Point to next character
0CDE   FE 21                  CP   " " + 1   ; ignore whitespace
0CE0   38 FA                  JR   c,parseBlock1   
0CE2   FE 29                  CP   ")"   
0CE4   28 2D                  JR   z,parseBlock4   
0CE6   FE 7D                  CP   "}"   
0CE8   28 29                  JR   z,parseBlock4   
0CEA   FE 5D                  CP   "]"   
0CEC   28 25                  JR   z,parseBlock4   
0CEE   FE 28                  CP   "("   
0CF0   28 16                  JR   z,parseBlock2   
0CF2   FE 7B                  CP   "{"   
0CF4   28 12                  JR   z,parseBlock2   
0CF6   FE 5B                  CP   "["   
0CF8   28 0E                  JR   z,parseBlock2   
0CFA   FE 27                  CP   "'"   
0CFC   28 0D                  JR   z,parseBlock3   
0CFE   FE 60                  CP   "`"   
0D00   28 09                  JR   z,parseBlock3   
0D02   FE 22                  CP   DQ   
0D04   28 05                  JR   z,parseBlock3   
0D06   18 D4                  JR   parseBlock1   
0D08                PARSEBLOCK2:      
0D08   14                     INC   d   
0D09   18 D1                  JR   parseBlock1   
0D0B                PARSEBLOCK3:      
0D0B   3E 80                  LD   a,$80   
0D0D   AA                     XOR   d   
0D0E   57                     LD   d,a   
0D0F   20 CB                  JR   nz,parseBlock1   
0D11   18 03                  JR   parseBlock5   
0D13                PARSEBLOCK4:      
0D13   15                     DEC   d   
0D14   20 C6                  JR   nz,parseBlock1   ; get the next element
0D16                PARSEBLOCK5:      
0D16   60 69                  LD   hl,bc   ; hl = IP
0D18   11 20 24               LD   de,HEAP   ; is IP pointing to object in heap
0D1B   B7                     OR   a   ; IP - HEAP
0D1C   ED 52                  SBC   hl,de   
0D1E   CB 7C                  BIT   7,h   ; if -ve then copy to heap else skip
0D20   28 1C                  JR   z,parseBlock6   
0D22   60 69                  LD   hl,bc   ; hl = IP
0D24   D1                     POP   de   ; de = block*
0D25   ED 43 02 24            LD   (vTemp1),bc   ; save IP
0D29   B7                     OR   a   ; bc = size
0D2A   ED 52                  SBC   hl,de   
0D2C   44 4D                  LD   bc,hl   
0D2E   EB                     EX   de,hl   ; hl = block* de = heap*
0D2F   ED 5B F0 23            LD   de,(vHeapPtr)   
0D33   D5                     PUSH   de   ; return hblock*
0D34   ED B0                  LDIR      ; copy size bytes from block* to hblock*
0D36   ED 53 F0 23            LD   (vHeapPtr),de   ; heap* += size
0D3A   ED 4B 02 24            LD   bc,(vTemp1)   ; restore IP
0D3E                PARSEBLOCK6:      
0D3E   0B                     DEC   bc   ; balanced, exit
0D3F   E1                     POP   hl   ; hl = block*
0D40   E3                     EX   (sp),hl   ; return to caller
0D41   E9                     JP   (hl)   
0D42                             ; create function
0D42                             ; arg_list* block* -- func*
0D42                CREATEFUNC:      
0D42   E1                     POP   hl   ; save retrn address
0D43   22 06 24               LD   (vTemp3),hl   
0D46   ED 43 02 24            LD   (vTemp1),bc   ; save IP
0D4A   E1                     POP   hl   ; hl = block*
0D4B   22 04 24               LD   (vTemp2),hl   ; save block*
0D4E   FD 5E 04               LD   e,(iy+4)   ; de = outer_arg_list
0D51   FD 56 05               LD   d,(iy+5)   
0D54   7B                     LD   a,e   ; if arg_list == null then make a func
0D55   B2                     OR   d   
0D56   20 09                  JR   nz,createFunc0   
0D58   21 00 00               LD   hl,0   ; partial_array = null
0D5B   ED 5B F0 23            LD   de,(vHeapPtr)   ; de = compile*
0D5F   18 65                  JR   createFunc5   
0D61                CREATEFUNC0:      
0D61   E1                     POP   hl   ; hl = inner_arg_list*
0D62   E5                     PUSH   hl   ; save inner_arg_list
0D63   ED 5B F0 23            LD   de,(vHeapPtr)   ; de = compile*
0D67   7E                     LD   a,(hl)   ; compile inner_num_locals
0D68   4F                     LD   c,a   ; b = inner_num_locals
0D69   12                     LD   (de),a   
0D6A   23                     INC   hl   
0D6B   13                     INC   de   
0D6C   7E                     LD   a,(hl)   ; compile inner_length
0D6D   12                     LD   (de),a   
0D6E   91                     SUB   c   ; a = inner_num args
0D6F   23                     INC   hl   
0D70   13                     INC   de   
0D71   B7                     OR   a   ; compile args if inner_length > 0
0D72   28 05                  JR   z,createFunc1   
0D74   4F                     LD   c,a   ; bc = a
0D75   06 00                  LD   b,0   
0D77   ED B0                  LDIR      
0D79                CREATEFUNC1:      
0D79   EB                     EX   de,hl   ; hl = outer_arg_list
0D7A   FD 5E 04               LD   e,(iy+4)   
0D7D   FD 56 05               LD   d,(iy+5)   
0D80   EB                     EX   de,hl   
0D81   23                     INC   hl   ; a = outer_length
0D82   7E                     LD   a,(hl)   
0D83   23                     INC   hl   
0D84   B7                     OR   a   
0D85   28 05                  JR   z,createFunc2   
0D87   4F                     LD   c,a   
0D88   06 00                  LD   b,0   
0D8A   ED B0                  LDIR      ; append outer_args
0D8C                CREATEFUNC2:      ; a = outer_length
0D8C   47                     LD   b,a   ; b = a = outer_length
0D8D   2A F0 23               LD   hl,(vHeapPtr)   ; b > 0, hl = start of cloned arg_list
0D90   23                     INC   hl   
0D91   7E                     LD   a,(hl)   ; add outer_length to new length
0D92   80                     ADD   a,b   
0D93   77                     LD   (hl),a   
0D94   2B                     DEC   hl   
0D95   78                     LD   a,b   ; save outer_length in a'
0D96   08                     EX   af,af'   
0D97   E3                     EX   (sp),hl   ; hl = inner_arg_list*, (sp) new_arg_list
0D98   7E                     LD   a,(hl)   ; c = a = inner_num_locals
0D99   B7                     OR   a   
0D9A   28 0F                  JR   z,createFunc2a   ; if inner_num_locals == 0 skip
0D9C   4F                     LD   c,a   ; c = inner_num_locals
0D9D   06 00                  LD   b,0   ; bc = inner_num_locals
0D9F   23                     INC   hl   ; a = inner_length
0DA0   7E                     LD   a,(hl)   
0DA1   91                     SUB   c   ; a = inner_num_args
0DA2   23                     INC   hl   ; hl = inner_arg_chars
0DA3   85                     ADD   a,l   ; hl += a
0DA4   6F                     LD   l,a   
0DA5   3E 00                  LD   a,0   
0DA7   84                     ADD   a,h   
0DA8   67                     LD   h,a   
0DA9   ED B0                  LDIR      ; append inner_locals
0DAB                CREATEFUNC2A:      
0DAB   08                     EX   af,af'   ; restore outer_length to a, de = partial_array[-2]
0DAC   12                     LD   (de),a   ; compile partial_array length field
0DAD   13                     INC   de   
0DAE   AF                     XOR   a   
0DAF   12                     LD   (de),a   
0DB0   13                     INC   de   
0DB1   D5                     PUSH   de   ; push partial_array*
0DB2   EB                     EX   de,hl   ; hl = first_arg, copy outer_args+locals to partial_array
0DB3   FD 5E 02               LD   e,(iy+2)   
0DB6   FD 56 03               LD   d,(iy+3)   
0DB9   EB                     EX   de,hl   
0DBA                CREATEFUNC3:      
0DBA   2B                     DEC   hl   ; c = MSB of arg from stack (incl. locals)
0DBB   4E                     LD   c,(hl)   
0DBC   2B                     DEC   hl   
0DBD   7E                     LD   a,(hl)   ; a = LSB of arg from stack (incl. locals)
0DBE   12                     LD   (de),a   ; write LSB and MSB to partial_array*
0DBF   13                     INC   de   
0DC0   79                     LD   a,c   
0DC1   12                     LD   (de),a   
0DC2   13                     INC   de   
0DC3   10 F5                  DJNZ   createFunc3   ; b = outer_length
0DC5                CREATEFUNC4:      
0DC5   E1                     POP   hl   ; hl = partial_array*
0DC6                CREATEFUNC5:      
0DC6   C1                     POP   bc   ; bc = new_arg_list*
0DC7   D5                     PUSH   de   ; return new func*
0DC8   EB                     EX   de,hl   ; hl = new func*, de = partial_array*
0DC9   73                     LD   (hl),e   ; compile partial_array* to func
0DCA   23                     INC   hl   
0DCB   72                     LD   (hl),d   
0DCC   23                     INC   hl   
0DCD   ED 5B 04 24            LD   de,(vTemp2)   ; de = block*
0DD1   73                     LD   (hl),e   ; compile block* to func
0DD2   23                     INC   hl   
0DD3   72                     LD   (hl),d   
0DD4   23                     INC   hl   
0DD5   71                     LD   (hl),c   ; compile new_arg_list* to func
0DD6   23                     INC   hl   
0DD7   70                     LD   (hl),b   
0DD8   23                     INC   hl   
0DD9   22 F0 23               LD   (vHeapPtr),hl   ; bump heap ptr
0DDC   ED 4B 02 24            LD   bc,(vTemp1)   ; restore IP
0DE0   2A 06 24               LD   hl,(vTemp3)   ; jump to return address
0DE3   E9                     JP   (hl)   
0DE4                             ; prints whatever in in buffer starting from BUF and ending at vBufPtr*
0DE4                FLUSHBUFFER:      
0DE4   F5                     PUSH   af   
0DE5   D5                     PUSH   de   
0DE6   E5                     PUSH   hl   
0DE7   2A EC 23               LD   hl,(vBufPtr)   
0DEA   11 00 22               LD   de,BUF   
0DED   ED 53 EC 23            LD   (vBufPtr),de   
0DF1   B7                     OR   a   
0DF2   ED 52                  SBC   hl,de   
0DF4   CD 9D 0C               CALL   printChars2   
0DF7   E1                     POP   hl   
0DF8   D1                     POP   de   
0DF9   F1                     POP   af   
0DFA   C9                     RET      
0DFB                COMMANDTABLE:      
0DFB   03                     INC   bc   
0DFC   0A                     LD   a,(bc)   
0DFD   FE 7B                  CP   "z"+1   
0DFF   30 09                  JR   nc,commandTable2   
0E01   D6 61                  SUB   "a"   
0E03   38 05                  JR   c,commandTable2   
0E05                COMMANDTABLE1:      
0E05   E1                     POP   hl   
0E06   85                     ADD   a,l   
0E07   6F                     LD   l,a   
0E08   6E                     LD   l,(hl)   ; must have the same msb as the table
0E09   E9                     JP   (hl)   
0E0A                COMMANDTABLE2:      
0E0A   3E 1A                  LD   a,26   
0E0C   0B                     DEC   bc   
0E0D   18 F6                  JR   commandTable1   
0E0F                             ; followed by a table
0E0F                             ; db char
0E0F                             ; db lsb(addr)
0E0F                             ; the final item must have char == NUL
0E0F                JUMPTABLE:      
0E0F   E1                     POP   hl   
0E10   03                     INC   bc   
0E11                JUMPTABLE0:      
0E11   AF                     XOR   a   
0E12   BE                     CP   (hl)   
0E13   28 0B                  JR   z,jumpTable2   
0E15   0A                     LD   a,(bc)   
0E16   BE                     CP   (hl)   
0E17   28 04                  JR   z,jumpTable1   
0E19   23                     INC   hl   
0E1A   23                     INC   hl   
0E1B   18 F4                  JR   jumpTable0   
0E1D                JUMPTABLE1:      
0E1D   23                     INC   hl   
0E1E   6E                     LD   l,(hl)   ; must have the same msb as the table
0E1F   E9                     JP   (hl)   
0E20                JUMPTABLE2:      
0E20   0B                     DEC   bc   
0E21   23                     INC   hl   
0E22   E9                     JP   (hl)   
0E23                PRTSTR0:      
0E23   CD 85 00               CALL   putchar   
0E26   23                     INC   hl   
0E27                PRTSTR:      
0E27   7E                     LD   a,(hl)   
0E28   B7                     OR   a   
0E29   20 F8                  JR   nz,prtstr0   
0E2B   C9                     RET      
0E2C                             ; **************************************************************************
0E2C                             ; calculate nesting value
0E2C                             ; a is char to be tested,
0E2C                             ; e is the nesting value (initially 0)
0E2C                             ; e is increased by ( and [
0E2C                             ; e is decreased by ) and ]
0E2C                             ; e has its bit 7 toggled by `
0E2C                             ; limited to 127 levels
0E2C                             ; **************************************************************************
0E2C                NESTING:      
0E2C   FE 22                  CP   DQ   ; quote char
0E2E   28 06                  JR   z,nesting0   
0E30   FE 60                  CP   "`"   ; quote char
0E32   28 02                  JR   z,nesting0   
0E34   18 0A                  JR   nesting1   
0E36                NESTING0:      
0E36   CB 7B                  BIT   7,e   
0E38   28 03                  JR   z,nesting1a   
0E3A   CB BB                  RES   7,e   
0E3C   C9                     RET      
0E3D                NESTING1A:      
0E3D   CB FB                  SET   7,e   
0E3F   C9                     RET      
0E40                NESTING1:      
0E40   CB 7B                  BIT   7,e   
0E42   C0                     RET   nz   
0E43   FE 7B                  CP   "{"   
0E45   28 08                  JR   z,nesting2   
0E47   FE 5B                  CP   "["   
0E49   28 04                  JR   z,nesting2   
0E4B   FE 28                  CP   "("   
0E4D   20 02                  JR   nz,nesting3   
0E4F                NESTING2:      
0E4F   1C                     INC   e   
0E50   C9                     RET      
0E51                NESTING3:      
0E51   FE 7D                  CP   "}"   
0E53   28 07                  JR   z,nesting4   
0E55   FE 5D                  CP   "]"   
0E57   28 03                  JR   z,nesting4   
0E59   FE 29                  CP   ")"   
0E5B   C0                     RET   nz   
0E5C                NESTING4:      
0E5C   1D                     DEC   e   
0E5D   C9                     RET      
0E5E                PROMPT:      
0E5E   CD 6E 0E               CALL   printStr   
0E61   0D 0A 3E 20 00         .CSTR   "\r\n> "   
0E66   C9                     RET      
0E67                CRLF:        
0E67   CD 6E 0E               CALL   printStr   
0E6A   0D 0A 00               .CSTR   "\r\n"   
0E6D   C9                     RET      
0E6E                             ; prints a null teminated string
0E6E                             ; the string should be immediately following the call
0E6E                PRINTSTR:      
0E6E   E3                     EX   (sp),hl   ; swap			
0E6F   CD 27 0E               CALL   prtstr   
0E72   23                     INC   hl   ; inc past NUL
0E73   E3                     EX   (sp),hl   ; put it back	
0E74   C9                     RET      
0E75                INIT:        
0E75   21 F0 01               LD   hl,titleStr   
0E78   11 0C 24               LD   de,titleBuf   
0E7B   06 14                  LD   b,20   
0E7D                INIT1:       
0E7D   1A                     LD   a,(de)   
0E7E   BE                     CP   (hl)   
0E7F   20 17                  JR   nz,coldBoot0   
0E81   13                     INC   de   
0E82   23                     INC   hl   
0E83   10 F8                  DJNZ   init1   
0E85                WARMINIT:      
0E85   ED 4B FA 23            LD   bc,(vSavedIP)   ; restore IP
0E89   ED 7B FC 23            LD   sp,(vSavedSP)   ; restore SP
0E8D   DD 2A FE 23            LD   ix,(vSavedNext)   ; restore Next
0E91   FD 2A 00 24            LD   iy,(vSavedBP)   ; restore BP
0E95   C3 CF 0E               JP   start1   
0E98                COLDBOOT0:      
0E98   21 F0 01               LD   hl,titleStr   ; copy titleStr to titleBuf
0E9B   11 0C 24               LD   de,titleBuf   
0E9E   06 14                  LD   b,20   
0EA0   ED B0                  LDIR      
0EA2                COLDINIT:      
0EA2   21 DE 01               LD   hl,isysVars   
0EA5   11 E6 23               LD   de,sysVars   
0EA8   01 10 00               LD   bc,8 * 2   
0EAB   ED B0                  LDIR      
0EAD   21 00 23               LD   hl,vars   ; 52 vars LO HI
0EB0   06 34                  LD   b,26*2   
0EB2   AF                     XOR   a   
0EB3                COLDBOOT1:      
0EB3   77                     LD   (hl),a   
0EB4   23                     INC   hl   
0EB5   10 FC                  DJNZ   coldBoot1   
0EB7   DD 2A EE 23            LD   ix,(vNext)   
0EBB   FD 21 00 21            LD   iy,STACK   
0EBF   C9                     RET      
0EC0                COLDSTART:      
0EC0   31 00 21               LD   sp,STACK   
0EC3   CD 98 0E               CALL   coldBoot0   
0EC6   C3 CF 0E               JP   start1   
0EC9                START:       
0EC9   31 00 21               LD   sp,STACK   ; start Monty
0ECC   CD 75 0E               CALL   init   ; setups
0ECF                START1:      
0ECF   21 0C 24               LD   hl,titleBuf   
0ED2   CD 27 0E               CALL   prtstr   ; prog count to stack, put code line 235 on stack then call print
0ED5                INTERPRET:      
0ED5   CD E4 0D               CALL   flushBuffer   
0ED8   CD 5E 0E               CALL   prompt   
0EDB   01 00 00               LD   bc,0   ; load TIB length, decide char into tib or execute or control
0EDE   21 00 21               LD   hl,TIB   
0EE1   22 EA 23               LD   (vTIBPtr),hl   ; no chars in TIB so set end pointer to beginning
0EE4                INTERPRET2:      ; calculate nesting
0EE4   1E 00                  LD   e,0   ; initilize nesting value
0EE6   C5                     PUSH   bc   ; save offset into TIB,
0EE7                             ; bc is also the count of chars in TIB
0EE7   21 00 21               LD   hl,TIB   ; hl is start of TIB
0EEA   18 0B                  JR   interpret4   
0EEC                INTERPRET3:      
0EEC   3E 33                  LD   a,"3"   
0EEE   CD 85 00               CALL   putchar   
0EF1   7E                     LD   a,(hl)   ; a = char in TIB
0EF2   23                     INC   hl   ; inc pointer into TIB
0EF3   0B                     DEC   bc   ; dec count of chars in TIB
0EF4   CD 2C 0E               CALL   nesting   ; update nesting value
0EF7                INTERPRET4:      
0EF7   79                     LD   a,c   ; is count zero?
0EF8   B0                     OR   b   
0EF9   20 F1                  JR   nz,interpret3   ; if not loop
0EFB   C1                     POP   bc   ; restore offset into TIB
0EFC                INTERPRET5:      
0EFC   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
0EFF   FE 20                  CP   $20   ; compare to space
0F01   30 19                  JR   nc,interpret6   ; if >= space, if below 20 set cary flag
0F03   FE 00                  CP   NUL   ; is it end of string? NUL end of string
0F05                             ; ???? NEEDED?
0F05   28 36                  JR   z,interpret8   
0F07   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0F09   28 1F                  JR   z,interpret7   ; if anything else its macro/control
0F0B   FE 05                  CP   CTRL_E   
0F0D   CA 9B 0F               JP   z,edit_   
0F10   FE 08                  CP   CTRL_H   
0F12   CA 8B 0F               JP   z,backSpace_   
0F15   FE 0A                  CP   CTRL_J   
0F17   CA B3 0F               JP   z,reEdit_   
0F1A                             ; cp CTRL_S
0F1A                             ; jp z,printStack_
0F1A                             ; DB     lsb(edit_)       ; ENQ ^E  5
0F1A                             ; DB     lsb(reedit_)     ; LF  ^J 10
0F1A                             ; DB     lsb(list_)       ; FF  ^L 12
0F1A                             ; DB     lsb(printStack_) ; DLE ^P 16
0F1A                             ; DB lsb(depth_)      ;\#3    ( -- val )    depth of data stack
0F1A                             ; DB lsb(printStack_)   ;\#4    ( -- )        non-destructively prints stack
0F1A                             ; DB lsb(prompt_)     ;\#5    ( -- )        print MINT prompt
0F1A                             ; DB lsb(editDef_)    ;\#6    ( char -- )   edit command
0F1A                             ; DB lsb(aDup_)       ;\#7    ( adr -- )    dupe (used in asm tests)
0F1A                             ; DB     lsb(newln_)      ;a4    \$  prints a newline to output	
0F1A                             ; reedit_: DB "\\e\\@\\#6;"			; lastDef, edit. remembers last line edited
0F1A                             ; edit_: .cstr "`?`?\\#5\\#6;"      ; ?,key,prompt,edit
0F1A                             ; list_: .cstr "\\$26(\\i@65+\\#6\\c@0>(\\$))\\#5;" newln, loop 26 (index + "A", edit tib* > 0, newln),prompt
0F1A                             ; printStack_: .cstr "\\#4\\#5;"  ; print stack, prompt
0F1A                INTERPRET5A:      
0F1A                             ; ld (vTIBPtr),bc
0F1A                             ; ld bc,(vTIBPtr)
0F1A   18 C8                  JR   interpret2   
0F1C                INTERPRET6:      
0F1C   21 00 21               LD   hl,TIB   
0F1F   09                     ADD   hl,bc   
0F20   77                     LD   (hl),a   ; store the character in textbuf
0F21   03                     INC   bc   
0F22   CD 85 00               CALL   putchar   ; echo character to screen
0F25   CD 2C 0E               CALL   nesting   
0F28   18 D2                  JR   interpret5   ; wait for next character
0F2A                INTERPRET7:      
0F2A   21 00 21               LD   hl,TIB   
0F2D   09                     ADD   hl,bc   
0F2E   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
0F30   23                     INC   hl   
0F31   36 0A                  LD   (hl),"\n"   
0F33   23                     INC   hl   
0F34   03                     INC   bc   
0F35   03                     INC   bc   
0F36   CD 67 0E               CALL   crlf   ; echo character to screen
0F39   7B                     LD   a,e   ; if zero nesting append and ETX after \r
0F3A   B7                     OR   a   
0F3B   20 BF                  JR   nz,interpret5   
0F3D                INTERPRET8:      
0F3D   21 00 21               LD   hl,TIB   
0F40   09                     ADD   hl,bc   
0F41   22 EA 23               LD   (vTIBPtr),hl   
0F44   01 00 21               LD   bc,TIB   
0F47   ED 43 FA 23            LD   (vSavedIP),bc   ; save IP
0F4B   ED 73 FC 23            LD   (vSavedSP),sp   ; save SP
0F4F   DD 22 FE 23            LD   (vSavedNext),ix   ; save Next
0F53   FD 22 00 24            LD   (vSavedBP),iy   ; save BP
0F57   0B                     DEC   bc   
0F58                NEXT:        
0F58   03                     INC   bc   ; Increment the IP
0F59   0A                     LD   a,(bc)   ; Get the next character and dispatch
0F5A   FE 20                  CP   " "   ; whitespace?
0F5C   28 FA                  JR   z,next   ; space? ignore
0F5E   38 08                  JR   c,next1   
0F60   C6 5F                  ADD   a,$80 - "!"   ; subtract "!", add $80 (opcodes lsb starts at $80)
0F62   6F                     LD   l,a   ; index into table
0F63   26 01                  LD   h,msb(opcodes)   ; start address of jump table
0F65   6E                     LD   l,(hl)   ; get low jump address
0F66   24                     INC   h   ; Load h with page after opcodes
0F67   E9                     JP   (hl)   ; Jump to routine
0F68                NEXT1:       
0F68   FE 00                  CP   NUL   ; end of input string?
0F6A   28 03                  JR   z,exit   
0F6C   C3 D5 0E               JP   interpret   ; no, other whitespace, macros?
0F6F                EXIT:        
0F6F   03                     INC   bc   
0F70   60 69                  LD   hl,bc   
0F72   E9                     JP   (hl)   
0F73                RUN:         
0F73   C1                     POP   bc   
0F74   0B                     DEC   bc   
0F75   DD E9                  JP   (ix)   
0F77                ERROR:       
0F77   E5                     PUSH   hl   
0F78   CD 73 0F               CALL   run   
0F7B   60 45 72 72 6F 72 20 60 2E 73 20 2E 00 DB   "`Error `.s .",0   
0F88   C3 D5 0E               JP   interpret   
0F8B                BACKSPACE_:      
0F8B   79                     LD   a,c   
0F8C   B0                     OR   b   
0F8D   CA E4 0E               JP   z,interpret2   
0F90   0B                     DEC   bc   
0F91   CD 6E 0E               CALL   printStr   
0F94   08 20 08 00            .CSTR   "\b \b"   
0F98   C3 E4 0E               JP   interpret2   
0F9B                             ; edit
0F9B                EDIT_:       
0F9B   CD 73 0F               CALL   run   
0F9E   60 76 61 72 3F 60 2E 73 20 2F 6B 2F 61 64 20 2E 68 00 DB   "`var?`.s /k/ad .h",0   
0FB0   C3 D5 0E               JP   interpret   
0FB3                REEDIT_:      
0FB3   C3 D5 0E               JP   interpret   
0FB6                PRINTSTACK_:      
0FB6   CD 73 0F               CALL   run   
0FB9   2F 70 6B 00            .CSTR   "/pk"   
0FBD   C3 D5 0E               JP   interpret   
0FC0                             ; editDef:
0FC0                             ;     pop hl                      ; pop ret address
0FC0                             ;     ex (sp),hl                  ; swap with TOS
0FC0                             ;     push hl                     ; dup TOS
0FC0                             ;     ld a,l                      ; a = ident
0FC0                             ;     ld de,TIB                   ; de = start of TIB
0FC0                             ;     ld (vTIBPtr),de             ; update TIB*
0FC0                             ;     push ix                     ; save NEXT
0FC0                             ;     ld ix,editDef0              ; NEXT = editDef0
0FC0                             ;     jp lookupRef                ; convert letter into address
0FC0                             ; editDef0:
0FC0                             ;     ld e,(hl)                   ; de = (hl++)
0FC0                             ;     inc hl
0FC0                             ;     ld d,(hl)
0FC0                             ;     ld a,d                      ; de == 0 ?
0FC0                             ;     or e
0FC0                             ;     jr z,editDef4
0FC0                             ;     ld ix,editDef3              ; NEXT = editDef3
0FC0                             ;     ex de,hl
0FC0                             ;     ld a,(hl)
0FC0                             ;     cp "{"
0FC0                             ;     jr nz,editDef1
0FC0                             ;     jp editBlock0               ; convert letter into address
0FC0                             ; editDef1:
0FC0                             ;     cp "("
0FC0                             ;     jr nz,editDef2
0FC0                             ;     jp editBlock0               ; convert letter into address
0FC0                             ; editDef2:
0FC0                             ;     jp editFunc
0FC0                             ; editDef3:
0FC0                             ;     ld a," "                    ; write assign
0FC0                             ;     call writeChar
0FC0                             ;     pop hl                      ; a = ident
0FC0                             ;     ld a,l
0FC0                             ;     call writeChar
0FC0                             ;     ld a,"="                    ; write assign
0FC0                             ;     call writeChar
0FC0                             ;     ld ix,editDef4              ; NEXT = editDef4
0FC0                             ;     jp printTIB
0FC0                             ; editDef4:
0FC0                             ;     pop ix                      ; restore NEXT
0FC0                             ;     jp (ix)
0FC0                             ; writeChar:
0FC0                             ;     ld de,(vTIBPtr)             ; de = TIB*
0FC0                             ;     ld (de),a                   ; write ident
0FC0                             ;     inc de
0FC0                             ;     ld (vTIBPtr),de             ; update TIB* to point to end of string
0FC0                             ;     ret
0FC0                             ; ; printTIB
0FC0                             ; printTIB:
0FC0                             ;     ld hl,(vTIBPtr)
0FC0                             ;     ld de,TIB
0FC0                             ;     or a
0FC0                             ;     sbc hl,de
0FC0                             ;     jp printTIB2
0FC0                             ; printTIB1:
0FC0                             ;     ld a,(de)
0FC0                             ;     call putchar
0FC0                             ; printTIB2:
0FC0                             ;     ld a,l
0FC0                             ;     or h
0FC0                             ;     jr nz,printTIB1
0FC0                             ;     jp (ix)
0FC0                             ; editBlock:
0FC0                             ;     pop hl                      ; hl = block*
0FC0                             ; editBlock0:
0FC0                             ;     push ix                     ; save next
0FC0                             ;     push hl                     ; push block*
0FC0                             ;     push hl                     ; push block*
0FC0                             ;     ld ix,(editBlock2)
0FC0                             ;     jp blockLength
0FC0                             ; editBlock1:
0FC0                             ;     pop hl                      ; bc = length, (sp) = IP
0FC0                             ;     pop de                      ; de = block*
0FC0                             ;     ld a,l
0FC0                             ;     or h
0FC0                             ;     jr z,editBlock2
0FC0                             ;     push bc
0FC0                             ;     ld bc,hl
0FC0                             ;     ex de,hl                    ; hl = block*
0FC0                             ;     ld de,(vTIBPtr)              ; de = TIB*
0FC0                             ;     ldir                        ; copy block to TIB
0FC0                             ;     ld (vTIBPtr),de              ; save TIB*
0FC0                             ;     pop bc
0FC0                             ; editBlock2:
0FC0                             ;     pop ix                      ; restore next
0FC0                             ;     jp (ix)
0FC0                             ; editFunc:
0FC0                             ;     jp (ix)
0FC0                             ; editArray:
0FC0                             ;     jp (ix)
0FC0                             ; editparseArgs:
0FC0                             ;     jp (ix)
0FC0                             ; ; blockLength
0FC0                             ; ; addr1 -- length
0FC0                             ; blockLength:
0FC0                             ;     pop hl                      ; block*
0FC0                             ;     push hl                     ; save block*
0FC0                             ;     inc hl                      ; skip first char
0FC0                             ;     ld d,1                      ; increase nesting
0FC0                             ; blockLength1:                   ; Skip to end of definition
0FC0                             ;     ld a,(hl)                   ; Get the next character
0FC0                             ;     inc hl                      ; Point to next character
0FC0                             ;     cp " " + 1                  ; ignore whitespace
0FC0                             ;     jr c,blockLength1
0FC0                             ;     cp ")"
0FC0                             ;     jr z,blockLength4
0FC0                             ;     cp "}"
0FC0                             ;     jr z,blockLength4
0FC0                             ;     cp "]"
0FC0                             ;     jr z,blockLength4
0FC0                             ;     cp "("
0FC0                             ;     jr z,blockLength2
0FC0                             ;     cp "{"
0FC0                             ;     jr z,blockLength2
0FC0                             ;     cp "["
0FC0                             ;     jr z,blockLength2
0FC0                             ;     cp "'"
0FC0                             ;     jr z,blockLength3
0FC0                             ;     cp "`"
0FC0                             ;     jr z,blockLength3
0FC0                             ;     cp DQ
0FC0                             ;     jr z,blockLength3
0FC0                             ;     jr blockLength1
0FC0                             ; blockLength2:
0FC0                             ;     inc d
0FC0                             ;     jr blockLength1
0FC0                             ; blockLength4:
0FC0                             ;     dec d
0FC0                             ;     jr nz, blockLength1         ; get the next element
0FC0                             ; blockLength3:
0FC0                             ;     ld a,$80
0FC0                             ;     xor d
0FC0                             ;     ld d,a
0FC0                             ;     jr nz, blockLength1
0FC0                             ;     pop hl                      ; hl = block*
0FC0                             ;     or a
0FC0                             ;     sbc hl,de
0FC0                             ;     push hl
0FC0                             ;     jp (ix)
0FC0                             ; "`=> `\\a@2-\\#3 1-(",$22,"@\\b@(,)(.)2-)'\\$"
0FC0                             ; \a start of stack \#3 depth \b base \$ prompt
0FC0                             ; DW dStack               ; a vS0 start of datastack			
0FC0                             ; DW FALSE                ; b vBase16
0FC0                             ; DW 0                    ; c vTIBPtr an offset to the tib
0FC0                             ; DW 0                    ; d
0FC0                             ; DW 65                   ; e vLastDef "A" last command u defined
0FC0                             ; DW 0                    ; f
0FC0                             ; DW page6                ; g 256 bytes limits
0FC0                             ; DW HEAP                 ; h vHeapPtr \h start of the free mem
0FC0                F1:          
0FC0                F2:          
0FC0                F3:          
0FC0                F4:          
0FC0                             ; 
2000                          .ORG   RAMSTART   
2000                STKSIZE:   EQU   $100   ; Stack size
2000                TIBSIZE:   EQU   $100   ; 256 bytes
2000                BUFSIZE:   EQU   $100   ; 256 bytes, wraps
2000                          ALIGN   $100   
2000                          DS   STKSIZE   
2100                STACK:       
2100                          ALIGN   $100   
2100                TIB:      DS   TIBSIZE   ; must be one page, lsb of vTIBPtr is length and wraps around
2200                          ALIGN   $100   
2200                BUF:      DS   BUFSIZE   ; must be one page, lsb of vBufPtr is length and wraps around
2300                          ALIGN   $100   
2300                VARS:        
2300                          DS   26 * 2 * 4   ; 52 vars, 3 bytes, RST LO HI CHAR
23D0                RESTARTS:      
23D0                RST08:    DS   2   
23D2                RST10:    DS   2   
23D4                RST18:    DS   2   
23D6                RST20:    DS   2   
23D8                RST28:    DS   2   
23DA                RST30:    DS   2   ; 
23DC                BAUD:     DS   2   ; 
23DE                INTVEC:   DS   2   ; 
23E0                NMIVEC:   DS   2   ; 
23E2                GETCVEC:   DS   2   ; 
23E4                PUTCVEC:   DS   2   ; 
23E6                SYSVARS:      
23E6                             ; initialised sys variables (preserved)
23E6                VDATAWIDTH:   DS   2   ; 
23E8                VNUMBASE:   DS   2   ; 
23EA                VTIBPTR:   DS   2   ; 
23EC                VBUFPTR:   DS   2   ; 
23EE                VNEXT:    DS   2   ; 
23F0                VHEAPPTR:   DS   2   ; 
23F2                VRECUR:   DS   2   ; 
23F4                VDEFINE:   DS   2   ; 
23F6                             ; uninitialised sys variables (preserved)
23F6                VPOINTER:   DS   2   ; 
23F8                VREMAIN:   DS   2   ; 
23FA                VSAVEDIP:   DS   2   ; 
23FC                VSAVEDSP:   DS   2   ; 
23FE                VSAVEDNEXT:   DS   2   ; 
2400                VSAVEDBP:   DS   2   ; 
2402                             ; uninitialised sys variables (unpreserved)
2402                VTEMP1:   DS   2   ; 
2404                VTEMP2:   DS   2   ; 
2406                VTEMP3:   DS   2   ; 
2408                VLASTDEF:   DS   2   ; 
240A                TBPTR:    DS   2   ; reserved for tests
240C                TITLEBUF:   DS   20   
2420                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 112 IN IOSerial.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 126 IN IOSerial.asm
                    > USED AT LINE 133 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 153 IN IOSerial.asm
                    > USED AT LINE 195 IN IOSerial.asm
                    > USED AT LINE 48 IN MAIN.asm
RAMSTART:           2000 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 15
ROMSIZE:            2000 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            2000 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
                    > USED AT LINE 493 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 317 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 321 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 27 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 158 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 182 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 186 IN IOSerial.asm
                    > USED AT LINE 188 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 299 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 300 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 303 IN IOSerial.asm
                    > USED AT LINE 307 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 315 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 316 IN IOSerial.asm
                    > USED AT LINE 320 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 1700 IN MAIN.asm
                    > USED AT LINE 2336 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 1857 IN MAIN.asm
                    > USED AT LINE 2173 IN MAIN.asm
                    > USED AT LINE 2320 IN MAIN.asm
                    > USED AT LINE 2382 IN MAIN.asm
RESET:              008B DEFINED AT LINE 450 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 337 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 342 IN MAIN.asm
NUL:                0000 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
                    > USED AT LINE 445 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
                    > USED AT LINE 461 IN MAIN.asm
                    > USED AT LINE 471 IN MAIN.asm
                    > USED AT LINE 478 IN MAIN.asm
                    > USED AT LINE 500 IN MAIN.asm
                    > USED AT LINE 658 IN MAIN.asm
                    > USED AT LINE 701 IN MAIN.asm
                    > USED AT LINE 715 IN MAIN.asm
                    > USED AT LINE 732 IN MAIN.asm
                    > USED AT LINE 755 IN MAIN.asm
                    > USED AT LINE 802 IN MAIN.asm
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 34
                    > USED AT LINE 1071 IN MAIN.asm
                    > USED AT LINE 1683 IN MAIN.asm
                    > USED AT LINE 2339 IN MAIN.asm
                    > USED AT LINE 2427 IN MAIN.asm
DQ:                 0022 DEFINED AT LINE 19 IN MAIN.asm
                    > USED AT LINE 1834 IN MAIN.asm
                    > USED AT LINE 1950 IN MAIN.asm
                    > USED AT LINE 2192 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 20 IN MAIN.asm
CTRL_E:             0005 DEFINED AT LINE 21 IN MAIN.asm
                    > USED AT LINE 2345 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 22 IN MAIN.asm
                    > USED AT LINE 2347 IN MAIN.asm
CTRL_J:             000A DEFINED AT LINE 23 IN MAIN.asm
                    > USED AT LINE 2349 IN MAIN.asm
CTRL_L:             000C DEFINED AT LINE 24 IN MAIN.asm
CTRL_P:             0010 DEFINED AT LINE 25 IN MAIN.asm
CTRL_S:             0013 DEFINED AT LINE 26 IN MAIN.asm
OPCODES:            0180 DEFINED AT LINE 52 IN MAIN.asm
ISYSVARS:           01DE DEFINED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 2273 IN MAIN.asm
TITLESTR:           01F0 DEFINED AT LINE 168 IN MAIN.asm
                    > USED AT LINE 2248 IN MAIN.asm
                    > USED AT LINE 2267 IN MAIN.asm
PLUS_:              0204 DEFINED AT LINE 173 IN MAIN.asm
ADD:                0204 DEFINED AT LINE 174 IN MAIN.asm
ADD1:               020F DEFINED AT LINE 182 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
ADD3:               0213 DEFINED AT LINE 187 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
                    > USED AT LINE 1370 IN MAIN.asm
                    > USED AT LINE 1737 IN MAIN.asm
ADD4:               021D DEFINED AT LINE 195 IN MAIN.asm
                    > USED AT LINE 191 IN MAIN.asm
AMPER_:             0220 DEFINED AT LINE 198 IN MAIN.asm
AND:                0220 DEFINED AT LINE 199 IN MAIN.asm
AND1:               0227 DEFINED AT LINE 207 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
PIPE_:              022B DEFINED AT LINE 212 IN MAIN.asm
OR:                 022B DEFINED AT LINE 213 IN MAIN.asm
AT_:                0234 DEFINED AT LINE 226 IN MAIN.asm
ADDR:               0234 DEFINED AT LINE 227 IN MAIN.asm
BANG_:              023E DEFINED AT LINE 232 IN MAIN.asm
NOT:                0248 DEFINED AT LINE 240 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
MINUS_:             024E DEFINED AT LINE 245 IN MAIN.asm
SUB:                0259 DEFINED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
SUB1:               0263 DEFINED AT LINE 260 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
NUM_:               026B DEFINED AT LINE 268 IN MAIN.asm
                    > USED AT LINE 252 IN MAIN.asm
EQ_:                026E DEFINED AT LINE 271 IN MAIN.asm
EQ0_:               0277 DEFINED AT LINE 278 IN MAIN.asm
EQ1:                0278 DEFINED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 243 IN MAIN.asm
GT_:                027B DEFINED AT LINE 284 IN MAIN.asm
LT_:                0286 DEFINED AT LINE 292 IN MAIN.asm
LT1:                028F DEFINED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 291 IN MAIN.asm
EQUALS:             0296 DEFINED AT LINE 307 IN MAIN.asm
                    > USED AT LINE 282 IN MAIN.asm
NOTEQUALS:          029D DEFINED AT LINE 313 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
LESSTHANEQ:         02A4 DEFINED AT LINE 321 IN MAIN.asm
                    > USED AT LINE 301 IN MAIN.asm
LESSTHAN:           02A9 DEFINED AT LINE 328 IN MAIN.asm
                    > USED AT LINE 303 IN MAIN.asm
LESSTHAN1:          02AE DEFINED AT LINE 333 IN MAIN.asm
                    > USED AT LINE 324 IN MAIN.asm
TRUE1:              02B1 DEFINED AT LINE 336 IN MAIN.asm
                    > USED AT LINE 310 IN MAIN.asm
                    > USED AT LINE 316 IN MAIN.asm
                    > USED AT LINE 518 IN MAIN.asm
NULL1:              02B7 DEFINED AT LINE 340 IN MAIN.asm
FALSE1:             02B7 DEFINED AT LINE 341 IN MAIN.asm
                    > USED AT LINE 311 IN MAIN.asm
                    > USED AT LINE 317 IN MAIN.asm
                    > USED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
                    > USED AT LINE 695 IN MAIN.asm
NOP_:               02BB DEFINED AT LINE 344 IN MAIN.asm
RPAREN_:            02BD DEFINED AT LINE 346 IN MAIN.asm
DOLLAR_:            02C0 DEFINED AT LINE 348 IN MAIN.asm
LBRACK_:            02C3 DEFINED AT LINE 350 IN MAIN.asm
RBRACK_:            02C6 DEFINED AT LINE 352 IN MAIN.asm
PERCENT_:           02C9 DEFINED AT LINE 354 IN MAIN.asm
LPAREN_:            02CC DEFINED AT LINE 356 IN MAIN.asm
LBRACE_:            02CC DEFINED AT LINE 357 IN MAIN.asm
RBRACE_:            02CF DEFINED AT LINE 359 IN MAIN.asm
TICK_:              02D2 DEFINED AT LINE 361 IN MAIN.asm
SEMICOLON_:         02D5 DEFINED AT LINE 363 IN MAIN.asm
DOT_:               02D8 DEFINED AT LINE 365 IN MAIN.asm
COLON_:             02DB DEFINED AT LINE 367 IN MAIN.asm
UPCASE_:            02DE DEFINED AT LINE 369 IN MAIN.asm
LOWCASE_:           02E1 DEFINED AT LINE 371 IN MAIN.asm
QUESTION_:          02E4 DEFINED AT LINE 373 IN MAIN.asm
STAR_:              02E7 DEFINED AT LINE 375 IN MAIN.asm
HASH_:              02EA DEFINED AT LINE 377 IN MAIN.asm
CARET_:             02ED DEFINED AT LINE 379 IN MAIN.asm
COMMA_:             02F0 DEFINED AT LINE 381 IN MAIN.asm
DQUOTE_:            02F3 DEFINED AT LINE 383 IN MAIN.asm
BACKSLASH_:         02F6 DEFINED AT LINE 385 IN MAIN.asm
UNDERSCORE_:        02F9 DEFINED AT LINE 387 IN MAIN.asm
TILDE_:             02FC DEFINED AT LINE 389 IN MAIN.asm
SLASH_:             02FF DEFINED AT LINE 391 IN MAIN.asm
SLASH:              0301 DEFINED AT LINE 399 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
COMMAND:            0301 DEFINED AT LINE 400 IN MAIN.asm
COMMAND_A_:         0327 DEFINED AT LINE 435 IN MAIN.asm
COMMAND_B_:         0336 DEFINED AT LINE 448 IN MAIN.asm
COMMAND_I_:         0341 DEFINED AT LINE 457 IN MAIN.asm
COMMAND_M_:         034A DEFINED AT LINE 464 IN MAIN.asm
COMMAND_P_:         034D DEFINED AT LINE 467 IN MAIN.asm
COMMAND_Q_:         0356 DEFINED AT LINE 474 IN MAIN.asm
COMMAND_R_:         035F DEFINED AT LINE 481 IN MAIN.asm
COMMAND_S_:         0362 DEFINED AT LINE 484 IN MAIN.asm
COMMAND_V_:         0365 DEFINED AT LINE 487 IN MAIN.asm
COMMAND_NOP_:       0368 DEFINED AT LINE 490 IN MAIN.asm
DECIMAL_:           036A DEFINED AT LINE 493 IN MAIN.asm
DECIMAL1:           036D DEFINED AT LINE 495 IN MAIN.asm
                    > USED AT LINE 509 IN MAIN.asm
DIV_:               0372 DEFINED AT LINE 499 IN MAIN.asm
ERROR1_:            0376 DEFINED AT LINE 503 IN MAIN.asm
                    > USED AT LINE 446 IN MAIN.asm
                    > USED AT LINE 462 IN MAIN.asm
                    > USED AT LINE 472 IN MAIN.asm
                    > USED AT LINE 479 IN MAIN.asm
                    > USED AT LINE 702 IN MAIN.asm
                    > USED AT LINE 716 IN MAIN.asm
                    > USED AT LINE 733 IN MAIN.asm
                    > USED AT LINE 756 IN MAIN.asm
HEXADECIMAL_:       037C DEFINED AT LINE 507 IN MAIN.asm
KEY_:               0382 DEFINED AT LINE 511 IN MAIN.asm
                    > USED AT LINE 512 IN MAIN.asm
OUTPUT_:            0385 DEFINED AT LINE 514 IN MAIN.asm
TRUE_:              0388 DEFINED AT LINE 517 IN MAIN.asm
WORDS_:             038B DEFINED AT LINE 520 IN MAIN.asm
XOR_:               038E DEFINED AT LINE 523 IN MAIN.asm
XOR1:               038F DEFINED AT LINE 525 IN MAIN.asm
ABSOLUTE_:          0399 DEFINED AT LINE 538 IN MAIN.asm
ADDROF_:            03A6 DEFINED AT LINE 551 IN MAIN.asm
ARRAYITER_:         03A9 DEFINED AT LINE 554 IN MAIN.asm
ARRAYSIZE_:         03AC DEFINED AT LINE 559 IN MAIN.asm
BREAK_:             03B4 DEFINED AT LINE 568 IN MAIN.asm
COLDSTART_:         03B7 DEFINED AT LINE 572 IN MAIN.asm
BYTES_:             03BA DEFINED AT LINE 576 IN MAIN.asm
                    > USED AT LINE 455 IN MAIN.asm
BYTES1:             03BD DEFINED AT LINE 578 IN MAIN.asm
                    > USED AT LINE 617 IN MAIN.asm
INPUT_:             03C2 DEFINED AT LINE 584 IN MAIN.asm
PRINTCHARS_:        03CD DEFINED AT LINE 597 IN MAIN.asm
QUIT_:              03D4 DEFINED AT LINE 605 IN MAIN.asm
QUIT1:              03DB DEFINED AT LINE 611 IN MAIN.asm
                    > USED AT LINE 609 IN MAIN.asm
WORDS:              03DE DEFINED AT LINE 615 IN MAIN.asm
                    > USED AT LINE 521 IN MAIN.asm
COMMAND_F_:         03E4 DEFINED AT LINE 619 IN MAIN.asm
COMMENT:            03E6 DEFINED AT LINE 623 IN MAIN.asm
                    > USED AT LINE 404 IN MAIN.asm
                    > USED AT LINE 627 IN MAIN.asm
COMMAND_F:          0400 DEFINED AT LINE 636 IN MAIN.asm
                    > USED AT LINE 620 IN MAIN.asm
FOREACH_:           041B DEFINED AT LINE 661 IN MAIN.asm
FLUSH_:             041E DEFINED AT LINE 666 IN MAIN.asm
FILTER_:            0423 DEFINED AT LINE 670 IN MAIN.asm
FOLD_:              0426 DEFINED AT LINE 673 IN MAIN.asm
FUNCSRC_:           0429 DEFINED AT LINE 676 IN MAIN.asm
F1_:                042C DEFINED AT LINE 679 IN MAIN.asm
F2_:                042F DEFINED AT LINE 682 IN MAIN.asm
F3_:                0432 DEFINED AT LINE 685 IN MAIN.asm
F4_:                0435 DEFINED AT LINE 688 IN MAIN.asm
FZ_:                0438 DEFINED AT LINE 691 IN MAIN.asm
FALSE_:             043B DEFINED AT LINE 694 IN MAIN.asm
                    > USED AT LINE 659 IN MAIN.asm
COMMAND_M:          043E DEFINED AT LINE 697 IN MAIN.asm
                    > USED AT LINE 465 IN MAIN.asm
MAP_:               0447 DEFINED AT LINE 704 IN MAIN.asm
COMMAND_R:          044A DEFINED AT LINE 707 IN MAIN.asm
                    > USED AT LINE 482 IN MAIN.asm
RECUR_:             0457 DEFINED AT LINE 718 IN MAIN.asm
REMAIN_:            045D DEFINED AT LINE 723 IN MAIN.asm
COMMAND_S:          0463 DEFINED AT LINE 728 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
STRINGITER_:        046C DEFINED AT LINE 735 IN MAIN.asm
RANGESRC_:          046F DEFINED AT LINE 738 IN MAIN.asm
COMMAND_V:          0472 DEFINED AT LINE 741 IN MAIN.asm
                    > USED AT LINE 488 IN MAIN.asm
CONSTBUFSTART_:     0485 DEFINED AT LINE 758 IN MAIN.asm
CONSTHEAPSTART_:    048A DEFINED AT LINE 762 IN MAIN.asm
CONSTTIBSTART_:     048F DEFINED AT LINE 766 IN MAIN.asm
VARBUFPTR_:         0494 DEFINED AT LINE 770 IN MAIN.asm
VARHEAPPTR_:        049D DEFINED AT LINE 775 IN MAIN.asm
VARTIBPTR_:         04A6 DEFINED AT LINE 780 IN MAIN.asm
VARIABLE:           04AF DEFINED AT LINE 785 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 773 IN MAIN.asm
                    > USED AT LINE 778 IN MAIN.asm
                    > USED AT LINE 783 IN MAIN.asm
CONSTANT:           04B2 DEFINED AT LINE 787 IN MAIN.asm
                    > USED AT LINE 760 IN MAIN.asm
                    > USED AT LINE 764 IN MAIN.asm
                    > USED AT LINE 768 IN MAIN.asm
DOT:                04B5 DEFINED AT LINE 792 IN MAIN.asm
                    > USED AT LINE 366 IN MAIN.asm
DOTNUMBER_:         04C4 DEFINED AT LINE 807 IN MAIN.asm
                    > USED AT LINE 803 IN MAIN.asm
                    > USED AT LINE 1512 IN MAIN.asm
DOTSTRING_:         04CF DEFINED AT LINE 815 IN MAIN.asm
DOTSTRING0:         04D6 DEFINED AT LINE 819 IN MAIN.asm
                    > USED AT LINE 827 IN MAIN.asm
DOTSTRING1:         04DC DEFINED AT LINE 824 IN MAIN.asm
                    > USED AT LINE 818 IN MAIN.asm
DOTCHAR_:           04E9 DEFINED AT LINE 834 IN MAIN.asm
DOTXCHARS_:         04EE DEFINED AT LINE 840 IN MAIN.asm
DOTXCHARS0:         04EF DEFINED AT LINE 842 IN MAIN.asm
                    > USED AT LINE 836 IN MAIN.asm
DOTXCHARS1:         04F8 DEFINED AT LINE 848 IN MAIN.asm
                    > USED AT LINE 858 IN MAIN.asm
DOTXCHARS2:         0500 DEFINED AT LINE 855 IN MAIN.asm
                    > USED AT LINE 847 IN MAIN.asm
RANGESRC:           050A DEFINED AT LINE 32
                    > USED AT LINE 739 IN MAIN.asm
RANGESRCM_1297S870: 0519 DEFINED AT LINE 39
                    > USED AT LINE 35
ARRAYITER:          0586 DEFINED AT LINE 32
                    > USED AT LINE 555 IN MAIN.asm
ARRAYITERM_1316S890: 0593 DEFINED AT LINE 39
                    > USED AT LINE 35
STRINGITER:         0607 DEFINED AT LINE 32
                    > USED AT LINE 736 IN MAIN.asm
STRINGITERM_1335S910: 0614 DEFINED AT LINE 39
                    > USED AT LINE 35
MAP:                068D DEFINED AT LINE 32
                    > USED AT LINE 705 IN MAIN.asm
MAPM_1355S932:      069A DEFINED AT LINE 39
                    > USED AT LINE 35
FILTER:             06CF DEFINED AT LINE 32
                    > USED AT LINE 671 IN MAIN.asm
FILTERM_1369S947:   06DD DEFINED AT LINE 39
                    > USED AT LINE 35
FOLD:               072D DEFINED AT LINE 32
                    > USED AT LINE 674 IN MAIN.asm
FOLDM_1388S967:     073C DEFINED AT LINE 39
                    > USED AT LINE 35
FOREACH:            077F DEFINED AT LINE 32
                    > USED AT LINE 662 IN MAIN.asm
FOREACHM_1402S982:  078D DEFINED AT LINE 39
                    > USED AT LINE 35
FUNCSRC:            07CB DEFINED AT LINE 32
                    > USED AT LINE 677 IN MAIN.asm
FUNCSRCM_1416S997:  07D7 DEFINED AT LINE 39
                    > USED AT LINE 35
DOTARRAY:           0804 DEFINED AT LINE 32
DOTARRAYM_1426S1008: 0812 DEFINED AT LINE 39
                    > USED AT LINE 35
UNDERSCORE:         084C DEFINED AT LINE 1018 IN MAIN.asm
                    > USED AT LINE 388 IN MAIN.asm
TILDE:              084C DEFINED AT LINE 1019 IN MAIN.asm
                    > USED AT LINE 390 IN MAIN.asm
COMMA:              084C DEFINED AT LINE 1020 IN MAIN.asm
                    > USED AT LINE 382 IN MAIN.asm
COLON:              084E DEFINED AT LINE 1029 IN MAIN.asm
                    > USED AT LINE 368 IN MAIN.asm
BACKSLASH:          085B DEFINED AT LINE 1038 IN MAIN.asm
                    > USED AT LINE 386 IN MAIN.asm
LAMBDA:             085B DEFINED AT LINE 1039 IN MAIN.asm
LAMBDA1:            0860 DEFINED AT LINE 1042 IN MAIN.asm
                    > USED AT LINE 1046 IN MAIN.asm
LAMBDA2:            0870 DEFINED AT LINE 1051 IN MAIN.asm
                    > USED AT LINE 1048 IN MAIN.asm
DEFINESTART:        087C DEFINED AT LINE 1059 IN MAIN.asm
                    > USED AT LINE 1033 IN MAIN.asm
SEMICOLON:          0885 DEFINED AT LINE 1065 IN MAIN.asm
                    > USED AT LINE 364 IN MAIN.asm
DEFINEEND:          0885 DEFINED AT LINE 1066 IN MAIN.asm
DEFINEEND1:         0897 DEFINED AT LINE 1075 IN MAIN.asm
                    > USED AT LINE 1070 IN MAIN.asm
ADDROF:             0899 DEFINED AT LINE 1080 IN MAIN.asm
                    > USED AT LINE 552 IN MAIN.asm
ADDROF1:            08AD DEFINED AT LINE 1092 IN MAIN.asm
                    > USED AT LINE 1088 IN MAIN.asm
ADDROF2:            08B8 DEFINED AT LINE 1101 IN MAIN.asm
                    > USED AT LINE 1084 IN MAIN.asm
                    > USED AT LINE 1086 IN MAIN.asm
                    > USED AT LINE 1091 IN MAIN.asm
PERCENT:            08BA DEFINED AT LINE 1107 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
ARG:                08BA DEFINED AT LINE 1108 IN MAIN.asm
ARG0:               08D6 DEFINED AT LINE 1127 IN MAIN.asm
                    > USED AT LINE 1133 IN MAIN.asm
ARG0A:              08DF DEFINED AT LINE 1135 IN MAIN.asm
                    > USED AT LINE 1114 IN MAIN.asm
                    > USED AT LINE 1119 IN MAIN.asm
ARG1:               08E4 DEFINED AT LINE 1138 IN MAIN.asm
                    > USED AT LINE 1131 IN MAIN.asm
ARG1A:              08EC DEFINED AT LINE 1145 IN MAIN.asm
                    > USED AT LINE 1137 IN MAIN.asm
LBRACK:             08EF DEFINED AT LINE 1149 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
ARRAYSTART:         08EF DEFINED AT LINE 1150 IN MAIN.asm
RBRACK:             090B DEFINED AT LINE 1164 IN MAIN.asm
                    > USED AT LINE 353 IN MAIN.asm
ARRAYEND:           090B DEFINED AT LINE 1165 IN MAIN.asm
ARRAYEND1:          0927 DEFINED AT LINE 1182 IN MAIN.asm
                    > USED AT LINE 1199 IN MAIN.asm
ARRAYEND2:          0937 DEFINED AT LINE 1192 IN MAIN.asm
                    > USED AT LINE 1188 IN MAIN.asm
ARRAYEND3:          093C DEFINED AT LINE 1196 IN MAIN.asm
                    > USED AT LINE 1181 IN MAIN.asm
HASH:               095B DEFINED AT LINE 1219 IN MAIN.asm
                    > USED AT LINE 378 IN MAIN.asm
ARRAYINDEX:         095B DEFINED AT LINE 1220 IN MAIN.asm
ARRAYINDEX0:        0963 DEFINED AT LINE 1226 IN MAIN.asm
ARRAYINDEX1:        0964 DEFINED AT LINE 1228 IN MAIN.asm
                    > USED AT LINE 1225 IN MAIN.asm
ARRAYINDEX2:        0970 DEFINED AT LINE 1237 IN MAIN.asm
                    > USED AT LINE 1234 IN MAIN.asm
ASSIGN:             0973 DEFINED AT LINE 1242 IN MAIN.asm
                    > USED AT LINE 276 IN MAIN.asm
ASSIGN0:            0975 DEFINED AT LINE 1245 IN MAIN.asm
                    > USED AT LINE 181 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 259 IN MAIN.asm
ASSIGN1:            0979 DEFINED AT LINE 1248 IN MAIN.asm
                    > USED AT LINE 1074 IN MAIN.asm
ASSIGN2:            0982 DEFINED AT LINE 1255 IN MAIN.asm
                    > USED AT LINE 1252 IN MAIN.asm
LBRACE:             0984 DEFINED AT LINE 1260 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
RBRACE:             0989 DEFINED AT LINE 1264 IN MAIN.asm
                    > USED AT LINE 360 IN MAIN.asm
BLOCKEND:           0989 DEFINED AT LINE 1265 IN MAIN.asm
                    > USED AT LINE 612 IN MAIN.asm
                    > USED AT LINE 1340 IN MAIN.asm
BLOCKEND1:          09BB DEFINED AT LINE 1287 IN MAIN.asm
                    > USED AT LINE 1280 IN MAIN.asm
BLOCKEND2:          09C7 DEFINED AT LINE 1294 IN MAIN.asm
                    > USED AT LINE 1286 IN MAIN.asm
BLOCKEND3:          09D9 DEFINED AT LINE 1308 IN MAIN.asm
                    > USED AT LINE 1300 IN MAIN.asm
BLOCKEND4:          09ED DEFINED AT LINE 1318 IN MAIN.asm
                    > USED AT LINE 1316 IN MAIN.asm
BREAK:              09F6 DEFINED AT LINE 1325 IN MAIN.asm
                    > USED AT LINE 569 IN MAIN.asm
BREAK1:             09FD DEFINED AT LINE 1331 IN MAIN.asm
                    > USED AT LINE 1329 IN MAIN.asm
TICK:               0A10 DEFINED AT LINE 1342 IN MAIN.asm
                    > USED AT LINE 362 IN MAIN.asm
CHAR:               0A10 DEFINED AT LINE 1343 IN MAIN.asm
CHAR1:              0A13 DEFINED AT LINE 1345 IN MAIN.asm
                    > USED AT LINE 1356 IN MAIN.asm
CHAR2:              0A1F DEFINED AT LINE 1354 IN MAIN.asm
                    > USED AT LINE 1351 IN MAIN.asm
CHAR3:              0A22 DEFINED AT LINE 1357 IN MAIN.asm
                    > USED AT LINE 1349 IN MAIN.asm
DIV:                0A25 DEFINED AT LINE 1361 IN MAIN.asm
                    > USED AT LINE 501 IN MAIN.asm
BUFFERDEC:          0A36 DEFINED AT LINE 1374 IN MAIN.asm
                    > USED AT LINE 811 IN MAIN.asm
BUFFERDEC0:         0A50 DEFINED AT LINE 1391 IN MAIN.asm
                    > USED AT LINE 1378 IN MAIN.asm
BUFFERDEC1:         0A60 DEFINED AT LINE 1405 IN MAIN.asm
                    > USED AT LINE 1393 IN MAIN.asm
BUFFERDEC2:         0A80 DEFINED AT LINE 1419 IN MAIN.asm
                    > USED AT LINE 1408 IN MAIN.asm
                    > USED AT LINE 1410 IN MAIN.asm
                    > USED AT LINE 1412 IN MAIN.asm
                    > USED AT LINE 1414 IN MAIN.asm
                    > USED AT LINE 1417 IN MAIN.asm
BUFFERDEC3:         0A82 DEFINED AT LINE 1421 IN MAIN.asm
                    > USED AT LINE 1424 IN MAIN.asm
BUFFERDEC4:         0A92 DEFINED AT LINE 1433 IN MAIN.asm
                    > USED AT LINE 1428 IN MAIN.asm
BUFFERDEC5:         0A93 DEFINED AT LINE 1435 IN MAIN.asm
                    > USED AT LINE 1432 IN MAIN.asm
BUFFERHEX:          0A9C DEFINED AT LINE 1446 IN MAIN.asm
                    > USED AT LINE 810 IN MAIN.asm
BUFFERHEX1:         0ABD DEFINED AT LINE 1464 IN MAIN.asm
                    > USED AT LINE 1454 IN MAIN.asm
                    > USED AT LINE 1456 IN MAIN.asm
BUFFERHEX2:         0AC6 DEFINED AT LINE 1472 IN MAIN.asm
                    > USED AT LINE 1470 IN MAIN.asm
DIVIDE:             0AD4 DEFINED AT LINE 1486 IN MAIN.asm
                    > USED AT LINE 1366 IN MAIN.asm
DIVIDE1:            0AD9 DEFINED AT LINE 1489 IN MAIN.asm
                    > USED AT LINE 1501 IN MAIN.asm
DIVIDE2:            0AE6 DEFINED AT LINE 1497 IN MAIN.asm
                    > USED AT LINE 1494 IN MAIN.asm
DIVIDE3:            0AE7 DEFINED AT LINE 1499 IN MAIN.asm
                    > USED AT LINE 1496 IN MAIN.asm
FZ:                 0AED DEFINED AT LINE 1506 IN MAIN.asm
                    > USED AT LINE 692 IN MAIN.asm
CARET:              0AFA DEFINED AT LINE 1517 IN MAIN.asm
                    > USED AT LINE 380 IN MAIN.asm
GO:                 0AFA DEFINED AT LINE 1518 IN MAIN.asm
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
                    > USED AT LINE 33
GO1:                0AFB DEFINED AT LINE 1520 IN MAIN.asm
                    > USED AT LINE 1321 IN MAIN.asm
                    > USED AT LINE 1695 IN MAIN.asm
                    > USED AT LINE 1697 IN MAIN.asm
GO2:                0B01 DEFINED AT LINE 1525 IN MAIN.asm
                    > USED AT LINE 1523 IN MAIN.asm
GOBLOCK:            0B0C DEFINED AT LINE 1533 IN MAIN.asm
                    > USED AT LINE 1528 IN MAIN.asm
GOBLOCK2:           0B31 DEFINED AT LINE 1550 IN MAIN.asm
                    > USED AT LINE 1631 IN MAIN.asm
GOBLOCK3:           0B3B DEFINED AT LINE 1556 IN MAIN.asm
GOFUNC:             0B3F DEFINED AT LINE 1560 IN MAIN.asm
                    > USED AT LINE 1530 IN MAIN.asm
GOFUNC1:            0B58 DEFINED AT LINE 1579 IN MAIN.asm
                    > USED AT LINE 1589 IN MAIN.asm
GOFUNC2:            0B5E DEFINED AT LINE 1586 IN MAIN.asm
                    > USED AT LINE 1578 IN MAIN.asm
GOFUNC3:            0B69 DEFINED AT LINE 1592 IN MAIN.asm
                    > USED AT LINE 1568 IN MAIN.asm
GOFUNC4:            0B81 DEFINED AT LINE 1609 IN MAIN.asm
                    > USED AT LINE 1606 IN MAIN.asm
GOFUNC5:            0B84 DEFINED AT LINE 1612 IN MAIN.asm
                    > USED AT LINE 1618 IN MAIN.asm
GOFUNC6:            0B87 DEFINED AT LINE 1616 IN MAIN.asm
                    > USED AT LINE 1611 IN MAIN.asm
GOFUNC7:            0B8A DEFINED AT LINE 1619 IN MAIN.asm
GOFUNC8:            0B8E DEFINED AT LINE 1624 IN MAIN.asm
                    > USED AT LINE 1544 IN MAIN.asm
                    > USED AT LINE 1608 IN MAIN.asm
DOLLAR:             0B99 DEFINED AT LINE 1633 IN MAIN.asm
                    > USED AT LINE 349 IN MAIN.asm
HEXNUM:             0B99 DEFINED AT LINE 1634 IN MAIN.asm
HEXNUM1:            0B9C DEFINED AT LINE 1636 IN MAIN.asm
                    > USED AT LINE 1653 IN MAIN.asm
HEXNUM2:            0BA4 DEFINED AT LINE 1642 IN MAIN.asm
                    > USED AT LINE 1640 IN MAIN.asm
UPCASE:             0BB6 DEFINED AT LINE 1655 IN MAIN.asm
                    > USED AT LINE 370 IN MAIN.asm
LOWCASE:            0BBB DEFINED AT LINE 1659 IN MAIN.asm
                    > USED AT LINE 372 IN MAIN.asm
IDENT1:             0BC0 DEFINED AT LINE 1663 IN MAIN.asm
                    > USED AT LINE 1658 IN MAIN.asm
QUESTION:           0BCD DEFINED AT LINE 1676 IN MAIN.asm
                    > USED AT LINE 374 IN MAIN.asm
IF:                 0BCD DEFINED AT LINE 1677 IN MAIN.asm
IFTE:               0BD9 DEFINED AT LINE 1687 IN MAIN.asm
                    > USED AT LINE 1681 IN MAIN.asm
IFTE1:              0BDA DEFINED AT LINE 1689 IN MAIN.asm
                    > USED AT LINE 1684 IN MAIN.asm
KEY:                0BE6 DEFINED AT LINE 1699 IN MAIN.asm
OUTPUT:             0BEF DEFINED AT LINE 1708 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
STAR:               0BF8 DEFINED AT LINE 1717 IN MAIN.asm
                    > USED AT LINE 376 IN MAIN.asm
MUL:                0BF8 DEFINED AT LINE 1718 IN MAIN.asm
MUL2:               0BFA DEFINED AT LINE 1721 IN MAIN.asm
MUL3:               0C02 DEFINED AT LINE 1726 IN MAIN.asm
                    > USED AT LINE 1735 IN MAIN.asm
NUM:                0C14 DEFINED AT LINE 1739 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
NUM0:               0C1D DEFINED AT LINE 1745 IN MAIN.asm
                    > USED AT LINE 1743 IN MAIN.asm
NUM1:               0C1E DEFINED AT LINE 1747 IN MAIN.asm
                    > USED AT LINE 1764 IN MAIN.asm
NUM2:               0C36 DEFINED AT LINE 1765 IN MAIN.asm
                    > USED AT LINE 1644 IN MAIN.asm
                    > USED AT LINE 1646 IN MAIN.asm
                    > USED AT LINE 1750 IN MAIN.asm
                    > USED AT LINE 1752 IN MAIN.asm
NUM3:               0C41 DEFINED AT LINE 1773 IN MAIN.asm
                    > USED AT LINE 1768 IN MAIN.asm
RPAREN:             0C44 DEFINED AT LINE 1777 IN MAIN.asm
                    > USED AT LINE 347 IN MAIN.asm
SHIFTLEFT:          0C4C DEFINED AT LINE 1784 IN MAIN.asm
                    > USED AT LINE 296 IN MAIN.asm
SHIFTLEFT1:         0C54 DEFINED AT LINE 1791 IN MAIN.asm
                    > USED AT LINE 1794 IN MAIN.asm
SHIFTLEFT2:         0C55 DEFINED AT LINE 1793 IN MAIN.asm
                    > USED AT LINE 1790 IN MAIN.asm
SHIFTRIGHT:         0C5C DEFINED AT LINE 1801 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
SHIFTRIGHT1:        0C64 DEFINED AT LINE 1808 IN MAIN.asm
                    > USED AT LINE 1812 IN MAIN.asm
SHIFTRIGHT2:        0C68 DEFINED AT LINE 1811 IN MAIN.asm
                    > USED AT LINE 1807 IN MAIN.asm
DQUOTE:             0C6F DEFINED AT LINE 1820 IN MAIN.asm
                    > USED AT LINE 384 IN MAIN.asm
STRING:             0C6F DEFINED AT LINE 1821 IN MAIN.asm
STRING1:            0C78 DEFINED AT LINE 1828 IN MAIN.asm
                    > USED AT LINE 1837 IN MAIN.asm
STRING2:            0C7B DEFINED AT LINE 1832 IN MAIN.asm
                    > USED AT LINE 1827 IN MAIN.asm
STRING3:            0C84 DEFINED AT LINE 1838 IN MAIN.asm
                    > USED AT LINE 1835 IN MAIN.asm
PRINTCHARS1:        0C97 DEFINED AT LINE 1855 IN MAIN.asm
                    > USED AT LINE 1864 IN MAIN.asm
PRINTCHARS2:        0C9D DEFINED AT LINE 1860 IN MAIN.asm
                    > USED AT LINE 600 IN MAIN.asm
                    > USED AT LINE 2122 IN MAIN.asm
PARSEARGS:          0CA2 DEFINED AT LINE 1874 IN MAIN.asm
                    > USED AT LINE 1041 IN MAIN.asm
PARSEARGS1:         0CAC DEFINED AT LINE 1881 IN MAIN.asm
                    > USED AT LINE 1902 IN MAIN.asm
PARSEARGS1A:        0CB4 DEFINED AT LINE 1887 IN MAIN.asm
                    > USED AT LINE 1884 IN MAIN.asm
PARSEARGS2:         0CBC DEFINED AT LINE 1892 IN MAIN.asm
PARSEARGS3:         0CC4 DEFINED AT LINE 1900 IN MAIN.asm
                    > USED AT LINE 1886 IN MAIN.asm
                    > USED AT LINE 1898 IN MAIN.asm
PARSEARGS4:         0CC7 DEFINED AT LINE 1903 IN MAIN.asm
                    > USED AT LINE 1889 IN MAIN.asm
                    > USED AT LINE 1891 IN MAIN.asm
PARSEARGS5:         0CCD DEFINED AT LINE 1909 IN MAIN.asm
                    > USED AT LINE 1907 IN MAIN.asm
PARSEBLOCK:         0CD8 DEFINED AT LINE 1922 IN MAIN.asm
                    > USED AT LINE 1052 IN MAIN.asm
                    > USED AT LINE 1261 IN MAIN.asm
PARSEBLOCK1:        0CDC DEFINED AT LINE 1926 IN MAIN.asm
                    > USED AT LINE 1930 IN MAIN.asm
                    > USED AT LINE 1952 IN MAIN.asm
                    > USED AT LINE 1955 IN MAIN.asm
                    > USED AT LINE 1960 IN MAIN.asm
                    > USED AT LINE 1964 IN MAIN.asm
PARSEBLOCK2:        0D08 DEFINED AT LINE 1953 IN MAIN.asm
                    > USED AT LINE 1940 IN MAIN.asm
                    > USED AT LINE 1942 IN MAIN.asm
                    > USED AT LINE 1944 IN MAIN.asm
PARSEBLOCK3:        0D0B DEFINED AT LINE 1956 IN MAIN.asm
                    > USED AT LINE 1947 IN MAIN.asm
                    > USED AT LINE 1949 IN MAIN.asm
                    > USED AT LINE 1951 IN MAIN.asm
PARSEBLOCK4:        0D13 DEFINED AT LINE 1962 IN MAIN.asm
                    > USED AT LINE 1933 IN MAIN.asm
                    > USED AT LINE 1935 IN MAIN.asm
                    > USED AT LINE 1937 IN MAIN.asm
PARSEBLOCK5:        0D16 DEFINED AT LINE 1965 IN MAIN.asm
                    > USED AT LINE 1961 IN MAIN.asm
PARSEBLOCK6:        0D3E DEFINED AT LINE 1984 IN MAIN.asm
                    > USED AT LINE 1971 IN MAIN.asm
CREATEFUNC:         0D42 DEFINED AT LINE 1992 IN MAIN.asm
                    > USED AT LINE 1053 IN MAIN.asm
CREATEFUNC0:        0D61 DEFINED AT LINE 2006 IN MAIN.asm
                    > USED AT LINE 2002 IN MAIN.asm
CREATEFUNC1:        0D79 DEFINED AT LINE 2025 IN MAIN.asm
                    > USED AT LINE 2021 IN MAIN.asm
CREATEFUNC2:        0D8C DEFINED AT LINE 2038 IN MAIN.asm
                    > USED AT LINE 2034 IN MAIN.asm
CREATEFUNC2A:       0DAB DEFINED AT LINE 2064 IN MAIN.asm
                    > USED AT LINE 2051 IN MAIN.asm
CREATEFUNC3:        0DBA DEFINED AT LINE 2076 IN MAIN.asm
                    > USED AT LINE 2086 IN MAIN.asm
CREATEFUNC4:        0DC5 DEFINED AT LINE 2087 IN MAIN.asm
CREATEFUNC5:        0DC6 DEFINED AT LINE 2089 IN MAIN.asm
                    > USED AT LINE 2005 IN MAIN.asm
FLUSHBUFFER:        0DE4 DEFINED AT LINE 2113 IN MAIN.asm
                    > USED AT LINE 667 IN MAIN.asm
                    > USED AT LINE 822 IN MAIN.asm
                    > USED AT LINE 853 IN MAIN.asm
                    > USED AT LINE 1383 IN MAIN.asm
                    > USED AT LINE 1440 IN MAIN.asm
                    > USED AT LINE 1452 IN MAIN.asm
                    > USED AT LINE 1460 IN MAIN.asm
                    > USED AT LINE 1480 IN MAIN.asm
                    > USED AT LINE 2303 IN MAIN.asm
COMMANDTABLE:       0DFB DEFINED AT LINE 2128 IN MAIN.asm
                    > USED AT LINE 406 IN MAIN.asm
COMMANDTABLE1:      0E05 DEFINED AT LINE 2135 IN MAIN.asm
                    > USED AT LINE 2144 IN MAIN.asm
COMMANDTABLE2:      0E0A DEFINED AT LINE 2141 IN MAIN.asm
                    > USED AT LINE 2132 IN MAIN.asm
                    > USED AT LINE 2134 IN MAIN.asm
JUMPTABLE:          0E0F DEFINED AT LINE 2150 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 436 IN MAIN.asm
                    > USED AT LINE 449 IN MAIN.asm
                    > USED AT LINE 458 IN MAIN.asm
                    > USED AT LINE 468 IN MAIN.asm
                    > USED AT LINE 475 IN MAIN.asm
                    > USED AT LINE 637 IN MAIN.asm
                    > USED AT LINE 698 IN MAIN.asm
                    > USED AT LINE 708 IN MAIN.asm
                    > USED AT LINE 729 IN MAIN.asm
                    > USED AT LINE 742 IN MAIN.asm
                    > USED AT LINE 793 IN MAIN.asm
JUMPTABLE0:         0E11 DEFINED AT LINE 2153 IN MAIN.asm
                    > USED AT LINE 2162 IN MAIN.asm
JUMPTABLE1:         0E1D DEFINED AT LINE 2163 IN MAIN.asm
                    > USED AT LINE 2159 IN MAIN.asm
JUMPTABLE2:         0E20 DEFINED AT LINE 2167 IN MAIN.asm
                    > USED AT LINE 2156 IN MAIN.asm
PRTSTR0:            0E23 DEFINED AT LINE 2172 IN MAIN.asm
                    > USED AT LINE 2178 IN MAIN.asm
PRTSTR:             0E27 DEFINED AT LINE 2175 IN MAIN.asm
                    > USED AT LINE 2242 IN MAIN.asm
                    > USED AT LINE 2299 IN MAIN.asm
NESTING:            0E2C DEFINED AT LINE 2191 IN MAIN.asm
                    > USED AT LINE 2325 IN MAIN.asm
                    > USED AT LINE 2383 IN MAIN.asm
NESTING0:           0E36 DEFINED AT LINE 2197 IN MAIN.asm
                    > USED AT LINE 2193 IN MAIN.asm
                    > USED AT LINE 2195 IN MAIN.asm
NESTING1A:          0E3D DEFINED AT LINE 2202 IN MAIN.asm
                    > USED AT LINE 2199 IN MAIN.asm
NESTING1:           0E40 DEFINED AT LINE 2205 IN MAIN.asm
                    > USED AT LINE 2196 IN MAIN.asm
NESTING2:           0E4F DEFINED AT LINE 2214 IN MAIN.asm
                    > USED AT LINE 2209 IN MAIN.asm
                    > USED AT LINE 2211 IN MAIN.asm
NESTING3:           0E51 DEFINED AT LINE 2217 IN MAIN.asm
                    > USED AT LINE 2213 IN MAIN.asm
NESTING4:           0E5C DEFINED AT LINE 2224 IN MAIN.asm
                    > USED AT LINE 2219 IN MAIN.asm
                    > USED AT LINE 2221 IN MAIN.asm
PROMPT:             0E5E DEFINED AT LINE 2228 IN MAIN.asm
                    > USED AT LINE 2304 IN MAIN.asm
CRLF:               0E67 DEFINED AT LINE 2233 IN MAIN.asm
                    > USED AT LINE 2396 IN MAIN.asm
PRINTSTR:           0E6E DEFINED AT LINE 2240 IN MAIN.asm
                    > USED AT LINE 2229 IN MAIN.asm
                    > USED AT LINE 2234 IN MAIN.asm
                    > USED AT LINE 2453 IN MAIN.asm
INIT:               0E75 DEFINED AT LINE 2247 IN MAIN.asm
                    > USED AT LINE 2296 IN MAIN.asm
INIT1:              0E7D DEFINED AT LINE 2251 IN MAIN.asm
                    > USED AT LINE 2257 IN MAIN.asm
WARMINIT:           0E85 DEFINED AT LINE 2259 IN MAIN.asm
COLDBOOT0:          0E98 DEFINED AT LINE 2266 IN MAIN.asm
                    > USED AT LINE 2254 IN MAIN.asm
                    > USED AT LINE 2292 IN MAIN.asm
COLDINIT:           0EA2 DEFINED AT LINE 2272 IN MAIN.asm
COLDBOOT1:          0EB3 DEFINED AT LINE 2281 IN MAIN.asm
                    > USED AT LINE 2284 IN MAIN.asm
COLDSTART:          0EC0 DEFINED AT LINE 2290 IN MAIN.asm
                    > USED AT LINE 573 IN MAIN.asm
START:              0EC9 DEFINED AT LINE 2294 IN MAIN.asm
                    > USED AT LINE 7
START1:             0ECF DEFINED AT LINE 2297 IN MAIN.asm
                    > USED AT LINE 2264 IN MAIN.asm
                    > USED AT LINE 2293 IN MAIN.asm
INTERPRET:          0ED5 DEFINED AT LINE 2301 IN MAIN.asm
                    > USED AT LINE 2429 IN MAIN.asm
                    > USED AT LINE 2444 IN MAIN.asm
                    > USED AT LINE 2461 IN MAIN.asm
                    > USED AT LINE 2464 IN MAIN.asm
                    > USED AT LINE 2469 IN MAIN.asm
INTERPRET2:         0EE4 DEFINED AT LINE 2310 IN MAIN.asm
                    > USED AT LINE 2374 IN MAIN.asm
                    > USED AT LINE 2451 IN MAIN.asm
                    > USED AT LINE 2455 IN MAIN.asm
INTERPRET3:         0EEC DEFINED AT LINE 2318 IN MAIN.asm
                    > USED AT LINE 2331 IN MAIN.asm
INTERPRET4:         0EF7 DEFINED AT LINE 2327 IN MAIN.asm
                    > USED AT LINE 2316 IN MAIN.asm
INTERPRET5:         0EFC DEFINED AT LINE 2334 IN MAIN.asm
                    > USED AT LINE 2384 IN MAIN.asm
                    > USED AT LINE 2399 IN MAIN.asm
INTERPRET5A:        0F1A DEFINED AT LINE 2371 IN MAIN.asm
INTERPRET6:         0F1C DEFINED AT LINE 2376 IN MAIN.asm
                    > USED AT LINE 2338 IN MAIN.asm
INTERPRET7:         0F2A DEFINED AT LINE 2386 IN MAIN.asm
                    > USED AT LINE 2343 IN MAIN.asm
INTERPRET8:         0F3D DEFINED AT LINE 2401 IN MAIN.asm
                    > USED AT LINE 2341 IN MAIN.asm
NEXT:               0F58 DEFINED AT LINE 2414 IN MAIN.asm
                    > USED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 2418 IN MAIN.asm
NEXT1:              0F68 DEFINED AT LINE 2426 IN MAIN.asm
                    > USED AT LINE 2419 IN MAIN.asm
EXIT:               0F6F DEFINED AT LINE 2431 IN MAIN.asm
                    > USED AT LINE 2428 IN MAIN.asm
RUN:                0F73 DEFINED AT LINE 2435 IN MAIN.asm
                    > USED AT LINE 2442 IN MAIN.asm
                    > USED AT LINE 2459 IN MAIN.asm
                    > USED AT LINE 2467 IN MAIN.asm
ERROR:              0F77 DEFINED AT LINE 2440 IN MAIN.asm
                    > USED AT LINE 505 IN MAIN.asm
                    > USED AT LINE 1036 IN MAIN.asm
                    > USED AT LINE 1050 IN MAIN.asm
BACKSPACE_:         0F8B DEFINED AT LINE 2448 IN MAIN.asm
                    > USED AT LINE 2348 IN MAIN.asm
EDIT_:              0F9B DEFINED AT LINE 2458 IN MAIN.asm
                    > USED AT LINE 2346 IN MAIN.asm
REEDIT_:            0FB3 DEFINED AT LINE 2463 IN MAIN.asm
                    > USED AT LINE 2350 IN MAIN.asm
PRINTSTACK_:        0FB6 DEFINED AT LINE 2466 IN MAIN.asm
F1:                 0FC0 DEFINED AT LINE 10
                    > USED AT LINE 680 IN MAIN.asm
F2:                 0FC0 DEFINED AT LINE 11
                    > USED AT LINE 683 IN MAIN.asm
F3:                 0FC0 DEFINED AT LINE 12
                    > USED AT LINE 686 IN MAIN.asm
F4:                 0FC0 DEFINED AT LINE 13
                    > USED AT LINE 689 IN MAIN.asm
STKSIZE:            0100 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 6 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
BUFSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
STACK:              2100 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 6
                    > USED AT LINE 1507 IN MAIN.asm
                    > USED AT LINE 1535 IN MAIN.asm
                    > USED AT LINE 2287 IN MAIN.asm
                    > USED AT LINE 2291 IN MAIN.asm
                    > USED AT LINE 2295 IN MAIN.asm
TIB:                2100 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 767 IN MAIN.asm
                    > USED AT LINE 2307 IN MAIN.asm
                    > USED AT LINE 2315 IN MAIN.asm
                    > USED AT LINE 2378 IN MAIN.asm
                    > USED AT LINE 2388 IN MAIN.asm
                    > USED AT LINE 2403 IN MAIN.asm
                    > USED AT LINE 2406 IN MAIN.asm
BUF:                2200 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 759 IN MAIN.asm
                    > USED AT LINE 2118 IN MAIN.asm
VARS:               2300 DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 1094 IN MAIN.asm
                    > USED AT LINE 2278 IN MAIN.asm
RESTARTS:           23D0 DEFINED AT LINE 18 IN ram.asm
RST08:              23D0 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
RST10:              23D2 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 114 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
RST18:              23D4 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 121 IN IOSerial.asm
                    > USED AT LINE 455 IN IOSerial.asm
RST20:              23D6 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RST28:              23D8 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
RST30:              23DA DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
BAUD:               23DC DEFINED AT LINE 26 IN ram.asm
INTVEC:             23DE DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 149 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
NMIVEC:             23E0 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 197 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
GETCVEC:            23E2 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 441 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
PUTCVEC:            23E4 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
SYSVARS:            23E6 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 2274 IN MAIN.asm
VDATAWIDTH:         23E6 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 579 IN MAIN.asm
                    > USED AT LINE 1186 IN MAIN.asm
                    > USED AT LINE 1223 IN MAIN.asm
                    > USED AT LINE 1250 IN MAIN.asm
VNUMBASE:           23E8 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 808 IN MAIN.asm
VTIBPTR:            23EA DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 781 IN MAIN.asm
                    > USED AT LINE 782 IN MAIN.asm
                    > USED AT LINE 2308 IN MAIN.asm
                    > USED AT LINE 2405 IN MAIN.asm
VBUFPTR:            23EC DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 771 IN MAIN.asm
                    > USED AT LINE 772 IN MAIN.asm
                    > USED AT LINE 817 IN MAIN.asm
                    > USED AT LINE 828 IN MAIN.asm
                    > USED AT LINE 829 IN MAIN.asm
                    > USED AT LINE 846 IN MAIN.asm
                    > USED AT LINE 859 IN MAIN.asm
                    > USED AT LINE 1375 IN MAIN.asm
                    > USED AT LINE 1384 IN MAIN.asm
                    > USED AT LINE 1385 IN MAIN.asm
                    > USED AT LINE 1448 IN MAIN.asm
                    > USED AT LINE 1461 IN MAIN.asm
                    > USED AT LINE 2117 IN MAIN.asm
                    > USED AT LINE 2119 IN MAIN.asm
VNEXT:              23EE DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 2286 IN MAIN.asm
VHEAPPTR:           23F0 DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 776 IN MAIN.asm
                    > USED AT LINE 777 IN MAIN.asm
                    > USED AT LINE 1175 IN MAIN.asm
                    > USED AT LINE 1209 IN MAIN.asm
                    > USED AT LINE 1213 IN MAIN.asm
                    > USED AT LINE 1822 IN MAIN.asm
                    > USED AT LINE 1842 IN MAIN.asm
                    > USED AT LINE 1876 IN MAIN.asm
                    > USED AT LINE 1911 IN MAIN.asm
                    > USED AT LINE 1979 IN MAIN.asm
                    > USED AT LINE 1982 IN MAIN.asm
                    > USED AT LINE 2004 IN MAIN.asm
                    > USED AT LINE 2009 IN MAIN.asm
                    > USED AT LINE 2040 IN MAIN.asm
                    > USED AT LINE 2106 IN MAIN.asm
VRECUR:             23F2 DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 720 IN MAIN.asm
                    > USED AT LINE 1313 IN MAIN.asm
                    > USED AT LINE 1320 IN MAIN.asm
VDEFINE:            23F4 DEFINED AT LINE 43 IN ram.asm
                    > USED AT LINE 1062 IN MAIN.asm
                    > USED AT LINE 1067 IN MAIN.asm
                    > USED AT LINE 1072 IN MAIN.asm
VPOINTER:           23F6 DEFINED AT LINE 47 IN ram.asm
                    > USED AT LINE 228 IN MAIN.asm
                    > USED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 786 IN MAIN.asm
                    > USED AT LINE 1061 IN MAIN.asm
                    > USED AT LINE 1141 IN MAIN.asm
                    > USED AT LINE 1230 IN MAIN.asm
                    > USED AT LINE 1247 IN MAIN.asm
                    > USED AT LINE 1667 IN MAIN.asm
VREMAIN:            23F8 DEFINED AT LINE 48 IN ram.asm
                    > USED AT LINE 724 IN MAIN.asm
                    > USED AT LINE 1368 IN MAIN.asm
VSAVEDIP:           23FA DEFINED AT LINE 50 IN ram.asm
                    > USED AT LINE 2260 IN MAIN.asm
                    > USED AT LINE 2408 IN MAIN.asm
VSAVEDSP:           23FC DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 2261 IN MAIN.asm
                    > USED AT LINE 2409 IN MAIN.asm
VSAVEDNEXT:         23FE DEFINED AT LINE 52 IN ram.asm
                    > USED AT LINE 2262 IN MAIN.asm
                    > USED AT LINE 2410 IN MAIN.asm
VSAVEDBP:           2400 DEFINED AT LINE 53 IN ram.asm
                    > USED AT LINE 2263 IN MAIN.asm
                    > USED AT LINE 2411 IN MAIN.asm
VTEMP1:             2402 DEFINED AT LINE 57 IN ram.asm
                    > USED AT LINE 1168 IN MAIN.asm
                    > USED AT LINE 1214 IN MAIN.asm
                    > USED AT LINE 1268 IN MAIN.asm
                    > USED AT LINE 1312 IN MAIN.asm
                    > USED AT LINE 1534 IN MAIN.asm
                    > USED AT LINE 1540 IN MAIN.asm
                    > USED AT LINE 1569 IN MAIN.asm
                    > USED AT LINE 1590 IN MAIN.asm
                    > USED AT LINE 1597 IN MAIN.asm
                    > USED AT LINE 1603 IN MAIN.asm
                    > USED AT LINE 1974 IN MAIN.asm
                    > USED AT LINE 1983 IN MAIN.asm
                    > USED AT LINE 1995 IN MAIN.asm
                    > USED AT LINE 2107 IN MAIN.asm
VTEMP2:             2404 DEFINED AT LINE 58 IN ram.asm
                    > USED AT LINE 1271 IN MAIN.asm
                    > USED AT LINE 1311 IN MAIN.asm
                    > USED AT LINE 1570 IN MAIN.asm
                    > USED AT LINE 1591 IN MAIN.asm
                    > USED AT LINE 1997 IN MAIN.asm
                    > USED AT LINE 2097 IN MAIN.asm
VTEMP3:             2406 DEFINED AT LINE 59 IN ram.asm
                    > USED AT LINE 1994 IN MAIN.asm
                    > USED AT LINE 2108 IN MAIN.asm
VLASTDEF:           2408 DEFINED AT LINE 60 IN ram.asm
TBPTR:              240A DEFINED AT LINE 61 IN ram.asm
TITLEBUF:           240C DEFINED AT LINE 63 IN ram.asm
                    > USED AT LINE 2249 IN MAIN.asm
                    > USED AT LINE 2268 IN MAIN.asm
                    > USED AT LINE 2298 IN MAIN.asm
HEAP:               2420 DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 159 IN MAIN.asm
                    > USED AT LINE 763 IN MAIN.asm
                    > USED AT LINE 1967 IN MAIN.asm
