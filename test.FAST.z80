.engine mycomputer

.include "constants.asm"
.include "test.fast.mac.asm"

.include "IOSerial.asm"

    jp testsStart

.include "MAIN.asm"

FUNC f1, 0, ""                               
db 0

FUNC f2, 0, ""                               
db 0

FUNC f3, 0, ""                  
db 0

FUNC f4, 0, ""                  
db 0

.align $100
testsStart:

    ; test "0 10 1 /rg \\a{%a.} /fe", 0
    ; test "0 10 1 /rg \\a{%a 1 + 10 *} /mp \\a{%a.} /fe", 0
    ; test "0 10 1 /rg \\a{%a 3<}/ft \\a{%a.} /fe", 0
    ; test "0 10 1 /rg  0 \\da{%d%a+}/fd \\a{%a 24<}/ft \\a{%a.} /fe", 0
    ; test "[10 20 30] /ai \\a{%a.} /fe", 0
    ; test "[1 2 3].a", 0
    ; test "/sb `hello:` 65.c 1. 2. 3. /se .s", FALSE
    ; test "`hello:` 65.c 1. 2. 3.", FALSE
    ; test "/hx/bm$1234.",0
    ; test "/bm257.",0
    
    ; test "$1000 'hello there!' /si \\a{%a.c} /fe", $1000

    ; test "10 0 -1 /rg \\a{%a.} /fe", 0
    ; test "0 10 1 /f1 \\a{%a.} /fe", 0

    ; test "0 x = 2 x + = x .", false

    ; test "[_A {100} _B {200} _P {300}] A=  A {-1} /sel", 1


    test "7 3 /", 2
    call printStr
    .cstr "Done!"
    HALT

    test "/f", false
    test "/t", true
    test "1", 1
    test "2", 2
    test "1", 1
    test "0", 0
    test "10", 10
    test "123", 123
    test "-1",-1
    test "-1/ab",1
    test "_a", $61
    test "__", $5F
    test "$10", $10
    test "$FF", $FF
    test "-1 2 +",1
    test "-1 1 +",0
    test "1 2 +", 3
    test "4 1 2 +", 3
    test "123 456 +", 123+456
    test "64 128 +", 64+128
    test "1 2 +", 3
    test "1a= a++ a",2
    test "-1 -1 -",0
    test "5 3 -", 2
    test "2 1 -",1
    test "3a= a-- a",2
    test "3 5 &", 1
    test "3 5 |", 7
    test "3 5 /x", 6
    test "3a= 5 a/x a= a",6
    test "0 !", true
    test "2 !", false
    test "0 !!", false
    test "2 !!", true
    test "2 3 *", 6
    test "1 2 3 + *", 5
    test "7 3 /", 2
    test "100a= 1a+= a", 101
    test "100a= 1a-= a", 99
    test "100a= 2a*= a", 200
    test "100a= 2 a/= a", 50
    test "2a= 3b= a b+= b", 5
    test "2a= 3b= a b-= b", 1
    test "2a= 3b= a b*= b", 6
    test "2a= 6b= a b/= b", 3
    test "$55a= $AAa&= a",0
    test "$55a= $AAa|= a",$FF
    test "$A5a= $AAa /x= a",$0F
    test "$00AA~",$FF55
    test "$AAAAa= a~= a",$5555
    test "3x= 1 x <<= x", 6
    test "10x= 1 x >>= x", 5
    test "7 3 / /re", 1
    test "7 3 /", 2
    test "2 3 ==", FALSE
    test "3 3 ==", TRUE
    test "1 2 <", TRUE
    test "2 1 <", FALSE
    test "2 3 <", TRUE
    test "3 3 <", FALSE
    test "1 2 >", FALSE
    test "2 1 >", TRUE
    test "3 3 >", FALSE
    test "4 3 >", TRUE
    test "2 2 <=", TRUE
    test "2 2 >=", TRUE
    test "3 1 <<", 6
    test "10 1 >>", 5
    test "1 x = x", 1
    test "1{}^", 1
    test "{1}^", 1
    test "{{1}^}^", 1
    test "{{{1}^}^}^", 1
    test "1 /f{10}{20} ? +", 21
    test "1 /t{10}{20} ? +", 11
    test "\\{2}^", 2
    test "\\a{2}^", 2
    test "5 \\a{%a}^", 5
    test "5 \\a:b{%a}^", 5
    test "\\a{{2}^}^", 2
    test "1 5 \\a{{%a}^}^", 5
    test "1 5 \\ab{{%a}^}^", 1
    test "1 5 \\a{{%a 2 +}^}^", 7
    test "1 5 \\ab{{%a %b +}^}^", 6
    test "\\a{2} x= 1 x^", 2
    test "\\a{%a} x= 0 1 x^", 1
    test "\\ab{%b} x= 1 2 x^", 2
    test "\\a:b{%a} x= 1 2 x^", 2
    test "\\ab{%b} x= 1 2 x^", 2
    test "\\ab{%b %a} x= 10 15 x^ -", 5
    test "\\a:b{2} x= 1 x^", 2
    test "\\:b{100 %b = %b} x= x^", 100
    test "\\a:b{1 %b = %b} x= 2 x^", 1
    test "\\a:b{%a %b = %b} x= 2 x^", 2
    test "1 10 20 \\ab{/t{%a}{%b} ?}^ +", 11
    test "1 10 20 \\ab{/f{%a}{%b} ?}^ +", 21
    test "[10 20 30] 1;", 20
    test "[10 20 30 40] /al", 4
    test "/bm [1 2 3] 1;", 2
    test "/bm [_A _B _C] 1;", 66
    test "[{10}{20}{30}] 0;^ ", 10
    test "10 20 \\ab{[{%a}{%b}] 0;^}^", 10
    test "0 10 20 \\iab{[{%a}{%b}] %i;^}^", 10
    test "1 10 20 \\iab{[{%a}{%b}] %i;^}^", 20
    test "3i= ( i i-- i/br )^ + +", 6
    test "3i= [ ( i i-- i/br )^ ] 1;", 2
    test "0 j= 4 i= ( i j + j= i i-- i/br )^ j ", 10
    test "0j= 0i= ( i j+= i++ i 5< /br )^ j ", 10
    test "0t= 3i= (4j= (t++ j-- j/br)^ i-- i/br)^ t", 12
    test "3 \\a:bc{%a %c = ( %c %c -- %c /br )^ + +}^", 6
    test "/t \\f{1 %f/br 2 +}^",3
    test "/f \\f{1 %f/br 2 +}^",1
    test "_A 1 - /ad", NUL
    test "_Z 1 + /ad", NUL
    test "_a 1 - /ad", NUL
    test "_z 1 + /ad", NUL
    test "_z /ad", VARS + (("z"-"a")+("Z"-"A")+1)*2
    test "_a /ad", VARS + ("Z"-"A"+1)*2
    test "_Z /ad", VARS + ("Z"-"A")*2
    test "_A /ad", VARS
    test "\\a{%a} F=1F^", 1
    test "1 \\b{\\a{%a}}^F= 3F^",3
    test "1 \\b{\\a{%a%b-}}^F= 3F^",2
    test "1 \\b{\\a:c{%a%b-%c= %c--%c}}^F= 3F^",1
    test "1 \\b:c{\\a{%a%b-%c= %c--%c}}^F= 3F^",1
    test "1 \\b:c{\\a:d{%a%b-%c= %c--%c %d= %d++%d}}^F= 3F^",2
    test "'hello'/sl",5
    test "'hello' 'hell' /sc", false
    test "'hello' 'hello' /sc", true
    test "[1 2 3]** + +", 6
    test "/bm[_a [_b _c]** _d]2;", $63

    ; ; test "$1000 0 10 1 /rg \\a{%a 1 + 10 *} /mp \\a{%a.} /fe", $1000

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    call printStr
    .cstr "Done!"
    HALT
    
.include "test.fast.util.asm"
.include "ram.asm"

; FUNC rangeSrc, 1, "besL"            ; range source: begin, end, step, local: L                 
; db "{"
; db    "[%b /t] %L="                 ; init mutable L [index active]                           
; db    "\\kt{"                            
; db      "0%t!=/qt"                  ; break if type != 0 
; db      "\\dt:a{"                   ; return talkback to receive data
; db        "%L1;!/qt"                ; if not active don't send
; db        "%L0; %a="                ; store current index in A 
; db        "%s %L0; +="              ; inc value of index by step
; db        "1%t!=/qt"                ; break if type != 0
; db        "%a %e <"                 ; ifte: in range?
; db          "{%a 1}{/f %L1;= 0 2}"  ; ifte: /t index, /f active = false, quit
; db          "? %k/rc"              ; ifte: send to sink note: /rc recur      
; db      "} 0 %k^"                   ; init sink
; db    "}" 
; db "}" 
; db 0

; FUNC map, 0, "sf"                   ; map                 
; db "{"
; db    "\\kt{"                        
; db      "0%t!=/qt"                  ; break if type != 0  
; db      "\\dt{"                     ; call source with tb
; db        "1%t=="                   ; ifte: type == 1 ?
; db        "{%d %f^}{%d}"            ; ifte: func(data) or data
; db        "? %t %k^"               ; ifte: send to sink
; db      "} 0 %s^" 
; db    "}" 
; db "}" 
; db 0

; ; /ft filter
; ; src pred -- src1
; FUNC filter, 1, "spT"               ; filter: source, predicate, local: T  
; db "{"
; db    "[0]%T="
; db    "\\kt{"                       ; return talkback to receive data 
; db      "\\dt{"                     ; call source with tb
; db        "["
; db          "{%d %T0;= /t}"         ; case 0: store talkback in T[0], return true
; db          "{%d %p^}"              ; case 1: return boolean based on predicate
; db          "{/t}"                  ; case 2: return true
; db        "]%t;^"                   ; select on %t
; db        "{%d %t %k^}{0 1 %T0;^}"  ; ifte: true send d to sink, false send 1 to talkback
; db        "?"
; db      "} 0 %s^"                    
; db    "}" 
; db "}" 
; db 0

; FUNC forEach, 1, "spT"                               
; db "{"
; db    "[0]%T="
; db    "\\dt{"                       ; return talkback to receive data ; $56AA
; db      "2%t==/qt"                    ; if type == 2 skip
; db      "0%t=="                   ; ifte: type = 0 ?
; db      "{%d %T0;=}{%d %p^}"      ; ifte: 0: store talkback, 1: send data
; db      "?"                      ; ifte:
; db      "0 1 %T0;^"               ; 0 or 1: get next src data item
; db    "} 0 %s^" 
; db "}" 
; db 0

; FUNC fold, 1, "sirA"                       ; src, init, reducer                      
; db "{"                                  ; reducer: \\da{...}
; db    "[%i]%A="
; db    "\\kt{"                         ; return talkback to receive data 
; db      "\\dt{"                         ; call source with tb
; db        "1%t=="                       ; ifte: type == 1 ?
; db        "{ %d %A0; %r^ %A0;= %A0;}{%d}"      ; ifte: reduce -> acc, acc or data 
; db        "? %t %k^"                    ; ifte: send to sink
; db      "} 0 %s^"                    
; db    "}" 
; db "}" 
; db 0



; 