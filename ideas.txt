\abs
    dw abs1

\adr
@
    dw addr

\byt
\B
    dw bytes

\go
    dw call

\def
    dw def

\exec
    dw exec

\F
    dw false1

\frac
    dw frac

\fun
    dw func

\in
    dw input

\if
    dw if

\ife
    dw ifte

\key
    dw key

\let
    dw let

\rpt
    dw loop

\mod
%
    dw mod

\neg
\-
-1*
    dw neg

\0
    dw null1

\out
    dw output

\set
    dw set

\shl
<<
    dw shl

\shr
>>
    dw shr

\sqr
    dw sqrt1

\sel
    dw switch

\T
    dw true1

\int
\W
    dw words


Problem: reset
cold boot
warm boot

Problem: Too few variables
Mint variables are fast but they are few. 
26 general data vars a..z
26 function vars A..Z
Proposed change 1
allow any any letter to be used as data or function

Example:

: a 1 2 + . ;

36 A !
A @ .

This will allow code and data to be distributed across 52 variables
with 3 bytes per variable (1st byte the type, next two bytes a value or a pointer)
156 bytes
Proposed change 2

Expand namespace to two chars letter-number

e.g. a0 m9 z5 B3 H7 Z9 etc.

This will consume more RAM if implemented as an array of vars
(26 + 26) * 10 = 520 variables
with 3 bytes per variable (1st byte the type, next two bytes a value or a pointer)
1560 bytes

More compact solutions are possible
52 chars = 6 bits 
10 digits = 4 bits
Problem: variable syntax  
Accessing Mint variables is too fiddly. Too similar to Forth variables


Reading: a @
Writing: 100 a !
Proposed change
Implement something more similar to Forth's values
Recognising that reading is more common that writing, reading 
should be the default behaviour 
free up !

Reading: a
Writing: 
100 a ;		\\ assigns 100 to variable a
a .
> 100

{ + } \f a ;	\\ assigns a code block a and make it executable	
1 2 a .
> 3	 
Problem: single char operators
Operators are mostly single chars, this restricts the language 
for example to do the following C operation in Mint would require 3 <= 2

3 2 % % < = | 
Proposed change 
3 2 <=
Problem: brace characters
Bit-shift operators waste the { and } symbols which could be used for code blocks (see below)
Could be fixed with formal arguments
Proposed change 
Use C notation for bit-shift operators
#4000 1 <<			\\ #8000
#4000 2 >>			\\ #1000
Problem: negative numbers
Negative numbers are not easy to work with
1000_ .
> 4095
Proposed change
Support sign operator for parsing and printing decimal numbers
-1000 .
> 1000
Hexadecimal numbers will stay unsigned
Free up negate operator, can use -1* instead
Problem: stack juggling
Too many stack operators leads to unclear hard to read code
Prefer global variables
Even better: formal parameters, local variables (leave locals out for now)
Proposed change 0: deprecate stack operators
Remove stack all stack operators in favour of variables
This frees up " ' % ~ swap
Proposed change 1: formal args
Parameter stack and base pointer

number of parameters can be specified with \p
:A 3 \p $0 $1 $2 + + ;
10 20 30 A .
> 60

where 
3 \p indicates that there are 3 params which can now we addresses as $0 $1 $2
Proposed change 2
Parameter stack and a formal args block (a string)
:A (abc) $a $b $c + + ;
10 20 30 A 
> 60


